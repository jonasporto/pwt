#!/bin/bash
# pwt - Power Worktrees
# A generic tool for managing git worktrees across multiple projects
#
# Usage:
#   pwt create <branch> [base] [desc]   # Create worktree from branch
#   pwt list                            # List worktrees and status
#   pwt info [worktree]                 # Show worktree details
#   pwt remove <worktree>               # Remove worktree
#   pwt server                          # Start dev server
#   pwt fix-port [worktree]             # Fix port conflict
#   pwt auto-remove [target]            # Remove worktrees merged into target
#   pwt meta [action] [args]            # Manage worktree metadata
#   pwt project [action] [args]         # Manage project configs
#
# Project auto-detection:
#   pwt detects the current project from your working directory
#   or you can specify: pwt myproject create ...
#   or use flag: pwt --project myproject create ...
#
# First time setup:
#   pwt project init myproject
#   pwt project set myproject main_app ~/path/to/main/app
#   pwt project set myproject worktrees_dir ~/path/to/worktrees

set -euo pipefail

# PWT directory structure
# PWT_DIR can be overridden via environment for testing/sandbox
PWT_DIR="${PWT_DIR:-$HOME/.pwt}"
PWT_META_FILE="$PWT_DIR/meta.json"
PWT_PROJECTS_DIR="$PWT_DIR/projects"

# Legacy support - will be overridden by project config
METADATA_DIR="$PWT_DIR"
METADATA_FILE="$PWT_META_FILE"
PROJECTS_DIR="$PWT_PROJECTS_DIR"

# Current project context (set by detect_project or --project flag)
CURRENT_PROJECT=""
PROJECT_EXPLICIT=false  # true if project was specified via --project or first arg
MAIN_APP=""
WORKTREES_DIR=""
BRANCH_PREFIX=""
PROJECT_REMOTE=""
DEFAULT_BRANCH=""  # Detected from remote (master or main)
BASE_PORT=5000

# Performance: List cache and fetch state
LIST_CACHE_DIR="$PWT_DIR/cache"
LIST_CACHE_TTL=300  # 5 minutes
PREFETCH_DONE=false  # Track if we already fetched remote refs
LIST_QUICK_MODE=false  # Skip network operations
LIST_REFRESH_MODE=false  # Force refresh cache

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
DIM='\033[2m'
NC='\033[0m' # No Color

# Cross-platform sed in-place edit (BSD/GNU compatible)
sed_inplace() {
    local expr="$1"
    local file="$2"
    if sed --version >/dev/null 2>&1; then
        sed -i "$expr" "$file"        # GNU sed
    else
        sed -i '' "$expr" "$file"     # BSD sed (macOS)
    fi
}

# Check required command exists
# Usage: require_cmd <cmd> [optional]
# If optional=true, just warn instead of exit
require_cmd() {
    local cmd="$1"
    local optional="${2:-false}"

    if ! command -v "$cmd" >/dev/null 2>&1; then
        if [ "$optional" = true ]; then
            return 1
        else
            echo -e "${RED}Error: Required command not found: $cmd${NC}" >&2
            # Provide install hints for common tools
            case "$cmd" in
                git)
                    echo "Install: https://git-scm.com/downloads" >&2
                    echo "  macOS:  xcode-select --install" >&2
                    echo "  Ubuntu: sudo apt install git" >&2
                    ;;
                jq)
                    echo "Install: https://jqlang.github.io/jq/download/" >&2
                    echo "  macOS:  brew install jq" >&2
                    echo "  Ubuntu: sudo apt install jq" >&2
                    ;;
                fzf)
                    echo "Install: https://github.com/junegunn/fzf" >&2
                    echo "  macOS:  brew install fzf" >&2
                    echo "  Ubuntu: sudo apt install fzf" >&2
                    ;;
                lsof)
                    echo "Install:" >&2
                    echo "  macOS:  (pre-installed)" >&2
                    echo "  Ubuntu: sudo apt install lsof" >&2
                    ;;
                *)
                    echo "Please install $cmd to use this feature." >&2
                    ;;
            esac
            exit 1
        fi
    fi
    return 0
}

# Check dependencies early
check_dependencies() {
    require_cmd git
    require_cmd jq
    # Optional: lsof (for port checking), fzf (for select)
    # These are checked where needed, not at startup
}

# Ask user for confirmation (returns 0 for yes, 1 for no)
confirm_action() {
    local prompt="${1:-Continue?}"
    local response
    echo -n "$prompt [y/N] "
    read -r response
    case "$response" in
        [yY]|[yY][eE][sS]) return 0 ;;
        *) return 1 ;;
    esac
}

# Detect submodules and warn user (worktrees + submodules can be problematic)
# Returns 0 if ok to proceed, 1 if user aborted
detect_submodules() {
    local repo_path="${1:-$MAIN_APP}"

    # Check if .gitmodules exists
    if [ ! -f "$repo_path/.gitmodules" ]; then
        return 0
    fi

    echo -e "${YELLOW}⚠  Submodules detected (.gitmodules found)${NC}"

    # Check if any submodule is initialized
    if git -C "$repo_path" submodule status --recursive 2>/dev/null | grep -q '^[ +-]'; then
        echo -e "${YELLOW}⚠  Submodules are initialized${NC}"
        echo ""
        echo "Worktrees + submodules may behave unexpectedly."
        echo "Consider using clone mode for this project."
        echo ""
        echo "Options:"
        echo "  - Continue with worktree (may have issues)"
        echo "  - Use clone mode: pwt create --clone ..."
        echo ""

        if ! confirm_action "Continue with worktree?"; then
            echo "Aborted."
            return 1
        fi
    fi

    return 0
}

# Check if lsof is available (cache result for performance)
_lsof_available=""
has_lsof() {
    if [ -z "$_lsof_available" ]; then
        if command -v lsof >/dev/null 2>&1; then
            _lsof_available="yes"
        else
            _lsof_available="no"
        fi
    fi
    [ "$_lsof_available" = "yes" ]
}

# Get PIDs using a port (returns empty if lsof unavailable)
# Usage: get_pids_on_port <port>
get_pids_on_port() {
    local port="$1"
    if has_lsof; then
        lsof -ti ":$port" 2>/dev/null || true
    fi
    # Without lsof, we can't detect - return empty (assume free)
}

# Check if a port is occupied (returns 1 if occupied or unknown, 0 if free)
# Usage: is_port_free <port>
is_port_free() {
    local port="$1"
    if ! has_lsof; then
        # Without lsof, assume port is free (best effort)
        return 0
    fi
    ! lsof -ti ":$port" > /dev/null 2>&1
}

# Initialize PWT directory
init_pwt() {
    # Create directory structure if it doesn't exist
    if [ ! -d "$PWT_DIR" ]; then
        mkdir -p "$PWT_DIR"
        mkdir -p "$PWT_PROJECTS_DIR"
    fi

    # Create empty metadata file if it doesn't exist
    if [ ! -f "$PWT_META_FILE" ]; then
        echo '{}' > "$PWT_META_FILE"
    fi
}

# Alias for compatibility
init_metadata() {
    init_pwt
}

# ============================================
# List Cache Functions (performance optimization)
# ============================================

# Initialize cache directory
init_cache_dir() {
    [ -d "$LIST_CACHE_DIR" ] || mkdir -p "$LIST_CACHE_DIR"
}

# Get cache file path for current project
get_list_cache_file() {
    local project="${CURRENT_PROJECT:-unknown}"
    echo "$LIST_CACHE_DIR/list-${project}.txt"
}

# Check if cache exists and is fresh (< TTL)
is_list_cache_valid() {
    local cache_file=$(get_list_cache_file)
    [ ! -f "$cache_file" ] && return 1

    # Get cache file age in seconds
    local now=$(date +%s)
    local cache_mtime
    if stat --version >/dev/null 2>&1; then
        cache_mtime=$(stat -c %Y "$cache_file" 2>/dev/null)  # GNU stat
    else
        cache_mtime=$(stat -f %m "$cache_file" 2>/dev/null)  # BSD stat (macOS)
    fi
    [ -z "$cache_mtime" ] && return 1

    local age=$((now - cache_mtime))
    [ "$age" -lt "$LIST_CACHE_TTL" ]
}

# Read cached list output
read_list_cache() {
    local cache_file=$(get_list_cache_file)
    [ -f "$cache_file" ] && cat "$cache_file"
}

# Write list output to cache
write_list_cache() {
    init_cache_dir
    local cache_file=$(get_list_cache_file)
    cat > "$cache_file"
}

# Clear list cache for current project
clear_list_cache() {
    local cache_file=$(get_list_cache_file)
    [ -f "$cache_file" ] && rm -f "$cache_file" || true
}

# Read cached list with dirty-only filter
# Keeps headers (first 3 lines) and filters data lines for dirty status (! or ?)
read_list_cache_filtered() {
    local cache_file=$(get_list_cache_file)
    [ ! -f "$cache_file" ] && return 1
    head -3 "$cache_file"
    tail -n +4 "$cache_file" | grep -E '[!?]' || true
}

# Detect default branch from remote (master or main)
# Usage: detect_default_branch <repo_path>
# Sets DEFAULT_BRANCH global variable
detect_default_branch() {
    local repo="${1:-$MAIN_APP}"
    if [ -z "$repo" ] || [ ! -d "$repo" ]; then
        return
    fi

    # Try to get from remote HEAD
    local remote_head=$(git -C "$repo" symbolic-ref refs/remotes/origin/HEAD 2>/dev/null)
    if [ -n "$remote_head" ]; then
        DEFAULT_BRANCH="${remote_head#refs/remotes/origin/}"
        return
    fi

    # Fallback: check if main or master exists
    if git -C "$repo" rev-parse --verify origin/main >/dev/null 2>&1; then
        DEFAULT_BRANCH="main"
    elif git -C "$repo" rev-parse --verify origin/master >/dev/null 2>&1; then
        DEFAULT_BRANCH="master"
    else
        # Last resort default
        DEFAULT_BRANCH="master"
    fi
}

# Detect project from current directory
# Sets CURRENT_PROJECT, MAIN_APP, WORKTREES_DIR, BRANCH_PREFIX
detect_project() {
    local current_dir="${1:-}"
    # Get current dir, resolve symlinks for consistent comparison
    [ -z "$current_dir" ] && current_dir=$(pwd)
    # Resolve symlinks (e.g., /var -> /private/var on macOS)
    current_dir=$(cd "$current_dir" 2>/dev/null && pwd -P)

    # Already set via --project flag
    if [ -n "$CURRENT_PROJECT" ]; then
        load_project_config "$CURRENT_PROJECT"
        return 0
    fi

    # Search through existing configured projects
    if [ -d "$PWT_PROJECTS_DIR" ]; then
        for project_dir in "$PWT_PROJECTS_DIR"/*/; do
            [ -d "$project_dir" ] || continue
            local project_name=$(basename "$project_dir")
            local config_file="$project_dir/config.json"
            [ -f "$config_file" ] || continue

            local main_app=$(jq -r '.path // .main_app // empty' "$config_file")
            local worktrees_dir=$(jq -r '.worktrees_dir // empty' "$config_file")

            # Check if current dir is main_app or inside worktrees_dir
            # Resolve symlinks in config paths for consistent comparison
            if [ -n "$main_app" ] && [ -d "$main_app" ]; then
                local resolved_main=$(cd "$main_app" 2>/dev/null && pwd -P)
                case "$current_dir" in
                    "$resolved_main"*|"$resolved_main")
                        CURRENT_PROJECT="$project_name"
                        load_project_config "$project_name"
                        return 0
                        ;;
                esac
            fi
            if [ -n "$worktrees_dir" ] && [ -d "$worktrees_dir" ]; then
                local resolved_wt=$(cd "$worktrees_dir" 2>/dev/null && pwd -P)
                case "$current_dir" in
                    "$resolved_wt"*|"$resolved_wt")
                        CURRENT_PROJECT="$project_name"
                        load_project_config "$project_name"
                        return 0
                        ;;
                esac
            fi
        done
    fi

    # No configured project found - try auto-detect from git
    auto_detect_project "$current_dir" || true
    return 0
}

# Auto-detect project from git repository (zero-config)
auto_detect_project() {
    local current_dir="$1"

    # Find git root
    local git_root=$(git -C "$current_dir" rev-parse --show-toplevel 2>/dev/null)
    [ -z "$git_root" ] && return 1

    # Project name = directory name
    local project_name=$(basename "$git_root")

    # Check if we're in a worktree (git-common-dir points to main repo's .git)
    local git_dir=$(git -C "$current_dir" rev-parse --git-dir 2>/dev/null)
    local git_common=$(git -C "$current_dir" rev-parse --git-common-dir 2>/dev/null)

    # In a worktree: git_dir is .git file, git_common is path to main's .git
    # In main repo: git_dir == git_common == .git
    if [ -n "$git_common" ] && [ "$git_dir" != "$git_common" ]; then
        # We're in a worktree, find the main repo
        # git_common = /path/to/main/.git, so main = dirname
        local main_repo=$(dirname "$git_common")
        if [ -d "$main_repo" ]; then
            git_root="$main_repo"
            project_name=$(basename "$git_root")
        fi
    fi

    # Set globals using conventions
    CURRENT_PROJECT="$project_name"
    MAIN_APP="$git_root"
    WORKTREES_DIR="$(dirname "$git_root")/${project_name}-worktrees"
    BRANCH_PREFIX=""

    return 0
}

# Resolve project alias to real project name
# Scans all project configs for "aliases" array
resolve_project_alias() {
    local name="$1"

    # First check if it's a real project
    if [ -f "$PWT_PROJECTS_DIR/$name/config.json" ]; then
        # Check it's not just an alias pointer (legacy) - check both .path and .main_app
        local has_main=$(jq -r '.path // .main_app // empty' "$PWT_PROJECTS_DIR/$name/config.json")
        if [ -n "$has_main" ]; then
            echo "$name"
            return 0
        fi
    fi

    # Scan all projects for alias match
    for config in "$PWT_PROJECTS_DIR"/*/config.json; do
        [ -f "$config" ] || continue
        local proj_alias=$(jq -r '.alias // empty' "$config")
        if [ "$proj_alias" = "$name" ]; then
            basename "$(dirname "$config")"
            return 0
        fi
    done

    # Not found, return original (might be auto-detected)
    echo "$name"
}

# Load project configuration into global variables
# Falls back to auto-detect if config doesn't exist
# Supports alias: config can have "alias": "pc"
load_project_config() {
    local project="$1"

    # Resolve alias to real project name
    project=$(resolve_project_alias "$project")
    local config_file="$PWT_PROJECTS_DIR/$project/config.json"

    CURRENT_PROJECT="$project"

    if [ -f "$config_file" ]; then
        # Load from config file
        # path is preferred, main_app for backwards compatibility
        local cfg_path=$(jq -r '.path // .main_app // empty' "$config_file")
        local cfg_wt=$(jq -r '.worktrees_dir // empty' "$config_file")
        local cfg_prefix=$(jq -r '.branch_prefix // empty' "$config_file")
        local cfg_port=$(jq -r '.base_port // empty' "$config_file")
        local cfg_remote=$(jq -r '.remote // empty' "$config_file")

        [ -n "$cfg_path" ] && MAIN_APP="$cfg_path"
        [ -n "$cfg_wt" ] && WORKTREES_DIR="$cfg_wt"
        [ -n "$cfg_prefix" ] && BRANCH_PREFIX="$cfg_prefix"
        [ -n "$cfg_port" ] && BASE_PORT="$cfg_port"
        [ -n "$cfg_remote" ] && PROJECT_REMOTE="$cfg_remote"
    fi

    # Detect default branch after MAIN_APP is set
    detect_default_branch "$MAIN_APP"

    return 0
}

# Require project context for commands that need it
# Auto-creates worktrees directory if needed
# Usage: require_project [--clone] [--info-only]
#   --clone     Auto-clone from remote if not cloned
#   --info-only Skip clone check (for list/info commands)
require_project() {
    local auto_clone=false
    local info_only=false
    for arg in "$@"; do
        [ "$arg" = "--clone" ] && auto_clone=true
        [ "$arg" = "--info-only" ] && info_only=true
    done

    if [ -z "$CURRENT_PROJECT" ]; then
        # Check if we're in a git repo (potential new project)
        if git rev-parse --git-dir &>/dev/null; then
            local repo_name=$(basename "$(git rev-parse --show-toplevel 2>/dev/null)")
            echo -e "${YELLOW}Git repository detected: $repo_name${NC}"
            echo ""
            echo "This repo is not configured with pwt yet."
            echo ""
            echo "To set it up:"
            echo "  pwt init                    # configure this repo"
            echo ""
            echo "Or specify a configured project:"
            echo "  pwt <project> <command>     # e.g., pwt acme list"
            echo "  pwt project list            # see configured projects"
        else
            echo -e "${RED}Error: No project detected${NC}"
            echo ""
            echo "You're not inside a git repository."
            echo ""
            echo "Options:"
            echo "  pwt <project> <command>     # specify project explicitly"
            echo "  pwt project list            # see configured projects"
            echo "  cd /path/to/repo && pwt init"
        fi
        exit 1
    fi

    if [ -z "$MAIN_APP" ] || [ -z "$WORKTREES_DIR" ]; then
        echo -e "${RED}Error: Could not determine project paths${NC}"
        echo ""
        echo "Run from inside a git repository, or initialize a project:"
        echo "  cd /path/to/repo && pwt init"
        echo "  pwt init git@github.com:user/repo.git"
        echo ""
        echo "Or configure manually:"
        echo "  pwt project set myproject path /path/to/main/app"
        echo "  pwt project set myproject worktrees_dir /path/to/worktrees"
        exit 1
    fi

    # For info-only mode, skip clone/exist checks
    [ "$info_only" = true ] && return 0

    # Check if main app exists
    if [ ! -d "$MAIN_APP" ]; then
        if [ -n "$PROJECT_REMOTE" ]; then
            if [ "$auto_clone" = true ]; then
                echo -e "${BLUE}Cloning from remote: $PROJECT_REMOTE${NC}"
                local parent_dir=$(dirname "$MAIN_APP")
                mkdir -p "$parent_dir"
                if git clone "$PROJECT_REMOTE" "$MAIN_APP"; then
                    echo -e "${GREEN}✓ Cloned successfully${NC}"
                else
                    echo -e "${RED}Error: Failed to clone from $PROJECT_REMOTE${NC}"
                    exit 1
                fi
            else
                echo -e "${RED}Error: Project not cloned${NC}"
                echo ""
                echo "Run: pwt clone $CURRENT_PROJECT"
                echo "Or:  pwt $CURRENT_PROJECT create <branch> <base> <desc>"
                exit 1
            fi
        else
            echo -e "${RED}Error: Main app directory not found: $MAIN_APP${NC}"
            exit 1
        fi
    fi

    # Auto-create worktrees directory if it doesn't exist
    if [ ! -d "$WORKTREES_DIR" ]; then
        echo -e "${BLUE}Creating worktrees directory: $WORKTREES_DIR${NC}"
        mkdir -p "$WORKTREES_DIR"
    fi
}

# Initialize a project (clone from URL or configure current directory)
# Usage: cmd_init [url]
#   With url: clone and configure as pwt project
#   Without url: configure current git repo as pwt project
cmd_init() {
    local url="${1:-}"

    # If URL provided, clone and configure
    if [ -n "$url" ]; then
        # Extract project name from URL
        local project_name=$(basename "$url" .git)
        local target_dir="${PWD}/${project_name}"

        if [ -d "$target_dir" ]; then
            echo -e "${YELLOW}Already exists: $target_dir${NC}"
            echo "To configure: cd $target_dir && pwt init"
            return 0
        fi

        echo -e "${BLUE}Cloning: $url${NC}"
        if ! git clone "$url" "$target_dir"; then
            echo -e "${RED}Error: Failed to clone${NC}"
            exit 1
        fi

        # Configure the project
        local project_dir="$PWT_PROJECTS_DIR/$project_name"
        mkdir -p "$project_dir"

        cat > "$project_dir/config.json" << EOF
{
  "path": "$target_dir",
  "remote": "$url",
  "worktrees_dir": "${target_dir}-worktrees"
}
EOF

        echo -e "${GREEN}✓ Cloned and configured: $project_name${NC}"
        echo ""
        echo "Usage:"
        echo -e "  ${GREEN}pwt $project_name list${NC}"
        echo -e "  ${GREEN}pwt $project_name create TICKET base \"description\"${NC}"
        return 0
    fi

    # No URL - configure current directory
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        echo -e "${RED}Error: Not a git repository${NC}"
        echo ""
        echo "Usage:"
        echo "  pwt init <url>    # Clone and configure new project"
        echo "  cd <repo> && pwt init  # Configure existing repo"
        exit 1
    fi

    local repo_root=$(git rev-parse --show-toplevel)
    local project_name=$(basename "$repo_root")
    local remote_url=$(git remote get-url origin 2>/dev/null || echo "")

    # Check if already configured
    if [ -f "$PWT_PROJECTS_DIR/$project_name/config.json" ]; then
        echo -e "${YELLOW}Already configured: $project_name${NC}"
        echo ""
        cat "$PWT_PROJECTS_DIR/$project_name/config.json"
        return 0
    fi

    # Create config
    local project_dir="$PWT_PROJECTS_DIR/$project_name"
    mkdir -p "$project_dir"

    local config="{
  \"path\": \"$repo_root\",
  \"worktrees_dir\": \"${repo_root}-worktrees\""

    if [ -n "$remote_url" ]; then
        config="$config,
  \"remote\": \"$remote_url\""
    fi

    config="$config
}"

    echo "$config" > "$project_dir/config.json"

    echo -e "${GREEN}✓ Configured: $project_name${NC}"
    echo ""
    cat "$project_dir/config.json"
    echo ""
    echo "Usage:"
    echo -e "  ${GREEN}pwt $project_name list${NC}"
    echo -e "  ${GREEN}pwt $project_name create TICKET base \"description\"${NC}"
}

# Initialize a project with explicit name
# Usage: cmd_init_named <project_name> [url]
#   With url: clone to <project_name> directory and configure
#   Without url: configure current git repo as <project_name>
cmd_init_named() {
    local project_name="$1"
    local url="${2:-}"

    if [ -n "$url" ]; then
        # Clone mode: pwt myproj init <url>
        local target_dir="${PWD}/${project_name}"

        if [ -d "$target_dir" ]; then
            echo -e "${YELLOW}Already exists: $target_dir${NC}"
            echo "To configure: cd $target_dir && pwt init"
            return 0
        fi

        echo -e "${BLUE}Cloning: $url${NC}"
        if ! git clone "$url" "$target_dir"; then
            echo -e "${RED}Error: Failed to clone${NC}"
            exit 1
        fi

        # Configure the project
        local project_dir="$PWT_PROJECTS_DIR/$project_name"
        mkdir -p "$project_dir"

        cat > "$project_dir/config.json" << EOF
{
  "path": "$target_dir",
  "remote": "$url",
  "worktrees_dir": "${target_dir}-worktrees"
}
EOF

        echo -e "${GREEN}✓ Cloned and configured: $project_name${NC}"
        echo ""
        echo "Usage:"
        echo -e "  ${GREEN}pwt $project_name list${NC}"
        echo -e "  ${GREEN}pwt $project_name create TICKET base \"description\"${NC}"
        return 0
    fi

    # No URL - configure current directory with given name
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        echo -e "${RED}Error: Not a git repository${NC}"
        echo ""
        echo "Usage:"
        echo "  pwt <name> init <url>    # Clone and configure with name"
        echo "  cd <repo> && pwt <name> init  # Configure existing repo with name"
        exit 1
    fi

    local repo_root=$(git rev-parse --show-toplevel)
    local remote_url=$(git remote get-url origin 2>/dev/null || echo "")

    # Check if already configured
    if [ -f "$PWT_PROJECTS_DIR/$project_name/config.json" ]; then
        echo -e "${YELLOW}Already configured: $project_name${NC}"
        echo ""
        cat "$PWT_PROJECTS_DIR/$project_name/config.json"
        return 0
    fi

    # Create config
    local project_dir="$PWT_PROJECTS_DIR/$project_name"
    mkdir -p "$project_dir"

    local config="{
  \"path\": \"$repo_root\",
  \"worktrees_dir\": \"${repo_root}-worktrees\""

    if [ -n "$remote_url" ]; then
        config="$config,
  \"remote\": \"$remote_url\""
    fi

    config="$config
}"

    echo "$config" > "$project_dir/config.json"

    echo -e "${GREEN}✓ Configured as: $project_name${NC}"
    echo ""
    cat "$project_dir/config.json"
    echo ""
    echo "Usage:"
    echo -e "  ${GREEN}pwt $project_name list${NC}"
    echo -e "  ${GREEN}pwt $project_name create TICKET base \"description\"${NC}"
}

# Atomic write to metadata file with file locking
# Usage: atomic_metadata_write <jq_filter> [jq_args...]
atomic_metadata_write() {
    local jq_filter="$1"
    shift

    init_metadata

    local lock_dir="$METADATA_FILE.lock"
    local lock_pid_file="$lock_dir/pid"
    # Create tmp in same directory as metadata for atomic mv (same filesystem)
    local tmp_file
    tmp_file="$(mktemp "${METADATA_FILE}.tmp.XXXXXX")"
    local max_wait=50  # 5 seconds (50 * 0.1s)
    local stale_threshold=60  # seconds - lock older than this is stale
    local already_locked=false

    # Create tmp_file early and set trap to clean it up on any exit
    trap "rm -f '$tmp_file'" RETURN

    # Check if we already own the lock (re-entrant call)
    if [ -d "$lock_dir" ] && [ -f "$lock_pid_file" ]; then
        local current_owner=$(cat "$lock_pid_file" 2>/dev/null)
        if [ "$current_owner" = "$$" ]; then
            already_locked=true
        fi
    fi

    # Acquire lock using mkdir (atomic on all systems), unless we already own it
    local waited=0
    while [ "$already_locked" = false ] && ! mkdir "$lock_dir" 2>/dev/null; do
        # Check for stale lock
        if [ -f "$lock_pid_file" ]; then
            local lock_pid=$(cat "$lock_pid_file" 2>/dev/null)
            local lock_age=0
            # Get lock age in seconds (portable: stat -f %m on macOS, stat -c %Y on Linux)
            if stat --version >/dev/null 2>&1; then
                lock_age=$(( $(date +%s) - $(stat -c %Y "$lock_pid_file" 2>/dev/null || echo 0) ))
            else
                lock_age=$(( $(date +%s) - $(stat -f %m "$lock_pid_file" 2>/dev/null || echo 0) ))
            fi

            # Remove stale lock if process is dead or lock is too old
            if [ -n "$lock_pid" ]; then
                if ! kill -0 "$lock_pid" 2>/dev/null || [ "$lock_age" -gt "$stale_threshold" ]; then
                    rm -rf "$lock_dir" 2>/dev/null
                    continue  # Retry acquiring lock
                fi
            fi
        fi

        waited=$((waited + 1))
        if [ $waited -ge $max_wait ]; then
            echo -e "${RED}Error: Could not acquire lock on metadata file${NC}" >&2
            return 1
        fi
        sleep 0.1
    done

    # Write our PID to the lock (only if we acquired it)
    if [ "$already_locked" = false ]; then
        echo "$$" > "$lock_pid_file"
        # Update trap to also clean lock after acquiring it
        trap "rm -rf '$lock_dir' '$tmp_file'" RETURN
    fi
    # If already_locked, we keep the original trap that only cleans tmp_file

    # Perform atomic write
    if jq "$jq_filter" "$@" "$METADATA_FILE" > "$tmp_file"; then
        mv "$tmp_file" "$METADATA_FILE"
        return 0
    else
        return 1
    fi
    # trap handles cleanup on return
}

# Acquire metadata lock (for operations needing read-modify-write atomicity)
# Usage: acquire_metadata_lock
# Returns: 0 on success, 1 on failure
# IMPORTANT: Must call release_metadata_lock when done
acquire_metadata_lock() {
    init_metadata

    local lock_dir="$METADATA_FILE.lock"
    local lock_pid_file="$lock_dir/pid"
    local max_wait=50  # 5 seconds
    local stale_threshold=60

    local waited=0
    while ! mkdir "$lock_dir" 2>/dev/null; do
        # Check for stale lock
        if [ -f "$lock_pid_file" ]; then
            local lock_pid=$(cat "$lock_pid_file" 2>/dev/null)
            local lock_age=0
            if stat --version >/dev/null 2>&1; then
                lock_age=$(( $(date +%s) - $(stat -c %Y "$lock_pid_file" 2>/dev/null || echo 0) ))
            else
                lock_age=$(( $(date +%s) - $(stat -f %m "$lock_pid_file" 2>/dev/null || echo 0) ))
            fi
            if [ -n "$lock_pid" ]; then
                if ! kill -0 "$lock_pid" 2>/dev/null || [ "$lock_age" -gt "$stale_threshold" ]; then
                    rm -rf "$lock_dir" 2>/dev/null
                    continue
                fi
            fi
        fi

        waited=$((waited + 1))
        if [ $waited -ge $max_wait ]; then
            echo -e "${RED}Error: Could not acquire metadata lock${NC}" >&2
            return 1
        fi
        sleep 0.1
    done

    echo "$$" > "$lock_pid_file"
    return 0
}

# Release metadata lock
# Usage: release_metadata_lock
release_metadata_lock() {
    local lock_dir="$METADATA_FILE.lock"
    rm -rf "$lock_dir" 2>/dev/null
}

# Save worktree metadata (namespaced by project)
# Usage: save_metadata <name> <path> <branch> <base> <base_commit> <port> <description>
save_metadata() {
    local name="$1"
    local path="$2"
    local branch="$3"
    local base="$4"
    local base_commit="$5"
    local port="$6"
    local description="$7"
    local mode="${8:-worktree}"  # worktree or clone
    local created_at=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    local project="${CURRENT_PROJECT:-unknown}"

    atomic_metadata_write \
       '.[$project][$name] = {
           path: $path,
           branch: $branch,
           base: $base,
           base_commit: $base_commit,
           port: $port,
           description: $description,
           mode: $mode,
           created_at: $created_at
       }' \
       --arg project "$project" \
       --arg name "$name" \
       --arg path "$path" \
       --arg branch "$branch" \
       --arg base "$base" \
       --arg base_commit "$base_commit" \
       --argjson port "$port" \
       --arg description "$description" \
       --arg mode "$mode" \
       --arg created_at "$created_at"
}

# Get worktree metadata field (namespaced by project)
# Usage: get_metadata <name> <field>
get_metadata() {
    local name="$1"
    local field="$2"
    local project="${CURRENT_PROJECT:-unknown}"

    init_metadata

    jq -r --arg project "$project" --arg name "$name" --arg field "$field" \
        '.[$project][$name][$field] // empty' "$METADATA_FILE" 2>/dev/null
}

# Get extra metadata fields as key=value string (for Meta column in list)
# Excludes fields already shown as columns: path, branch, base, base_commit, created_at, mode
# Shows: port, description, and any custom fields
# Usage: get_extra_metadata <name>
get_extra_metadata() {
    local name="$1"
    local project="${CURRENT_PROJECT:-unknown}"

    init_metadata

    jq -r --arg project "$project" --arg name "$name" '
        .[$project][$name] // {} |
        to_entries |
        map(select(.key | test("^(path|branch|base|base_commit|created_at|mode)$") | not)) |
        map("\(.key)=\(.value)") |
        join(" ")
    ' "$METADATA_FILE" 2>/dev/null
}

# Remove worktree metadata (namespaced by project)
# Usage: remove_metadata <name>
remove_metadata() {
    local name="$1"
    local project="${CURRENT_PROJECT:-unknown}"
    atomic_metadata_write 'del(.[$project][$name])' \
        --arg project "$project" --arg name "$name"
}

# Update worktree metadata field (namespaced by project)
# Usage: update_metadata <name> <field> <value>
# Note: For numeric fields (port), use update_metadata_json
update_metadata() {
    local name="$1"
    local field="$2"
    local value="$3"
    local project="${CURRENT_PROJECT:-unknown}"
    atomic_metadata_write \
       'if .[$project][$name] then .[$project][$name][$field] = $value else . end' \
       --arg project "$project" --arg name "$name" --arg field "$field" --arg value "$value"
}

# Update worktree metadata field with JSON value (for numbers, booleans, etc.)
# Usage: update_metadata_json <name> <field> <json_value>
update_metadata_json() {
    local name="$1"
    local field="$2"
    local json_value="$3"
    local project="${CURRENT_PROJECT:-unknown}"
    atomic_metadata_write \
       'if .[$project][$name] then .[$project][$name][$field] = $value else . end' \
       --arg project "$project" --arg name "$name" --arg field "$field" --argjson value "$json_value"
}

# List all metadata for current project
list_metadata() {
    local project="${CURRENT_PROJECT:-unknown}"
    init_metadata
    jq --arg project "$project" '.[$project] // {}' "$METADATA_FILE"
}

# Get project config directory
# Usage: get_project_dir <project_name>
get_project_dir() {
    local project="$1"
    echo "$PROJECTS_DIR/$project"
}

# Get project config value
# Usage: get_project_config <project_name> <key>
get_project_config() {
    local project="$1"
    local key="$2"
    local config_file="$PROJECTS_DIR/$project/config.json"

    if [ -f "$config_file" ]; then
        jq -r --arg key "$key" '.[$key] // empty' "$config_file" 2>/dev/null
    fi
}

# Pwtfile helpers (available in Pwtfile)
# These are sourced when running a Pwtfile
pwtfile_env() {
    local key="$1"
    local value="$2"
    if [ -f .env ]; then
        if grep -q "^${key}=" .env; then
            sed_inplace "s|^${key}=.*|${key}=${value}|" .env
        else
            echo "${key}=${value}" >> .env
        fi
    fi
}

pwtfile_replace() {
    local file="$1"
    local from="$2"
    local to="$3"
    [ -f "$file" ] && sed_inplace "s|${from}|${to}|g" "$file"
}

# Safe literal string replacement (no regex interpretation)
# Cross-platform: uses perl's \Q...\E for literal matching
# Usage: pwtfile_replace_literal <file> <from> <to>
# Example: pwtfile_replace_literal "config.yml" "localhost:3000" "localhost:5007"
pwtfile_replace_literal() {
    local file="$1"
    local from="$2"
    local to="$3"
    [ -f "$file" ] || return 0

    if command -v perl >/dev/null 2>&1; then
        # \Q...\E quotes metacharacters, making it literal
        perl -i -pe 'BEGIN { $f = shift; $t = shift } s/\Q$f\E/$t/g' "$from" "$to" "$file"
    else
        echo "  ! perl not found, skipping literal replace in $file"
        return 1
    fi
}

# Regex replacement using perl (cross-platform, unlike sed -E)
# Usage: pwtfile_replace_re <file> <pattern> <replacement>
# Example: pwtfile_replace_re "config.yml" "port:\s*\d+" "port: 5007"
pwtfile_replace_re() {
    local file="$1"
    local pattern="$2"
    local replacement="$3"
    [ -f "$file" ] || return 0

    if command -v perl >/dev/null 2>&1; then
        perl -i -pe "s/$pattern/$replacement/g" "$file"
    else
        echo "  ! perl not found, skipping regex replace in $file"
        return 1
    fi
}

pwtfile_database() {
    local action="$1"
    local name="$2"
    case "$action" in
        create) createdb "$name" 2>/dev/null || true ;;
        drop) dropdb "$name" 2>/dev/null || true ;;
    esac
}

pwtfile_rake() {
    bundle exec rake "$@" 2>/dev/null || true
}

pwtfile_run() {
    "$@" 2>/dev/null || true
}

# Symlink from main app to current worktree
# Usage: pwtfile_symlink <path>
# Example: pwtfile_symlink "node_modules"
pwtfile_symlink() {
    local path="$1"
    local source="$MAIN_APP/$path"
    local target="$PWD/$path"

    if [ ! -e "$source" ]; then
        echo "  ! Source not found: $source"
        return 1
    fi

    if [ -e "$target" ] && [ ! -L "$target" ]; then
        echo "  ! Target exists (not a symlink): $target"
        return 1
    fi

    rm -f "$target" 2>/dev/null
    ln -sf "$source" "$target"
    echo "  ✓ Symlinked: $path"
}

# Copy from main app to current worktree
# Usage: pwtfile_copy <path>
# Example: pwtfile_copy ".env"
pwtfile_copy() {
    local path="$1"
    local source="$MAIN_APP/$path"
    local target="$PWD/$path"

    if [ ! -e "$source" ]; then
        echo "  ! Source not found: $source"
        return 1
    fi

    if [ -d "$source" ]; then
        cp -r "$source" "$target"
    else
        cp "$source" "$target"
    fi
    echo "  ✓ Copied: $path"
}

# ============================================================
# List display helpers
# ============================================================

# Format relative time from Unix timestamp or git date
# Usage: format_relative_time <timestamp_or_git_date>
# Output: "30m", "4h", "2d", "3w", "5M"
format_relative_time() {
    local input="$1"
    local now=$(date +%s)
    local timestamp

    # Handle git date format or Unix timestamp
    if [[ "$input" =~ ^[0-9]+$ ]]; then
        timestamp="$input"
    else
        timestamp=$(date -j -f "%Y-%m-%d %H:%M:%S %z" "$input" +%s 2>/dev/null || \
                   date -d "$input" +%s 2>/dev/null || \
                   echo "$now")
    fi

    local diff=$((now - timestamp))

    if [ $diff -lt 60 ]; then
        echo "now"
    elif [ $diff -lt 3600 ]; then
        echo "$((diff / 60))m"
    elif [ $diff -lt 86400 ]; then
        echo "$((diff / 3600))h"
    elif [ $diff -lt 604800 ]; then
        echo "$((diff / 86400))d"
    elif [ $diff -lt 2592000 ]; then
        echo "$((diff / 604800))w"
    else
        echo "$((diff / 2592000))M"
    fi
}

# Get git status symbols
# Usage: get_status_symbols <dir>
# Output: "+!?" format (+ staged, ! modified, ? untracked)
get_status_symbols() {
    local dir="$1"
    local symbols=""

    local staged=$(git -C "$dir" diff --cached --numstat 2>/dev/null | wc -l | tr -d ' ')
    local modified=$(git -C "$dir" diff --numstat 2>/dev/null | wc -l | tr -d ' ')
    local untracked=$(git -C "$dir" ls-files --others --exclude-standard 2>/dev/null | wc -l | tr -d ' ')

    [ "$staged" -gt 0 ] && symbols="${symbols}+"
    [ "$modified" -gt 0 ] && symbols="${symbols}!"
    [ "$untracked" -gt 0 ] && symbols="${symbols}?"

    echo "$symbols"
}

# Get divergence from a ref (ahead/behind)
# Usage: get_divergence <dir> <ref>
# Output: "↑3" or "↓2" or "↑3↓2" or ""
get_divergence() {
    local dir="$1"
    local ref="$2"
    local result=""

    local ahead=$(git -C "$dir" rev-list --count "HEAD...$ref" --left-only 2>/dev/null || echo "0")
    local behind=$(git -C "$dir" rev-list --count "HEAD...$ref" --right-only 2>/dev/null || echo "0")

    # Remove whitespace
    ahead=$(echo "$ahead" | tr -d ' ')
    behind=$(echo "$behind" | tr -d ' ')

    [ "$ahead" -gt 0 ] && result="↑${ahead}"
    [ "$behind" -gt 0 ] && result="${result}↓${behind}"

    echo "$result"
}

# Get remote divergence (vs upstream)
# Usage: get_remote_divergence <dir>
# Output: "⇡3" or "⇣2" or "⇡3⇣2" or ""
get_remote_divergence() {
    local dir="$1"
    local branch=$(git -C "$dir" branch --show-current 2>/dev/null)
    [ -z "$branch" ] && return

    local upstream=$(git -C "$dir" rev-parse --abbrev-ref "${branch}@{upstream}" 2>/dev/null)
    [ -z "$upstream" ] && return

    local result=""
    local ahead=$(git -C "$dir" rev-list --count "${upstream}..HEAD" 2>/dev/null || echo "0")
    local behind=$(git -C "$dir" rev-list --count "HEAD..${upstream}" 2>/dev/null || echo "0")

    # Remove whitespace
    ahead=$(echo "$ahead" | tr -d ' ')
    behind=$(echo "$behind" | tr -d ' ')

    [ "$ahead" -gt 0 ] && result="⇡${ahead}"
    [ "$behind" -gt 0 ] && result="${result}⇣${behind}"

    echo "$result"
}

# Check if path is the previous worktree
# Usage: is_previous_worktree <path>
# Returns: 0 if previous, 1 otherwise
is_previous_worktree() {
    local path="$1"
    [ -n "${PWT_PREVIOUS_PATH:-}" ] && [ "$PWT_PREVIOUS_PATH" = "$path" ]
}

# Calculate visual width of string (accounting for multi-byte Unicode)
# Usage: visual_width <string>
visual_width() {
    local str="$1"
    # Use wc -m to count characters (not bytes)
    # Preserve current locale or fallback to UTF-8 for proper Unicode handling
    local lc="${LC_ALL:-${LC_CTYPE:-${LANG:-C.UTF-8}}}"
    printf "%s" "$str" | LC_ALL="$lc" wc -m | tr -d ' '
}

# Pad string to fixed visual width
# Usage: pad_visual <string> <width>
pad_visual() {
    local str="$1"
    local width="$2"
    local visual=$(visual_width "$str")
    printf "%s" "$str"
    local i
    for ((i=visual; i<width; i++)); do
        printf " "
    done
}

# Get short commit hash
# Usage: get_short_hash <dir>
get_short_hash() {
    local dir="$1"
    git -C "$dir" rev-parse --short HEAD 2>/dev/null || echo "?"
}

# Get base branch from metadata or detect from reflog
# Usage: get_base_branch <worktree_name> <dir>
get_base_branch() {
    local name="$1"
    local dir="$2"

    # First try metadata
    local base=$(get_metadata "$name" "base")
    if [ -n "$base" ]; then
        echo "$base"
        return
    fi

    # Fallback to default branch
    echo "${DEFAULT_BRANCH:-master}"
}

# Hash-based port generation (deterministic)
# Usage: pwtfile_hash_port [name] [base]
# Output: port number
pwtfile_hash_port() {
    local name="${1:-${PWT_WORKTREE:-}}"
    local base="${2:-${PORT_BASE:-5000}}"

    # Hash the name and take first 4 hex chars for offset 0-65535
    # macOS uses 'md5 -q', Linux uses 'md5sum'
    local hash
    if command -v md5sum >/dev/null 2>&1; then
        hash=$(printf "%s" "$name" | md5sum | awk '{print $1}')
    else
        hash=$(printf "%s" "$name" | md5 -q)
    fi
    local offset=$((16#${hash:0:4} % 1000))

    echo $((base + offset))
}

# ============================================================
# End list display helpers
# ============================================================

# Read PORT_BASE from Pwtfile (if defined)
# Sets BASE_PORT global variable
read_port_base() {
    local pwtfile=""

    # Check project config for custom pwtfile path first
    local config_pwtfile=$(get_project_config "$CURRENT_PROJECT" "pwtfile")
    if [ -n "$config_pwtfile" ]; then
        config_pwtfile="${config_pwtfile/#\~/$HOME}"
        [[ "$config_pwtfile" != /* ]] && config_pwtfile="$MAIN_APP/$config_pwtfile"
        [ -f "$config_pwtfile" ] && pwtfile="$config_pwtfile"
    fi

    # Fallback to default location
    if [ -z "$pwtfile" ] && [ -n "$MAIN_APP" ] && [ -f "$MAIN_APP/Pwtfile" ]; then
        pwtfile="$MAIN_APP/Pwtfile"
    fi

    [ -z "$pwtfile" ] && return 0

    # Extract PORT_BASE from Pwtfile (bash only)
    local port_base=$(grep -E "^PORT_BASE=" "$pwtfile" 2>/dev/null | head -1 | cut -d= -f2)

    if [ -n "$port_base" ] && [[ "$port_base" =~ ^[0-9]+$ ]]; then
        # Pwtfile PORT_BASE means "first worktree port"
        # Internal BASE_PORT means "main app port" (worktrees start at BASE_PORT+1)
        # So if PORT_BASE=5001 (first worktree), BASE_PORT=5000 (main app)
        BASE_PORT=$((port_base - 1))
    fi
}

# Run Pwtfile if exists
# Looks for: Pwtfile, Pwtfile.rb, Pwtfile.js
# Usage: run_pwtfile <phase> (setup|teardown|server)
# Execute a single Pwtfile
# Arguments: pwtfile_path phase label
run_single_pwtfile() {
    local pwtfile="$1"
    local phase="$2"
    local label="$3"

    [ ! -f "$pwtfile" ] && return 0

    case "$pwtfile" in
        *.rb)
            echo -e "${BLUE}Running $label ($phase)...${NC}"
            ruby "$pwtfile" "$phase"
            echo -e "  ${GREEN}✓${NC} $label ($phase) completed"
            ;;
        *.js)
            echo -e "${BLUE}Running $label ($phase)...${NC}"
            if command -v bun >/dev/null 2>&1; then
                bun "$pwtfile" "$phase"
            else
                node "$pwtfile" "$phase"
            fi
            echo -e "  ${GREEN}✓${NC} $label ($phase) completed"
            ;;
        *)
            # Bash Pwtfile - source and call function
            # Check if function exists before printing/running
            if ! grep -qE "^${phase}\s*\(\)|^function\s+${phase}\b" "$pwtfile" 2>/dev/null; then
                return 0  # Function doesn't exist, skip silently
            fi

            echo -e "${BLUE}Running $label ($phase)...${NC}"
            (
                cd "$PWT_WORKTREE_PATH"
                # Make helpers available
                env() { pwtfile_env "$@"; }
                replace() { pwtfile_replace "$@"; }
                replace_literal() { pwtfile_replace_literal "$@"; }
                replace_re() { pwtfile_replace_re "$@"; }
                database() { pwtfile_database "$@"; }
                rake() { pwtfile_rake "$@"; }
                run() { pwtfile_run "$@"; }

                source "$pwtfile"

                # Call the phase function if it exists
                if type "$phase" &>/dev/null; then
                    "$phase"
                fi
            )
            echo -e "  ${GREEN}✓${NC} $label ($phase) completed"
            ;;
    esac
}

# Check if a command exists in a specific file
# Usage: has_command_in_file <file> <command>
has_command_in_file() {
    local file="$1"
    local cmd="$2"
    [ -f "$file" ] || return 1
    # Match: "cmd() {" or "function cmd {"
    grep -qE "^${cmd}\s*\(\)|^function\s+${cmd}\b" "$file" 2>/dev/null
}

# Get project Pwtfile path
# Usage: get_project_pwtfile
get_project_pwtfile() {
    detect_project

    local project_pwtfile=""
    local config_pwtfile=$(get_project_config "$CURRENT_PROJECT" "pwtfile")

    if [ -n "$config_pwtfile" ]; then
        config_pwtfile="${config_pwtfile/#\~/$HOME}"
        [[ "$config_pwtfile" != /* ]] && config_pwtfile="$MAIN_APP/$config_pwtfile" || true
        [ -f "$config_pwtfile" ] && project_pwtfile="$config_pwtfile" || true
    fi

    if [ -z "$project_pwtfile" ]; then
        [ -f "$MAIN_APP/Pwtfile" ] && project_pwtfile="$MAIN_APP/Pwtfile" || true
    fi

    echo "$project_pwtfile"
}

# Check if a command exists in project OR global Pwtfile
# Usage: has_pwtfile_command <command>
has_pwtfile_command() {
    local cmd="$1"
    local project_pwtfile=$(get_project_pwtfile)
    local global_pwtfile="$PWT_DIR/Pwtfile"

    # Check project first, then global
    has_command_in_file "$project_pwtfile" "$cmd" && return 0
    has_command_in_file "$global_pwtfile" "$cmd" && return 0
    return 1
}

# Run a Pwtfile command in current worktree context
# Usage: run_pwtfile_command <command> [args...]
run_pwtfile_command() {
    local cmd="$1"
    shift

    # Set up worktree context from current directory
    # Resolve symlinks for consistent comparison (e.g., /var -> /private/var on macOS)
    local current_dir=$(pwd -P)
    local resolved_worktrees_dir=""
    local resolved_main_app=""

    if [ -n "$WORKTREES_DIR" ] && [ -d "$WORKTREES_DIR" ]; then
        resolved_worktrees_dir=$(cd "$WORKTREES_DIR" 2>/dev/null && pwd -P)
    fi
    if [ -n "$MAIN_APP" ] && [ -d "$MAIN_APP" ]; then
        resolved_main_app=$(cd "$MAIN_APP" 2>/dev/null && pwd -P)
    fi

    # Check if we're in a worktree or main app
    if [ -n "$resolved_worktrees_dir" ] && [[ "$current_dir" == "$resolved_worktrees_dir"/* ]]; then
        PWT_WORKTREE=$(basename "$current_dir")
        PWT_WORKTREE_PATH="$current_dir"
    elif [ -n "$resolved_main_app" ] && [[ "$current_dir" == "$resolved_main_app"* ]]; then
        PWT_WORKTREE="@"
        PWT_WORKTREE_PATH="$resolved_main_app"
    else
        # Default to main app
        PWT_WORKTREE="@"
        PWT_WORKTREE_PATH="${resolved_main_app:-$MAIN_APP}"
    fi

    # Get port and other metadata
    if [ "$PWT_WORKTREE" != "@" ]; then
        PWT_PORT=$(get_metadata "$PWT_WORKTREE" "port")
        PWT_BRANCH=$(get_metadata "$PWT_WORKTREE" "branch")
    else
        PWT_PORT=""
        PWT_BRANCH=$(git -C "$MAIN_APP" branch --show-current 2>/dev/null || echo "master")
    fi

    # Pass arguments to the command via environment
    export PWT_ARGS="$*"

    run_pwtfile "$cmd"
}

# Run Pwtfile commands with scope-aware behavior:
# - setup/teardown: run BOTH project AND global (additive)
# - server: run ONLY project (local only)
# - custom commands: run project if exists, else global (fallback)
run_pwtfile() {
    local phase="$1"

    # Export canonical PWT_* variables (always available)
    export PWT_PORT="${PWT_PORT:-}"
    export PWT_WORKTREE="${PWT_WORKTREE:-}"
    export PWT_WORKTREE_PATH="${PWT_WORKTREE_PATH:-}"
    export PWT_BRANCH="${PWT_BRANCH:-}"
    export PWT_TICKET="${PWT_TICKET:-}"
    export PWT_PROJECT="${PWT_PROJECT:-$CURRENT_PROJECT}"
    export MAIN_APP="${MAIN_APP:-}"

    # Back-compat aliases (short names)
    export PORT="$PWT_PORT"
    export WORKTREE="$PWT_WORKTREE"
    export WORKTREE_PATH="$PWT_WORKTREE_PATH"
    export BRANCH="$PWT_BRANCH"
    export TICKET="$PWT_TICKET"
    export PROJECT="$PWT_PROJECT"

    # Find project Pwtfile
    local project_pwtfile=""
    local config_pwtfile=$(get_project_config "$CURRENT_PROJECT" "pwtfile")

    if [ -n "$config_pwtfile" ]; then
        config_pwtfile="${config_pwtfile/#\~/$HOME}"
        [[ "$config_pwtfile" != /* ]] && config_pwtfile="$MAIN_APP/$config_pwtfile" || true
        [ -f "$config_pwtfile" ] && project_pwtfile="$config_pwtfile" || true
    fi

    if [ -z "$project_pwtfile" ]; then
        if [ -f "$MAIN_APP/Pwtfile" ]; then
            project_pwtfile="$MAIN_APP/Pwtfile"
        elif [ -f "$MAIN_APP/Pwtfile.rb" ]; then
            project_pwtfile="$MAIN_APP/Pwtfile.rb"
        elif [ -f "$MAIN_APP/Pwtfile.js" ]; then
            project_pwtfile="$MAIN_APP/Pwtfile.js"
        fi
    fi

    local global_pwtfile="$PWT_DIR/Pwtfile"

    case "$phase" in
        setup|teardown)
            # Additive: run BOTH project and global
            [ -n "$project_pwtfile" ] && run_single_pwtfile "$project_pwtfile" "$phase" "Pwtfile" || true
            [ -f "$global_pwtfile" ] && run_single_pwtfile "$global_pwtfile" "$phase" "Global Pwtfile" || true
            ;;
        server)
            # Local only: server is project-specific
            [ -n "$project_pwtfile" ] && run_single_pwtfile "$project_pwtfile" "$phase" "Pwtfile" || true
            ;;
        *)
            # Custom commands: project > global (fallback)
            if [ -n "$project_pwtfile" ] && has_command_in_file "$project_pwtfile" "$phase"; then
                run_single_pwtfile "$project_pwtfile" "$phase" "Pwtfile"
            elif [ -f "$global_pwtfile" ] && has_command_in_file "$global_pwtfile" "$phase"; then
                run_single_pwtfile "$global_pwtfile" "$phase" "Global Pwtfile"
            fi
            ;;
    esac
}

# Run project hook if it exists
# Usage: run_hook <hook_name>
# Environment variables passed to hooks:
#   PWT_PROJECT      - Project name
#   PWT_WORKTREE     - Worktree name (directory name)
#   PWT_WORKTREE_PATH - Full path to worktree
#   PWT_BRANCH       - Git branch name
#   PWT_PORT         - Allocated port
#   PWT_TICKET       - Ticket/worktree name
#   PWT_BASE         - Base branch
#   PWT_DESC         - Description
run_hook() {
    local hook_name="$1"
    local hook_file="$PWT_PROJECTS_DIR/$CURRENT_PROJECT/hooks/$hook_name"

    [ -x "$hook_file" ] || return 0

    echo -e "${BLUE}Running $hook_name hook...${NC}"

    # Export all PWT_* variables for the hook
    export PWT_PROJECT="${PWT_PROJECT:-$CURRENT_PROJECT}"
    export PWT_WORKTREE="${PWT_WORKTREE:-}"
    export PWT_WORKTREE_PATH="${PWT_WORKTREE_PATH:-}"
    export PWT_BRANCH="${PWT_BRANCH:-}"
    export PWT_PORT="${PWT_PORT:-}"
    export PWT_TICKET="${PWT_TICKET:-}"
    export PWT_BASE="${PWT_BASE:-}"
    export PWT_DESC="${PWT_DESC:-}"

    if "$hook_file"; then
        echo -e "  ${GREEN}✓${NC} $hook_name hook completed"
        return 0
    else
        echo -e "  ${YELLOW}⚠${NC} $hook_name hook failed (exit $?)"
        return 1
    fi
}

# Legacy wrapper
run_project_hook() {
    local project="$1"
    local hook="$2"
    shift 2
    CURRENT_PROJECT="$project" run_hook "$hook"
}

# Initialize project config directory
# Usage: init_project <project_name>
init_project() {
    local project="$1"
    local project_dir="$PROJECTS_DIR/$project"

    if [ ! -d "$project_dir" ]; then
        mkdir -p "$project_dir/hooks"
        cat > "$project_dir/config.json" << 'EOF'
{
  "name": "PROJECT_NAME",
  "main_app": "",
  "worktrees_dir": "",
  "branch_prefix": "",
  "post_create_commands": [],
  "pre_remove_commands": []
}
EOF
        sed_inplace "s/PROJECT_NAME/$project/" "$project_dir/config.json"
        echo -e "${GREEN}✓ Created project config: $project_dir${NC}"
    fi
}

# Extract worktree name from branch
# Removes path prefix (feature/, user/, etc) and sanitizes for directory use
extract_worktree_name() {
    local branch="$1"
    echo "$branch" | sed -E 's|.*/||; s|[^A-Za-z0-9._-]|-|g'
}

# Alias for backwards compatibility (was pair, now single port)
# Projects needing multiple ports should derive them in Pwtfile (e.g., VITE_PORT=$((PWT_PORT+1)))
is_port_pair_free() {
    is_port_free "$1"
}

# Find next available port
# Strategy: try to reuse ports from removed worktrees before incrementing
# Note: BASE_PORT is reserved for main app, worktrees start at BASE_PORT+1
#       (Pwtfile PORT_BASE defines first worktree port, see read_port_base)
next_available_port() {
    # Collect all ports "allocated" by existing worktrees
    local -a allocated_ports=()
    local project="${CURRENT_PROJECT:-unknown}"

    # BASE_PORT is reserved for main app (worktrees use BASE_PORT+1, +2, etc.)
    allocated_ports+=("$BASE_PORT")

    # Read ports from metadata for current project (primary source)
    if [ -f "$METADATA_FILE" ]; then
        while IFS= read -r port; do
            if [[ "$port" =~ ^[0-9]+$ ]]; then
                allocated_ports+=("$port")
            fi
        done < <(jq -r --arg project "$project" '.[$project] // {} | .[].port // empty' "$METADATA_FILE" 2>/dev/null)
    fi

    # Also scan directory names (fallback for legacy worktrees without metadata)
    if [ -d "$WORKTREES_DIR" ]; then
        for dir in "$WORKTREES_DIR"/*/; do
            if [ -d "$dir" ]; then
                local dirname=$(basename "$dir")
                # Only extract port if it looks like old format (ends with -XXXX)
                if [[ "$dirname" =~ -([0-9]{4})$ ]]; then
                    local port="${BASH_REMATCH[1]}"
                    allocated_ports+=("$port")
                fi
            fi
        done
    fi

    # Find next free port, starting from BASE_PORT+1
    # Try to reuse "holes" from removed worktrees
    local candidate=$((BASE_PORT + 1))
    local max_attempts=100  # Avoid infinite loop

    for ((i=0; i<max_attempts; i++)); do
        local is_allocated=false

        # Check if port is allocated by existing worktree
        for allocated in "${allocated_ports[@]}"; do
            if [ "$candidate" -eq "$allocated" ]; then
                is_allocated=true
                break
            fi
        done

        if [ "$is_allocated" = false ]; then
            # Check if port (and Vite +1) are actually free on the system
            if is_port_pair_free "$candidate"; then
                echo "$candidate"
                return 0
            fi
        fi

        candidate=$((candidate + 1))
    done

    # Fallback: return next after all allocated
    local max_port=$BASE_PORT
    for allocated in "${allocated_ports[@]}"; do
        if [ "$allocated" -gt "$max_port" ]; then
            max_port=$allocated
        fi
    done
    echo $((max_port + 1))
}

# Check if server is running in a worktree (generic - checks port, not pidfile)
check_server_status() {
    local dir="$1"
    local port="${2:-}"

    # If port provided, check if it's in use
    if [ -n "$port" ] && [[ "$port" =~ ^[0-9]+$ ]]; then
        local pids=$(get_pids_on_port "$port")
        if [ -n "$pids" ]; then
            echo -e "${GREEN}[running]${NC} port $port"
            return
        fi
    fi
    echo -e "${YELLOW}[stopped]${NC}"
}


# Command: create
# Usage: pwt create <branch> [base-ref] [description] [options]
# Options:
#   --dry-run, -n     Show what would be created without creating
#   -e, --editor      Open editor after creating
#   -a, --ai          Start AI tool after creating
#   --from <ref>      Create from specific ref (tag, commit, branch)
#   --from-current    Create from current branch
cmd_create() {
    local branch=""
    local base_ref=""
    local description=""
    local dry_run=false
    local open_editor=false
    local start_ai=false
    local from_current=false
    local use_clone=false

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --dry-run|-n)
                dry_run=true
                shift
                ;;
            -e|--editor)
                open_editor=true
                shift
                ;;
            -a|--ai)
                start_ai=true
                shift
                ;;
            --clone)
                use_clone=true
                shift
                ;;
            --from)
                base_ref="$2"
                shift 2
                ;;
            --from-current)
                from_current=true
                shift
                ;;
            --)
                # Everything after -- is the description
                shift
                description="$*"
                break
                ;;
            -h|--help)
                echo "Usage: pwt create <branch> [base] [-- description]"
                echo ""
                echo "Arguments:"
                echo "  branch          Branch name or ticket (e.g., ACME-1234)"
                echo "  base            Base branch (default: master)"
                echo "  -- description  Optional description after --"
                echo ""
                echo "Options:"
                echo "  --from <ref>      Create from specific ref (tag, commit, branch)"
                echo "  --from-current    Create from current branch"
                echo "  --clone           Use git clone instead of worktree"
                echo "  -e, --editor      Open in editor after creation"
                echo "  -a, --ai          Start AI assistant after creation"
                echo "  -n, --dry-run     Show what would be done"
                echo "  -h, --help        Show this help"
                return 0
                ;;
            -*)
                echo -e "${RED}Unknown option: $1${NC}"
                exit 1
                ;;
            *)
                # Positional arguments: branch, base_ref, description
                if [ -z "$branch" ]; then
                    branch="$1"
                elif [ -z "$base_ref" ]; then
                    base_ref="$1"
                else
                    # Accumulate all remaining positional args as description
                    if [ -z "$description" ]; then
                        description="$1"
                    else
                        description="$description $1"
                    fi
                fi
                shift
                ;;
        esac
    done

    # Handle --from-current: use current branch as base
    if [ "$from_current" = true ]; then
        cd "$MAIN_APP"
        base_ref=$(git branch --show-current 2>/dev/null)
        if [ -z "$base_ref" ]; then
            echo -e "${RED}Error: Could not detect current branch${NC}"
            exit 1
        fi
    fi

    if [ -z "$branch" ]; then
        echo -e "${RED}Error: Branch/ticket not specified${NC}"
        echo "Usage: pwt create <branch> [base-ref] [description...] [options]"
        echo "       pwt create <branch> [options] -- description with spaces"
        echo ""
        echo "Options:"
        echo "  --dry-run, -n     Show what would be created without creating"
        echo "  -e, --editor      Open editor after creating"
        echo "  -a, --ai          Start AI tool after creating"
        echo "  --from <ref>      Create from specific ref (tag, commit, branch)"
        echo "  --from-current    Create from current branch"
        echo "  --                Everything after is the description"
        echo ""
        echo "Examples:"
        echo "  pwt create feature/my-feature"
        echo "  pwt create PROJ-123 master"
        echo "  pwt create PROJ-123 master \"add auth flow\""
        echo "  pwt create PROJ-123 master add auth flow        # works too"
        echo "  pwt create PROJ-123 --from v1.2.3 -- hotfix for bug"
        echo "  pwt create hotfix --from-current"
        echo "  pwt create PROJ-123 master -e -a"
        exit 1
    fi

    # Ensure worktrees_dir exists
    mkdir -p "$WORKTREES_DIR"

    # Extract worktree name from branch (removes path prefix, sanitizes)
    local worktree_name=$(extract_worktree_name "$branch")
    local worktree_dir="$WORKTREES_DIR/$worktree_name"

    # Check if worktree already exists
    if [ -d "$worktree_dir" ]; then
        echo -e "${RED}Error: Worktree already exists: $worktree_name${NC}"
        echo ""
        echo "Options:"
        echo "  1. Remove existing: pwt remove $worktree_name"
        echo "  2. Use a different branch name"
        exit 1
    fi

    # Read PORT_BASE from Pwtfile (if defined)
    read_port_base

    # Acquire lock to prevent port allocation race condition
    # Lock is held until metadata is saved
    if ! acquire_metadata_lock; then
        echo -e "${RED}Error: Could not acquire lock for port allocation${NC}"
        exit 1
    fi
    # Ensure lock is released on exit
    trap 'release_metadata_lock' EXIT

    # Allocate port (stored in metadata only)
    local port=$(next_available_port)

    cd "$MAIN_APP"

    # Determine if need to create new branch or use existing
    local new_branch_name=""
    local git_worktree_args=()

    if [ -n "$base_ref" ]; then
        # Base ref provided: create new branch from it
        # Format: [prefix]ticket-name or [prefix]ticket-name-description-slug
        if [ -n "$description" ]; then
            # Convert description to slug: lowercase, spaces -> hyphens, remove special chars
            local slug=$(echo "$description" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | sed 's/[^a-z0-9-]//g' | sed 's/--*/-/g' | sed 's/^-//;s/-$//')
            new_branch_name="${BRANCH_PREFIX}${worktree_name}-${slug}"
        else
            new_branch_name="${BRANCH_PREFIX}${worktree_name}"
        fi

        # Fetch base ref if remote
        if [[ "$base_ref" == origin/* ]] || [[ "$base_ref" == "master" ]] || [[ "$base_ref" == "main" ]]; then
            local remote_ref="origin/${base_ref#origin/}"
            echo -e "${BLUE}Updating reference:${NC} $remote_ref"
            git fetch origin "${base_ref#origin/}" --quiet 2>/dev/null || true
            base_ref="$remote_ref"
        fi

        local mode_label="worktree"
        [ "$use_clone" = true ] && mode_label="clone"

        echo -e "${BLUE}Creating $mode_label:${NC} $worktree_name"
        echo -e "  New branch: $new_branch_name"
        echo -e "  Base:   $base_ref"
        echo -e "  Port:   $port"
        echo -e "  Dir:    $worktree_dir"
        echo ""

        git_worktree_args=(-b "$new_branch_name" "$worktree_dir" "$base_ref")
    else
        # No base ref: use existing branch
        local mode_label="worktree"
        [ "$use_clone" = true ] && mode_label="clone"

        echo -e "${BLUE}Creating $mode_label:${NC} $worktree_name"
        echo -e "  Branch: $branch"
        echo -e "  Port:   $port"
        echo -e "  Dir:    $worktree_dir"
        echo ""

        git_worktree_args=("$worktree_dir" "$branch")
    fi

    # Dry-run mode: show what would be created without creating
    if [ "$dry_run" = true ]; then
        local mode_str="worktree"
        [ "$use_clone" = true ] && mode_str="clone"
        echo -e "${YELLOW}[DRY-RUN] Would create $mode_str with above settings${NC}"
        echo ""
        echo "Run without --dry-run to create."
        exit 0
    fi

    # Check for submodules (warn but don't block) - only for worktree mode
    if [ "$use_clone" = false ]; then
        if ! detect_submodules "$MAIN_APP"; then
            release_metadata_lock
            exit 1
        fi
    fi

    # Create workspace (worktree or clone)
    local workspace_mode="worktree"
    if [ "$use_clone" = true ]; then
        workspace_mode="clone"
        echo "Cloning repository..."
        git clone --quiet "$MAIN_APP" "$worktree_dir"

        # Checkout the correct branch
        cd "$worktree_dir"
        local final_branch="${new_branch_name:-$branch}"

        if [ -n "$new_branch_name" ]; then
            # Create new branch from base
            local checkout_base="${base_ref:-HEAD}"
            # If base is remote ref, fetch it first
            if [[ "$checkout_base" == origin/* ]]; then
                git fetch origin "${checkout_base#origin/}" --quiet 2>/dev/null || true
            fi
            git checkout -b "$new_branch_name" "$checkout_base" --quiet 2>/dev/null || \
                git checkout -b "$new_branch_name" "origin/${checkout_base#origin/}" --quiet 2>/dev/null || \
                git checkout -b "$new_branch_name" --quiet
        else
            # Checkout existing branch
            git checkout "$branch" --quiet 2>/dev/null || \
                git checkout -b "$branch" "origin/$branch" --quiet 2>/dev/null || true
        fi
        cd - > /dev/null
        echo -e "  ${GREEN}✓ Clone created${NC}"
    else
        # Create worktree (original logic)
        git worktree add "${git_worktree_args[@]}"
    fi

    # Save metadata
    local final_branch="${new_branch_name:-$branch}"
    local final_base="${base_ref:-master}"
    local final_base_commit=$(git -C "$worktree_dir" merge-base HEAD "origin/${final_base#origin/}" 2>/dev/null || git -C "$worktree_dir" rev-parse HEAD 2>/dev/null)
    local final_base_short=$(git -C "$worktree_dir" rev-parse --short "$final_base_commit" 2>/dev/null || echo "?")
    local final_desc="${description:-}"

    save_metadata "$worktree_name" "$worktree_dir" "$final_branch" "$final_base" "$final_base_short" "$port" "$final_desc" "$workspace_mode"
    echo -e "  ${GREEN}✓ Metadata saved${NC}"

    # Release port allocation lock now that metadata is saved
    release_metadata_lock
    trap - EXIT  # Clear the exit trap

    # Set context for Pwtfile and hooks
    export PWT_WORKTREE="$worktree_name"
    export PWT_WORKTREE_PATH="$worktree_dir"
    export PWT_BRANCH="$final_branch"
    export PWT_PORT="$port"
    export PWT_TICKET="$worktree_name"  # User can customize via Pwtfile
    export PWT_BASE="$final_base"
    export PWT_DESC="$final_desc"
    export PWT_PROJECT="$CURRENT_PROJECT"
    export MAIN_APP="$MAIN_APP"

    # Run Pwtfile setup (if exists), then hook
    run_pwtfile "setup"
    run_hook "post-create"

    # Auto-set as current worktree (non-fatal)
    set_current_worktree "$worktree_name" 2>/dev/null || true

    local mode_label="Worktree"
    [ "$workspace_mode" = "clone" ] && mode_label="Clone" || true

    echo -e "\n${GREEN}✓ $mode_label created successfully!${NC}"
    clear_list_cache  # Invalidate cache so next list shows new worktree
    echo ""
    echo "To use:"
    echo -e "  ${BLUE}cd $worktree_dir${NC}  or  ${BLUE}z ${worktree_name}${NC}"
    echo -e "  Port: ${BLUE}$port${NC}"

    # Open editor if requested
    if [ "$open_editor" = true ]; then
        echo ""
        cmd_editor "$worktree_name"
    fi

    # Start AI tool if requested
    if [ "$start_ai" = true ]; then
        echo ""
        cmd_ai "$worktree_name"
    fi

    return 0
}

# Check port status for a worktree
# Arguments: port [worktree_dir]
# Returns: colored text with status
check_port_status() {
    local port="$1"
    local worktree_dir="${2:-}"

    if ! [[ "$port" =~ ^[0-9]+$ ]]; then
        echo -e "${YELLOW}[port ?]${NC}"
        return
    fi

    # Without lsof, we can't check port status
    if ! has_lsof; then
        echo -e "${YELLOW}[port $port]${NC}"
        return
    fi

    local pids=$(get_pids_on_port "$port")

    # If no port occupied, it's free
    if [ -z "$pids" ]; then
        echo -e "${GREEN}[port $port free]${NC}"
        return
    fi

    # Port is in use - show process info
    local first_pid=$(echo "$pids" | head -1)
    local proc=$(ps -p "$first_pid" -o comm= 2>/dev/null || echo "?")
    echo -e "${GREEN}[port $port: $proc]${NC}"
}

# Prefetch remote refs once (for list performance)
# Call this before looping through worktrees
prefetch_remote_refs() {
    if [ "$LIST_QUICK_MODE" = true ]; then
        return 0  # Skip in quick mode
    fi
    if [ "$PREFETCH_DONE" = true ]; then
        return 0  # Already fetched
    fi
    if [ ! -d "$MAIN_APP" ]; then
        return 0  # No main app
    fi

    cd "$MAIN_APP"
    # Fetch only default branch (faster than --prune which fetches all)
    local target="${DEFAULT_BRANCH:-master}"
    git fetch origin "$target" --quiet 2>/dev/null || true
    PREFETCH_DONE=true
}

# Check if branch is merged into master
# IMPORTANT: Also checks for uncommitted changes to avoid data loss
check_merge_status() {
    local dir="$1"
    local target="${2:-master}"
    local wt_commit=$(git -C "$dir" rev-parse HEAD 2>/dev/null)

    if [ -z "$wt_commit" ]; then
        echo -e "${RED}[corrupted]${NC}"
        return
    fi

    # Check for uncommitted changes (staged, modified, or untracked)
    local has_changes=false
    local git_status=$(git -C "$dir" status --porcelain 2>/dev/null)
    if [ -n "$git_status" ]; then
        has_changes=true
    fi

    # If there are uncommitted changes, ALWAYS show as open (unsafe to remove)
    if [ "$has_changes" = true ]; then
        echo -e "${YELLOW}[has changes]${NC}"
        return
    fi

    # Note: Assumes prefetch_remote_refs() was called before the loop
    # (performance: fetch once instead of per-worktree)
    cd "$MAIN_APP"

    if git merge-base --is-ancestor "$wt_commit" "origin/$target" 2>/dev/null; then
        # Check if branch ever diverged from target
        # If merge-base equals HEAD, branch never had unique commits
        local merge_base=$(git -C "$dir" merge-base HEAD "origin/$target" 2>/dev/null)
        if [ "$merge_base" = "$wt_commit" ]; then
            # Branch never diverged - no work done yet
            echo -e "${BLUE}[clean]${NC}"
        else
            # Branch had commits that are now in target
            echo -e "${GREEN}[merged]${NC}"
        fi
    else
        echo -e "${YELLOW}[open]${NC}"
    fi
}

# Command: list (porcelain output)
# Internal function for JSON output (uses jq for proper escaping)
cmd_list_porcelain() {
    local show_dirty_only="${1:-false}"
    local worktrees_json="[]"

    if [ -d "$WORKTREES_DIR" ] && [ "$(ls -A "$WORKTREES_DIR" 2>/dev/null)" ]; then
        for dir in "$WORKTREES_DIR"/*/; do
            [ -d "$dir" ] || continue

            local name=$(basename "$dir")
            local port=$(get_metadata "$name" "port")
            local branch=$(git -C "$dir" branch --show-current 2>/dev/null || echo "detached")
            local commit=$(git -C "$dir" rev-parse --short HEAD 2>/dev/null || echo "?")

            # Check for uncommitted changes
            local is_dirty=false
            local staged=$(git -C "$dir" diff --cached --numstat 2>/dev/null | wc -l | tr -d ' ')
            local unstaged=$(git -C "$dir" diff --numstat 2>/dev/null | wc -l | tr -d ' ')
            local untracked=$(git -C "$dir" ls-files --others --exclude-standard 2>/dev/null | wc -l | tr -d ' ')
            if [ "$staged" -gt 0 ] || [ "$unstaged" -gt 0 ] || [ "$untracked" -gt 0 ]; then
                is_dirty=true
            fi

            # Skip if --dirty and not dirty
            if [ "$show_dirty_only" = true ] && [ "$is_dirty" = false ]; then
                continue
            fi

            local meta_base=$(get_metadata "$name" "base")
            local meta_desc=$(get_metadata "$name" "description")

            # Build worktree JSON object with proper escaping via jq
            local wt_json
            wt_json=$(jq -n \
                --arg name "$name" \
                --arg path "$dir" \
                --arg branch "$branch" \
                --arg commit "$commit" \
                --arg port "${port:-}" \
                --argjson dirty "$is_dirty" \
                --arg base "${meta_base:-}" \
                --arg description "${meta_desc:-}" \
                '{name: $name, path: $path, branch: $branch, commit: $commit, port: $port, dirty: $dirty, base: $base, description: $description}')

            # Append to array
            worktrees_json=$(echo "$worktrees_json" | jq --argjson wt "$wt_json" '. + [$wt]')
        done
    fi

    # Output final JSON with proper escaping
    jq -n \
        --arg project "$CURRENT_PROJECT" \
        --arg main_app "$MAIN_APP" \
        --arg worktrees_dir "$WORKTREES_DIR" \
        --argjson worktrees "$worktrees_json" \
        '{project: $project, main_app: $main_app, worktrees_dir: $worktrees_dir, worktrees: $worktrees}'
}

# Command: list
# Usage: pwt list [--dirty] [--porcelain]
cmd_list() {
    local show_dirty_only=false
    local porcelain=false
    local verbose=false
    local statusline=false

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            -d|--dirty)
                show_dirty_only=true
                shift
                ;;
            --porcelain)
                porcelain=true
                shift
                ;;
            --verbose|-v)
                verbose=true
                shift
                ;;
            -q|--quick)
                LIST_QUICK_MODE=true
                shift
                ;;
            -r|--refresh)
                LIST_REFRESH_MODE=true
                shift
                ;;
            statusline)
                statusline=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    # Statusline mode: compact single-line for prompts
    if [ "$statusline" = true ]; then
        cmd_list_statusline
        return
    fi

    # Porcelain mode: output JSON
    if [ "$porcelain" = true ]; then
        cmd_list_porcelain "$show_dirty_only"
        return
    fi

    # Verbose mode: detailed output (original format)
    if [ "$verbose" = true ]; then
        cmd_list_verbose "$show_dirty_only"
        return
    fi

    # Default: compact tabular format with caching
    # Cache logic: first run slow (builds cache), subsequent runs fast (uses cache)
    # Cache always stores FULL list (no -d filter); -d filter applied on read

    local cache_file
    cache_file=$(get_list_cache_file)

    # Helper to read cache (with optional dirty filter)
    read_cache() {
        if [ "$show_dirty_only" = true ]; then
            read_list_cache_filtered
        else
            cat "$cache_file"
        fi
    }

    # Helper to generate cache (always full list, no -d filter)
    generate_cache() {
        init_cache_dir
        cmd_list_compact "" > "$cache_file"
    }

    # --refresh: clear cache and regenerate
    if [ "$LIST_REFRESH_MODE" = true ]; then
        clear_list_cache
        generate_cache
        read_cache
        return
    fi

    # --quick: always use cache if exists (even if stale)
    if [ "$LIST_QUICK_MODE" = true ]; then
        if [ -f "$cache_file" ]; then
            read_cache
            return
        fi
        # No cache, generate (but still skip network via LIST_QUICK_MODE)
        generate_cache
        read_cache
        return
    fi

    # Default: use cache if valid, else regenerate
    if is_list_cache_valid; then
        read_cache
    else
        generate_cache
        read_cache
    fi
}

# Print a table row with fixed column widths
# Usage: print_table_row <marker> <name> <branch> <hash> <base> <stat> <main_div> <remote_div> <age> <meta>
print_table_row() {
    local marker="$1"
    local name="$2"
    local branch="$3"
    local hash="$4"
    local base="$5"
    local stat="$6"
    local main_div="$7"
    local remote_div="$8"
    local age="$9"
    local meta="${10}"

    # Build row with proper visual padding for Unicode columns
    # Format: marker(2) name(20) branch(40) hash(8) base(8) stat(4) main(10) remote(10) age(4) meta
    printf "  %-2s " "$marker"
    pad_visual "${name:0:20}" 20
    printf " "
    pad_visual "${branch:0:40}" 40
    printf " "
    printf "%-8s " "${hash:0:8}"
    pad_visual "${base:0:8}" 8
    printf " "
    printf "%-4s " "${stat:-·}"
    pad_visual "${main_div:-·}" 10
    printf " "
    pad_visual "${remote_div:-·}" 10
    printf " "
    printf "%-4s " "$age"
    printf "%s\n" "$meta"
}

# Compact tabular list format (default)
cmd_list_compact() {
    local show_dirty_only="${1:-false}"

    # If project not cloned, show helpful message and exit
    if [ ! -d "$MAIN_APP" ]; then
        echo -e "${BLUE}${CURRENT_PROJECT}${NC}: ${YELLOW}not cloned${NC}"
        [ -n "$PROJECT_REMOTE" ] && echo -e "  Run: ${GREEN}pwt clone${NC}"
        return 0
    fi

    echo -e "${BLUE}${CURRENT_PROJECT}${NC}"
    echo ""

    # Print header
    print_table_row "" "Worktree" "Branch" "Hash" "Base" "Stat" "main↕" "Remote" "Age" "Meta"
    print_table_row "--" "--------------------" "----------------------------------------" "--------" "--------" "----" "----------" "----------" "----" "--------------------"

    # Main app row
    local main_branch=$(git -C "$MAIN_APP" branch --show-current 2>/dev/null || echo "?")
    local main_hash=$(get_short_hash "$MAIN_APP")
    local main_status=$(get_status_symbols "$MAIN_APP")
    local main_age_ts=$(git -C "$MAIN_APP" log -1 --format=%ct 2>/dev/null || echo "0")
    local main_age=$(format_relative_time "$main_age_ts")
    local main_remote=$(get_remote_divergence "$MAIN_APP")

    # Check if main is current
    local main_marker=" "
    if [ "$PWD" = "$MAIN_APP" ]; then
        main_marker="@"
    elif is_previous_worktree "$MAIN_APP"; then
        main_marker="*"
    fi

    print_table_row "$main_marker" "@" "$main_branch" "$main_hash" "·" "${main_status:-·}" "·" "${main_remote:-·}" "$main_age" "description=main application"

    # Prefetch remote refs once (performance: avoids N fetches in loop)
    prefetch_remote_refs

    # Worktrees
    local has_merged=false
    if [ -d "$WORKTREES_DIR" ] && [ "$(ls -A "$WORKTREES_DIR" 2>/dev/null)" ]; then
        for dir in "$WORKTREES_DIR"/*/; do
            [ -d "$dir" ] || continue
            local name=$(basename "$dir")

            # Git info
            local branch=$(git -C "$dir" branch --show-current 2>/dev/null || echo "detached")
            local hash=$(get_short_hash "$dir")
            local base=$(get_base_branch "$name" "$dir")

            # Status symbols
            local status=$(get_status_symbols "$dir")
            local is_dirty=false
            [ -n "$status" ] && is_dirty=true

            # Skip if --dirty and not dirty
            if [ "$show_dirty_only" = true ] && [ "$is_dirty" = false ]; then
                continue
            fi

            # Divergence from main
            local main_div=$(get_divergence "$dir" "origin/${DEFAULT_BRANCH:-master}")

            # Remote divergence
            local remote_div=$(get_remote_divergence "$dir")

            # Age
            local age_ts=$(git -C "$dir" log -1 --format=%ct 2>/dev/null || echo "0")
            local age=$(format_relative_time "$age_ts")

            # Markers: @ = current, * = previous
            local marker=" "
            if [ "$PWD" = "${dir%/}" ]; then
                marker="@"
            elif is_previous_worktree "${dir%/}"; then
                marker="*"
            fi

            # Check merge status for tips
            local merge_status=$(check_merge_status "$dir" "${DEFAULT_BRANCH:-master}" 2>/dev/null)
            if [[ "$merge_status" == *"merged"* ]] || [[ "$merge_status" == *"clean"* ]]; then
                has_merged=true
            fi

            # Build meta string from metadata (includes port, description, custom fields)
            local meta=$(get_extra_metadata "$name")

            # If no description in metadata, generate fallback
            if [[ "$meta" != *"description="* ]]; then
                local desc=""
                # Extract from branch name
                if [[ "$branch" =~ ^[^/]+/[A-Z]+-[0-9]+-(.*) ]]; then
                    desc=$(echo "${BASH_REMATCH[1]}" | tr '-' ' ')
                elif [[ ! "$branch" =~ ^[^/]+/[A-Z]+-[0-9]+$ ]]; then
                    if [[ "$branch" =~ ^[^/]+/(.+) ]]; then
                        desc=$(echo "${BASH_REMATCH[1]}" | tr '-' ' ')
                    fi
                fi
                # Fallback to commit message
                if [ -z "$desc" ]; then
                    desc=$(git -C "$dir" log --oneline --no-merges -1 --format=%s 2>/dev/null | head -c 40)
                fi
                [ -n "$desc" ] && meta="$meta description=$desc"
            fi

            [ -z "$meta" ] && meta="·"

            print_table_row "$marker" "$name" "$branch" "$hash" "$base" "${status:-·}" "${main_div:-·}" "${remote_div:-·}" "$age" "$meta"
        done
    fi

    echo ""

    # Tips
    if [ "$has_merged" = true ]; then
        echo -e "${YELLOW}Tip:${NC} Run ${GREEN}pwt auto-remove${NC} to clean up merged worktrees"
    fi

    # Legend
    echo -e "${BLUE}Legend:${NC} @ current  * previous  + staged  ! modified  ? untracked"
}

# Statusline for shell prompts
# Usage: pwt list statusline
# Output: [TICKET-123 +! ↑3 ⇡2] or empty if in main
cmd_list_statusline() {
    # Only show if in a worktree
    local worktree=""
    local dir=""

    if [ -n "${PWT_WORKTREE:-}" ]; then
        worktree="$PWT_WORKTREE"
        dir="$WORKTREES_DIR/$worktree"
    else
        # Try to detect from PWD
        if [[ "$PWD" == *"-worktrees/"* ]]; then
            worktree=$(basename "$PWD")
            dir="$PWD"
        else
            # In main app or not in worktree - output nothing
            return 0
        fi
    fi

    [ ! -d "$dir" ] && return 0

    local status=$(get_status_symbols "$dir")
    local main_div=$(get_divergence "$dir" "origin/${DEFAULT_BRANCH:-master}")
    local remote_div=$(get_remote_divergence "$dir")

    # Build statusline
    local parts=()
    parts+=("$worktree")
    [ -n "$status" ] && parts+=("$status")
    [ -n "$main_div" ] && parts+=("$main_div")
    [ -n "$remote_div" ] && parts+=("$remote_div")

    echo "[${parts[*]}]"
}

# Verbose list format (original detailed format)
cmd_list_verbose() {
    local show_dirty_only="${1:-false}"

    echo -e "${BLUE}Worktrees (${CURRENT_PROJECT}):${NC}\n"

    # Show config info
    echo -e "  ${BLUE}Config:${NC}"

    # Project path
    if [ -d "$MAIN_APP" ]; then
        echo -e "    Path:      $MAIN_APP"
    else
        echo -e "    Path:      ${YELLOW}$MAIN_APP (not cloned)${NC}"
        [ -n "$PROJECT_REMOTE" ] && echo -e "    Remote:    $PROJECT_REMOTE"
    fi

    # Worktrees directory
    echo -e "    Worktrees: $WORKTREES_DIR"

    # Pwtfiles (show all that would be used)
    local pwtfiles=()
    local config_pwtfile=$(get_project_config "$CURRENT_PROJECT" "pwtfile")
    if [ -n "$config_pwtfile" ]; then
        config_pwtfile="${config_pwtfile/#\~/$HOME}"
        [[ "$config_pwtfile" != /* ]] && config_pwtfile="$MAIN_APP/$config_pwtfile"
        if [ -f "$config_pwtfile" ]; then
            pwtfiles+=("$config_pwtfile (config)")
        else
            pwtfiles+=("${config_pwtfile} ${YELLOW}(config, missing)${NC}")
        fi
    fi
    if [ -f "$MAIN_APP/Pwtfile" ]; then
        pwtfiles+=("$MAIN_APP/Pwtfile (local)")
    fi
    if [ -f "$PWT_DIR/Pwtfile" ]; then
        pwtfiles+=("$PWT_DIR/Pwtfile (global)")
    fi

    if [ ${#pwtfiles[@]} -gt 0 ]; then
        echo -e "    Pwtfile:   ${pwtfiles[0]}"
        for ((i=1; i<${#pwtfiles[@]}; i++)); do
            echo -e "               ${pwtfiles[$i]}"
        done
    else
        echo -e "    Pwtfile:   ${YELLOW}(none)${NC}"
    fi
    echo ""

    # If project not cloned, show helpful message and exit
    if [ ! -d "$MAIN_APP" ]; then
        echo -e "  ${YELLOW}Project not cloned.${NC}"
        if [ -n "$PROJECT_REMOTE" ]; then
            echo -e "  Run: ${GREEN}pwt clone${NC} to clone from remote"
        fi
        echo ""
        return 0
    fi

    # Main app - also used as default target for merge status
    local main_branch=$(git -C "$MAIN_APP" branch --show-current 2>/dev/null || echo "?")
    local default_target="${main_branch:-master}"
    local main_commit=$(git -C "$MAIN_APP" rev-parse --short HEAD 2>/dev/null || echo "?")
    echo -e "  ${YELLOW}${CURRENT_PROJECT}${NC} (main)"
    echo -e "    Branch: $main_branch @ $main_commit"
    echo -n "    Server: "
    check_server_status "$MAIN_APP"
    echo -n "    Port:   "
    check_port_status 5000 "$MAIN_APP"
    echo ""

    # Worktrees
    local has_port_issues=false
    local has_merged=false
    if [ -d "$WORKTREES_DIR" ] && [ "$(ls -A "$WORKTREES_DIR" 2>/dev/null)" ]; then
        for dir in "$WORKTREES_DIR"/*/; do
            if [ -d "$dir" ]; then
                local name=$(basename "$dir")

                # Get port from metadata first, fallback to extracting from name
                local port=$(get_metadata "$name" "port")
                if [ -z "$port" ]; then
                    # Legacy: extract from directory name if ends with -XXXX
                    if [[ "$name" =~ -([0-9]{4})$ ]]; then
                        port="${BASH_REMATCH[1]}"
                    fi
                fi

                # Git info
                local branch=$(git -C "$dir" branch --show-current 2>/dev/null || echo "detached")
                local commit=$(git -C "$dir" rev-parse --short HEAD 2>/dev/null || echo "?")
                local upstream=$(git -C "$dir" rev-parse --abbrev-ref "${branch}@{upstream}" 2>/dev/null || echo "")

                # Get metadata (if exists)
                local meta_base=$(get_metadata "$name" "base")
                local meta_base_commit=$(get_metadata "$name" "base_commit")
                local meta_desc=$(get_metadata "$name" "description")

                # Find base branch info
                local base_name=""
                local base_short=""
                local base_ahead=""

                if [ -n "$meta_base" ]; then
                    # Use metadata for base
                    base_name="$meta_base"
                    base_short="$meta_base_commit"
                    # Calculate ahead/behind from current base
                    local base_ref="origin/${meta_base#origin/}"
                    local base_commit=$(git -C "$dir" merge-base HEAD "$base_ref" 2>/dev/null)
                    if [ -n "$base_commit" ]; then
                        local commits_ahead=$(git -C "$dir" rev-list --count "${base_commit}..HEAD" 2>/dev/null || echo "0")
                        local commits_behind=$(git -C "$dir" rev-list --count "HEAD..$base_ref" 2>/dev/null || echo "0")
                        if [ "$commits_ahead" -gt 0 ] || [ "$commits_behind" -gt 0 ]; then
                            base_ahead=" (↑${commits_ahead} ↓${commits_behind})"
                        fi
                    fi
                else
                    # Fallback: calculate merge-base with default branch
                    base_name="${DEFAULT_BRANCH:-master}"
                    local base_commit=$(git -C "$dir" merge-base HEAD "origin/${DEFAULT_BRANCH:-master}" 2>/dev/null)
                    if [ -n "$base_commit" ]; then
                        base_short=$(git -C "$dir" rev-parse --short "$base_commit" 2>/dev/null)
                        local commits_ahead=$(git -C "$dir" rev-list --count "${base_commit}..HEAD" 2>/dev/null || echo "0")
                        local commits_behind=$(git -C "$dir" rev-list --count "HEAD..origin/${DEFAULT_BRANCH:-master}" 2>/dev/null || echo "0")
                        if [ "$commits_ahead" -gt 0 ] || [ "$commits_behind" -gt 0 ]; then
                            base_ahead=" (↑${commits_ahead} ↓${commits_behind})"
                        fi
                    fi
                fi

                # Get description from metadata or extract from branch name
                local desc=""
                if [ -n "$meta_desc" ]; then
                    desc="$meta_desc"
                elif [ -n "$branch" ] && [ "$branch" != "detached" ]; then
                    desc=$(echo "$branch" | sed -E 's|^[a-z]+/||')
                    desc=$(echo "$desc" | tr '-' ' ')
                fi

                # Check for uncommitted changes
                local changes=""
                local is_dirty=false
                local staged=$(git -C "$dir" diff --cached --numstat 2>/dev/null | wc -l | tr -d ' ')
                local unstaged=$(git -C "$dir" diff --numstat 2>/dev/null | wc -l | tr -d ' ')
                local untracked=$(git -C "$dir" ls-files --others --exclude-standard 2>/dev/null | wc -l | tr -d ' ')
                if [ "$staged" -gt 0 ] || [ "$unstaged" -gt 0 ] || [ "$untracked" -gt 0 ]; then
                    is_dirty=true
                    local parts=()
                    [ "$staged" -gt 0 ] && parts+=("${staged} staged")
                    [ "$unstaged" -gt 0 ] && parts+=("${unstaged} modified")
                    [ "$untracked" -gt 0 ] && parts+=("${untracked} untracked")
                    changes=$(IFS=', '; echo "${parts[*]}")
                fi

                # Skip if --dirty and not dirty
                if [ "$show_dirty_only" = true ] && [ "$is_dirty" = false ]; then
                    continue
                fi

                # Title with description
                if [ -n "$desc" ]; then
                    echo -e "  ${YELLOW}$name${NC} - ${desc}"
                else
                    echo -e "  ${YELLOW}$name${NC}"
                fi

                # Branch and commit
                echo -e "    Branch: $branch @ $commit"

                # Base (where it was created from)
                if [ -n "$base_short" ]; then
                    echo -e "    Base:   $base_name @ $base_short$base_ahead"
                fi

                # Upstream/target only if different from "origin/<branch>" (i.e., meaningful)
                if [ -n "$upstream" ] && [ "$upstream" != "origin/$branch" ] && [ "$upstream" != "origin/${DEFAULT_BRANCH:-master}" ]; then
                    echo -e "    Target: $upstream"
                fi

                # Uncommitted changes
                if [ -n "$changes" ]; then
                    echo -e "    Changes: ${YELLOW}$changes${NC}"
                fi

                # Server status
                echo -n "    Server: "
                check_server_status "$dir"

                # Port status
                echo -n "    Port:   "
                local port_status=$(check_port_status "$port" "$dir")
                echo -e "$port_status"
                if [[ "$port_status" == *"conflict"* ]]; then
                    has_port_issues=true
                fi

                # Merge status
                echo -n "    Status: "
                local merge_status=$(check_merge_status "$dir" "$default_target")
                echo -e "$merge_status"
                if [[ "$merge_status" == *"merged"* ]] || [[ "$merge_status" == *"clean"* ]]; then
                    has_merged=true
                fi
                echo ""
            fi
        done
    else
        echo -e "  ${YELLOW}(no worktrees created)${NC}"
        echo ""
    fi

    # Tips
    if [ "$has_port_issues" = true ]; then
        echo -e "${YELLOW}Tip:${NC} Use ${GREEN}pwt fix-port <worktree>${NC} to resolve occupied ports"
    fi
    if [ "$has_merged" = true ]; then
        echo -e "${YELLOW}Tip:${NC} Use ${GREEN}pwt auto-remove${NC} to clean up merged worktrees"
    fi
    if [ "$has_port_issues" = false ] && [ "$has_merged" = false ]; then
        echo ""
    fi
}

# Command: tree
# Visual tree view of worktrees - mental map of active work
# Usage: pwt tree [--all] [--dirty] [--ports] [--short]
cmd_tree() {
    local show_all=false
    local show_dirty_only=false
    local show_ports=false
    local short_mode=false

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --all|-a)
                show_all=true
                shift
                ;;
            --dirty|-d)
                show_dirty_only=true
                shift
                ;;
            --ports|-p)
                show_ports=true
                shift
                ;;
            --short|-s)
                short_mode=true
                shift
                ;;
            -h|--help)
                echo "Usage: pwt tree [--all] [--dirty] [--ports] [--short]"
                echo ""
                echo "Visual tree view of worktrees - mental map of active work."
                echo ""
                echo "Options:"
                echo "  --all, -a     Show all projects (global view)"
                echo "  --dirty, -d   Show only dirty worktrees"
                echo "  --ports, -p   Show port mappings"
                echo "  --short, -s   One line per worktree"
                echo ""
                echo "Examples:"
                echo "  pwt tree              # current project"
                echo "  pwt tree --all        # all projects"
                echo "  pwt tree --dirty      # only dirty worktrees"
                echo "  pwt tree --ports      # show ports"
                return 0
                ;;
            *)
                echo -e "${RED}Unknown option: $1${NC}" >&2
                return 1
                ;;
        esac
    done

    # Helper to render a project tree
    _render_project_tree() {
        local project="$1"
        local project_dir="$PROJECTS_DIR/$project"
        local config_file="$project_dir/config.json"

        [ -f "$config_file" ] || return

        local main_app=$(jq -r '.path // empty' "$config_file")
        local worktrees_dir=$(jq -r '.worktrees_dir // empty' "$config_file")

        [ -d "$main_app" ] || return

        # Project header
        echo -e "${YELLOW}${project}/${NC}"

        # Main app
        local main_branch=$(git -C "$main_app" branch --show-current 2>/dev/null || echo "?")
        local main_status=""
        if [ -n "$(git -C "$main_app" status --porcelain 2>/dev/null)" ]; then
            main_status=" ${RED}*${NC}"
        fi
        if [ "$short_mode" = true ]; then
            echo -e "├─ ${GREEN}@${NC} main ($main_branch)$main_status"
        else
            echo -e "├─ ${GREEN}@${NC} (main)"
            echo -e "│  └─ $main_branch$main_status"
        fi

        # Worktrees
        if [ -d "$worktrees_dir" ] && [ "$(ls -A "$worktrees_dir" 2>/dev/null)" ]; then
            local wt_dirs=("$worktrees_dir"/*/)
            local wt_count=${#wt_dirs[@]}
            local i=0

            for dir in "${wt_dirs[@]}"; do
                [ -d "$dir" ] || continue
                i=$((i + 1))

                local name=$(basename "$dir")
                local branch=$(git -C "$dir" branch --show-current 2>/dev/null || echo "detached")
                local desc=$(get_metadata "$name" "description" 2>/dev/null)
                local port=$(get_metadata "$name" "port" 2>/dev/null)

                # Status
                local status_text=""
                local is_dirty=false
                if [ -n "$(git -C "$dir" status --porcelain 2>/dev/null)" ]; then
                    local dirty_count=$(git -C "$dir" status --porcelain 2>/dev/null | wc -l | tr -d ' ')
                    status_text=" ${RED}*${dirty_count}${NC}"
                    is_dirty=true
                fi

                # Skip if --dirty and not dirty
                if [ "$show_dirty_only" = true ] && [ "$is_dirty" = false ]; then
                    continue
                fi

                # Current marker
                local current_marker=""
                local current_name=$(get_current_from_symlink 2>/dev/null)
                if [ "$name" = "$current_name" ]; then
                    current_marker=" ${BLUE}[current]${NC}"
                fi

                # Tree connector
                local connector="├─"
                if [ $i -eq $wt_count ]; then
                    connector="└─"
                fi

                # Port info
                local port_text=""
                if [ "$show_ports" = true ] && [ -n "$port" ]; then
                    port_text=" :$port"
                fi

                if [ "$short_mode" = true ]; then
                    echo -e "$connector $branch$port_text$status_text$current_marker"
                else
                    echo -e "$connector ${GREEN}$name${NC}$current_marker"
                    [ -n "$desc" ] && echo -e "│  ├─ \"$desc\""
                    echo -e "│  ├─ $branch$port_text"
                    echo -e "│  └─ status:$status_text${status_text:- ${GREEN}clean${NC}}"
                fi
            done
        else
            echo -e "└─ ${DIM}(no worktrees)${NC}"
        fi

        echo ""
    }

    init_metadata

    if [ "$show_all" = true ]; then
        # Global view - all projects
        echo -e "${DIM}~/.pwt/projects/${NC}"
        echo ""
        for project_dir in "$PROJECTS_DIR"/*/; do
            [ -d "$project_dir" ] || continue
            local project=$(basename "$project_dir")
            _render_project_tree "$project"
        done
    else
        # Current project only
        require_project
        _render_project_tree "$CURRENT_PROJECT"
    fi
}

# Command: repair
# Runs post-create hook on worktrees (project-specific repairs via Pwtfile)
cmd_repair() {
    local name="$1"

    if [ -n "$name" ]; then
        # Repair specific worktree
        local worktree_dir="$WORKTREES_DIR/$name"
        if [ ! -d "$worktree_dir" ]; then
            echo -e "${RED}Error: Worktree not found: $name${NC}"
            exit 1
        fi
        echo -e "${BLUE}Repairing: $name${NC}"
        export PWT_WORKTREE="$name"
        export PWT_WORKTREE_PATH="$worktree_dir"
        cd "$worktree_dir"
        run_pwtfile "repair"
        run_hook "repair"
    else
        # Repair all worktrees
        echo -e "${BLUE}Repairing all worktrees...${NC}\n"

        if [ -d "$WORKTREES_DIR" ] && [ "$(ls -A "$WORKTREES_DIR" 2>/dev/null)" ]; then
            for dir in "$WORKTREES_DIR"/*/; do
                [ -d "$dir" ] || continue
                local wt_name=$(basename "$dir")
                echo -e "  ${YELLOW}$wt_name${NC}"
                export PWT_WORKTREE="$wt_name"
                export PWT_WORKTREE_PATH="$dir"
                cd "$dir"
                run_pwtfile "repair"
                run_hook "repair"
            done
        fi

        echo ""
        echo -e "${GREEN}Done!${NC}"
    fi
}

# Command: auto-remove (cleanup merged worktrees)
# Usage: pwt auto-remove [target] [--execute] [--dry-run]
# SAFETY: Dry-run by default. Must pass --execute to actually remove.
cmd_auto_remove() {
    local target_branch=""
    local dry_run=true  # SAFE DEFAULT: dry-run unless --execute
    local force_execute=false

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --execute|--yes|-y)
                force_execute=true
                dry_run=false
                shift
                ;;
            --dry-run|-n)
                dry_run=true
                shift
                ;;
            -h|--help)
                echo "Usage: pwt auto-remove [target] [options]"
                echo ""
                echo "Safely remove worktrees that have been merged into target branch."
                echo ""
                echo "Arguments:"
                echo "  target          Target branch to check merges against (default: current)"
                echo ""
                echo "Options:"
                echo "  --execute, -y   Actually remove (default is dry-run)"
                echo "  --dry-run, -n   Preview what would be removed (default)"
                echo "  -h, --help      Show this help"
                echo ""
                echo "Safety:"
                echo "  - Dry-run by default (shows what would be removed)"
                echo "  - Dirty worktrees backed up to ~/.pwt/trash/"
                echo "  - Requires --execute for non-interactive use"
                return 0
                ;;
            -*)
                echo -e "${RED}Unknown option: $1${NC}"
                exit 1
                ;;
            *)
                target_branch="$1"
                shift
                ;;
        esac
    done

    # SAFETY: Require interactive terminal or --execute flag
    if [ "$force_execute" = false ] && [ ! -t 0 ]; then
        echo -e "${RED}⛔ SAFETY: auto-remove requires --execute flag when run non-interactively${NC}"
        echo "This prevents accidental data loss from automated scripts."
        echo ""
        echo "Usage: pwt auto-remove [target] --execute"
        exit 1
    fi

    # If no branch specified, use current branch from main app
    if [ -z "$target_branch" ]; then
        cd "$MAIN_APP"
        target_branch=$(git branch --show-current 2>/dev/null)
        if [ -z "$target_branch" ]; then
            echo -e "${RED}Error: Could not detect current branch${NC}"
            echo "Usage: pwt auto-remove [target]"
            exit 1
        fi
        echo -e "${BLUE}Target branch (detected):${NC} $target_branch"
    fi

    echo -e "${BLUE}Checking worktrees merged into:${NC} $target_branch\n"

    # Fetch to ensure updated branches
    cd "$MAIN_APP"
    git fetch origin "$target_branch" --quiet 2>/dev/null || {
        echo -e "${RED}Error: Branch '$target_branch' not found on remote${NC}"
        exit 1
    }

    # Use origin/$target_branch for comparison (freshly fetched)
    local remote_target="origin/$target_branch"

    # List worktrees to remove
    local to_remove=()
    local pending=()

    if [ ! -d "$WORKTREES_DIR" ] || [ -z "$(ls -A "$WORKTREES_DIR" 2>/dev/null)" ]; then
        echo -e "${YELLOW}No worktrees found${NC}"
        exit 0
    fi

    for dir in "$WORKTREES_DIR"/*/; do
        [ -d "$dir" ] || continue

        local name=$(basename "$dir")

        # Get worktree HEAD commit
        local wt_commit=$(git -C "$dir" rev-parse HEAD 2>/dev/null)

        # Skip worktrees without valid commit (corrupted)
        if [ -z "$wt_commit" ]; then
            echo -e "  ${YELLOW}⚠️  CORRUPTED:${NC} $name (no commit)"
            to_remove+=("$name")
            continue
        fi

        local wt_branch=$(git -C "$dir" branch --show-current 2>/dev/null)
        local branch_display="${wt_branch:-detached}"

        # Check if worktree has uncommitted changes
        # SAFETY: Assume dirty if check fails (fail-safe)
        local is_dirty=true
        local git_status
        if git_status=$(git -C "$dir" status --porcelain 2>&1); then
            if [ -z "$git_status" ]; then
                is_dirty=false
            fi
        else
            echo -e "  ${RED}⚠️  CHECK FAILED:${NC} $name - cannot verify clean state, assuming dirty"
        fi

        # Check if worktree commit is contained in remote target branch (post-fetch)
        # Uses merge-base --is-ancestor which works even if remote branch was deleted
        if git merge-base --is-ancestor "$wt_commit" "$remote_target" 2>/dev/null; then
            if [ "$is_dirty" = true ]; then
                # Merged but has uncommitted changes - protect it
                echo -e "  ${YELLOW}⚠️  DIRTY:${NC} $name ($branch_display) - merged but has uncommitted changes"
                pending+=("$name")
            else
                echo -e "  ${GREEN}✅ MERGED:${NC} $name ($branch_display)"
                to_remove+=("$name")
            fi
        else
            echo -e "  ${YELLOW}⏳ PENDING:${NC} $name ($branch_display)"
            pending+=("$name")
        fi
    done

    echo ""

    # If nothing to remove, exit
    if [ ${#to_remove[@]} -eq 0 ]; then
        echo -e "${GREEN}No worktrees to remove${NC}"
        echo -e "Kept: ${#pending[@]}"
        exit 0
    fi

    # Dry-run mode: just show what would be removed
    if [ "$dry_run" = true ]; then
        echo -e "${YELLOW}[DRY-RUN] Would remove ${#to_remove[@]} worktree(s):${NC}"
        for name in "${to_remove[@]}"; do
            echo "  - $name"
        done
        echo ""
        echo -e "Would keep: ${#pending[@]}"
        exit 0
    fi

    # Remove merged worktrees
    echo -e "${BLUE}Removing ${#to_remove[@]} worktree(s)...${NC}\n"

    local removed=0
    for name in "${to_remove[@]}"; do
        echo -e "${YELLOW}Removing: $name${NC}"
        if cmd_remove "$name" 2>&1; then
            removed=$((removed + 1))
        else
            # SAFETY: Only manually remove if directory is truly empty or has no git data
            local wt_dir="$WORKTREES_DIR/$name"
            if [ -d "$wt_dir" ]; then
                # Check if it has any files (besides .git)
                local file_count=$(find "$wt_dir" -maxdepth 1 -type f 2>/dev/null | wc -l | tr -d ' ')
                local dir_count=$(find "$wt_dir" -maxdepth 1 -type d ! -name ".git" ! -name "." 2>/dev/null | wc -l | tr -d ' ')

                if [ "$file_count" -gt 0 ] || [ "$dir_count" -gt 0 ]; then
                    echo -e "  ${RED}⛔ SAFETY: Cannot manually remove - directory has files${NC}"
                    echo -e "  Use 'pwt remove $name -y' to force removal"
                    continue
                fi

                # Empty or git-only directory - safe to remove
                rm -rf "$wt_dir" 2>/dev/null && {
                    echo -e "  ${GREEN}✓ Removed empty/corrupted worktree${NC}"
                    removed=$((removed + 1))
                }
            fi
        fi
        echo ""
    done

    echo -e "${GREEN}Done!${NC}"
    echo -e "  Removed: $removed"
    echo -e "  Kept:    ${#pending[@]}"
}

# Command: remove
cmd_remove() {
    local name=""
    local with_branch=false
    local force_branch=false
    local kill_port=false
    local kill_sidekiq=false
    local auto_yes=false

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --with-branch)
                with_branch=true
                shift
                ;;
            --force-branch)
                with_branch=true
                force_branch=true
                shift
                ;;
            --kill-port)
                kill_port=true
                shift
                ;;
            --kill-sidekiq)
                kill_sidekiq=true
                shift
                ;;
            --kill-all)
                kill_port=true
                kill_sidekiq=true
                shift
                ;;
            -y|--yes)
                auto_yes=true
                shift
                ;;
            -h|--help)
                echo "Usage: pwt remove [worktree] [options]"
                echo ""
                echo "Arguments:"
                echo "  worktree        Worktree name (default: current)"
                echo ""
                echo "Options:"
                echo "  --with-branch     Also delete the branch (if merged)"
                echo "  --force-branch    Force delete the branch (even if not merged)"
                echo "  --kill-port       Kill processes using the port"
                echo "  --kill-sidekiq    Kill Sidekiq processes"
                echo "  --kill-all        Kill both port and Sidekiq processes"
                echo "  -y, --yes         Skip confirmation prompts"
                echo "  -h, --help        Show this help"
                echo ""
                echo "Safety: Dirty worktrees are backed up to ~/.pwt/trash/"
                return 0
                ;;
            -*)
                echo -e "${RED}Unknown option: $1${NC}"
                exit 1
                ;;
            *)
                name="$1"
                shift
                ;;
        esac
    done

    # If no name, try to use current worktree
    if [ -z "$name" ]; then
        if [ -n "${PWT_WORKTREE:-}" ]; then
            name="$PWT_WORKTREE"
        elif [[ "$PWD" == *"-worktrees/"* ]]; then
            name=$(basename "$PWD")
        else
            echo -e "${RED}Error: Not in a worktree. Specify target.${NC}"
            echo "Usage: pwt remove [worktree] [--with-branch] [--force-branch]"
            exit 1
        fi
        echo -e "${BLUE}Removing current worktree: $name${NC}"
    fi

    local worktree_dir="$WORKTREES_DIR/$name"

    if [ ! -d "$worktree_dir" ]; then
        echo -e "${RED}Error: Worktree not found: $name${NC}"
        exit 1
    fi

    # Get port from metadata, fallback to extracting from name
    local port=$(get_metadata "$name" "port")
    if [ -z "$port" ]; then
        # Legacy: extract from directory name if ends with -XXXX
        if [[ "$name" =~ -([0-9]{4})$ ]]; then
            port="${BASH_REMATCH[1]}"
        fi
    fi

    # Detect processes on port (generic - no framework-specific checks)
    local port_pids=""
    local port_info=""
    if [ -n "$port" ] && [[ "$port" =~ ^[0-9]+$ ]] && has_lsof; then
        local pids_on_port=$(get_pids_on_port "$port")
        for pid in $pids_on_port; do
            local proc_name=$(ps -p "$pid" -o comm= 2>/dev/null || echo "unknown")
            local proc_cmd=$(ps -p "$pid" -o args= 2>/dev/null || echo "unknown")
            port_pids="${port_pids}${port_pids:+ }$pid"
            port_info="${port_info}  PID $pid ($proc_name): $proc_cmd\n"
        done
    fi

    # Handle blocking processes
    if [ -n "$port_pids" ]; then
        if [ "$kill_port" = true ] || [ "$kill_sidekiq" = true ]; then
            echo -e "${YELLOW}Processes on port $port:${NC}"
            echo -e "$port_info"
            if [ "$auto_yes" = true ] || confirm_action "Kill these processes?"; then
                echo "$port_pids" | xargs kill -9 2>/dev/null || true
                sleep 1
                echo -e "  ${GREEN}✓ Port $port freed${NC}"
            else
                echo -e "${RED}Aborted.${NC}"
                exit 1
            fi
        else
            echo -e "${RED}Error: Processes detected on port $port:${NC}"
            echo -e "$port_info"
            echo ""
            echo "Options:"
            echo "  pwt remove $name --kill-port    # Kill port processes"
            echo "  pwt remove $name --kill-port -y # Kill without confirmation"
            exit 1
        fi
    fi

    echo -e "${YELLOW}Removing worktree: $name${NC}"

    # SAFETY: Check for uncommitted changes before removing
    local has_changes=false
    local changes_detail=""

    if [ -d "$worktree_dir" ]; then
        # Check using BOTH methods for maximum safety
        local porcelain_status=$(git -C "$worktree_dir" status --porcelain 2>/dev/null)
        local untracked_count=$(git -C "$worktree_dir" ls-files --others --exclude-standard 2>/dev/null | wc -l | tr -d ' ')
        local staged_count=$(git -C "$worktree_dir" diff --cached --name-only 2>/dev/null | wc -l | tr -d ' ')
        local modified_count=$(git -C "$worktree_dir" diff --name-only 2>/dev/null | wc -l | tr -d ' ')

        if [ -n "$porcelain_status" ] || [ "$untracked_count" -gt 0 ] || [ "$staged_count" -gt 0 ] || [ "$modified_count" -gt 0 ]; then
            has_changes=true
            changes_detail="staged=$staged_count, modified=$modified_count, untracked=$untracked_count"
        fi
    fi

    if [ "$has_changes" = true ]; then
        echo -e "${RED}⚠️  WARNING: Worktree has uncommitted changes!${NC}"
        echo -e "    ${changes_detail}"
        echo ""
        git -C "$worktree_dir" status --short 2>/dev/null | head -10
        echo ""

        if [ "$auto_yes" = true ]; then
            echo -e "${YELLOW}Proceeding due to -y flag (changes will be LOST)${NC}"
        elif [ -t 0 ]; then
            # Interactive terminal - ask for confirmation
            if ! confirm_action "Are you SURE you want to remove this worktree? Changes will be PERMANENTLY LOST!"; then
                echo -e "${GREEN}Aborted. Worktree preserved.${NC}"
                exit 1
            fi
        else
            # Non-interactive - refuse to proceed
            echo -e "${RED}⛔ SAFETY: Cannot remove dirty worktree non-interactively${NC}"
            echo "Use 'pwt remove $name -y' to force removal"
            exit 1
        fi
    fi

    # Get metadata for hooks/Pwtfile
    local branch=$(get_metadata "$name" "branch")
    local base=$(get_metadata "$name" "base")
    local desc=$(get_metadata "$name" "description")
    # Set context for Pwtfile and hooks
    export PWT_WORKTREE="$name"
    export PWT_WORKTREE_PATH="$worktree_dir"
    export PWT_BRANCH="$branch"
    export PWT_PORT="$port"
    export PWT_TICKET="$name"  # User can customize via Pwtfile
    export PWT_BASE="$base"
    export PWT_DESC="$desc"
    export PWT_PROJECT="$CURRENT_PROJECT"
    export MAIN_APP="$MAIN_APP"

    # Run Pwtfile teardown (if exists), then hook
    # (Pwtfile handles project-specific cleanup like databases)
    run_pwtfile "teardown"
    run_hook "pre-remove"

    # Clear current symlink if removing the current worktree
    local current_wt=$(get_current_from_symlink 2>/dev/null)
    if [ "$name" = "$current_wt" ]; then
        clear_current_symlink
        echo -e "  ${CYAN}Cleared current symlink${NC}"
    fi

    # Get workspace mode (clone or worktree)
    local workspace_mode=$(get_metadata "$name" "mode")
    workspace_mode="${workspace_mode:-worktree}"  # Default to worktree for backwards compatibility

    # SAFETY: Backup uncommitted changes before removing
    if [ "$has_changes" = true ] && [ -d "$worktree_dir" ]; then
        local backup_dir="$HOME/.pwt/trash"
        local timestamp=$(date +%Y%m%d_%H%M%S)
        local backup_name="${name}_${timestamp}"

        mkdir -p "$backup_dir"

        # Save metadata for restore (branch, base, port, etc.)
        local meta_branch=$(get_metadata "$name" "branch" 2>/dev/null || git -C "$worktree_dir" branch --show-current 2>/dev/null || echo "")
        local meta_base=$(get_metadata "$name" "base" 2>/dev/null || echo "")
        local meta_port=$(get_metadata "$name" "port" 2>/dev/null || echo "")
        local meta_desc=$(get_metadata "$name" "description" 2>/dev/null || echo "")
        local meta_project="$CURRENT_PROJECT"

        cat > "$backup_dir/${backup_name}.json" << EOF
{
  "worktree": "$name",
  "branch": "$meta_branch",
  "base": "$meta_base",
  "port": "$meta_port",
  "description": "$meta_desc",
  "project": "$meta_project",
  "timestamp": "$timestamp",
  "date": "$(date -r $(date +%s) '+%Y-%m-%d %H:%M:%S' 2>/dev/null || date '+%Y-%m-%d %H:%M:%S')"
}
EOF
        echo -e "  ${CYAN}✓ Metadata saved to ~/.pwt/trash/${backup_name}.json${NC}"

        # Try to stash tracked changes
        if git -C "$worktree_dir" stash push -m "pwt-backup-$timestamp" 2>/dev/null; then
            local stash_ref=$(git -C "$worktree_dir" stash list | head -1 | cut -d: -f1)
            if [ -n "$stash_ref" ]; then
                # Export stash to backup dir
                git -C "$worktree_dir" stash show -p "$stash_ref" > "$backup_dir/${backup_name}.patch" 2>/dev/null
                echo -e "  ${CYAN}✓ Tracked changes backed up to ~/.pwt/trash/${backup_name}.patch${NC}"
            fi
        fi

        # Backup untracked files
        local untracked_files=$(git -C "$worktree_dir" ls-files --others --exclude-standard 2>/dev/null)
        if [ -n "$untracked_files" ]; then
            local untracked_backup="$backup_dir/${backup_name}_untracked"
            mkdir -p "$untracked_backup"
            cd "$worktree_dir"
            echo "$untracked_files" | while read -r file; do
                if [ -f "$file" ]; then
                    local dir=$(dirname "$file")
                    mkdir -p "$untracked_backup/$dir"
                    cp "$file" "$untracked_backup/$file" 2>/dev/null
                fi
            done
            echo -e "  ${CYAN}✓ Untracked files backed up to ~/.pwt/trash/${backup_name}_untracked/${NC}"
        fi
    fi

    if [ "$workspace_mode" = "clone" ]; then
        rm -rf "$worktree_dir"
        echo -e "${GREEN}✓ Clone removed${NC}"
    else
        cd "$MAIN_APP"
        git worktree remove "$worktree_dir" --force
        echo -e "${GREEN}✓ Worktree removed${NC}"
    fi

    # Remove metadata
    remove_metadata "$name"
    clear_list_cache  # Invalidate cache so next list won't show removed worktree

    # Delete branch if requested
    if [ "$with_branch" = true ] && [ -n "$branch" ]; then
        # Validate branch exists (locally or remotely)
        local branch_exists=false
        if git rev-parse --verify "$branch" >/dev/null 2>&1; then
            branch_exists=true
        elif git rev-parse --verify "origin/$branch" >/dev/null 2>&1; then
            branch_exists=true
        fi

        if [ "$branch_exists" = false ]; then
            echo -e "${YELLOW}Branch '$branch' not found (local or remote)${NC}"
            return 0
        fi

        # Check if branch is merged (unless forcing)
        if [ "$force_branch" = false ]; then
            local target_branch="${DEFAULT_BRANCH:-master}"
            if ! git branch --merged "$target_branch" 2>/dev/null | grep -q "^[[:space:]]*${branch}$"; then
                echo -e "${YELLOW}Branch '$branch' is not merged into $target_branch. Use --force-branch to delete anyway.${NC}"
                return 0
            fi
        fi

        # Delete local branch
        if git rev-parse --verify "$branch" >/dev/null 2>&1; then
            if git branch -D "$branch" 2>/dev/null; then
                echo -e "${GREEN}✓ Local branch deleted: $branch${NC}"
            fi
        fi

        # Delete remote branch
        if git rev-parse --verify "origin/$branch" >/dev/null 2>&1; then
            if git push origin --delete "$branch" 2>/dev/null; then
                echo -e "${GREEN}✓ Remote branch deleted: origin/$branch${NC}"
            fi
        fi
    fi
}

# Command: server
# Start the server using Pwtfile's server() function
# Usage: cmd_server [worktree]
cmd_server() {
    # Handle --help before any processing
    if [ "${1:-}" = "-h" ] || [ "${1:-}" = "--help" ]; then
        echo "Usage: pwt server [worktree]"
        echo ""
        echo "Start development server for a worktree."
        echo ""
        echo "Arguments:"
        echo "  worktree        Worktree name (default: current worktree or symlink)"
        echo ""
        echo "Options:"
        echo "  -h, --help      Show this help"
        echo ""
        echo "Detection order:"
        echo "  1. Argument provided: pwt server ACME-1234-50XX"
        echo "  2. Inside worktree directory"
        echo "  3. Current symlink set via 'pwt use'"
        echo ""
        echo "Server runs on port from worktree metadata (usually 50XX)."
        return 0
    fi

    local arg="${1:-}"
    local current_dir=$(pwd)
    local worktree_name=""
    local worktree_path=""
    local via_symlink=false
    local via_argument=false

    # 0. Check if worktree name provided as argument
    if [ -n "$arg" ]; then
        worktree_path="$WORKTREES_DIR/$arg"
        # Try partial match if not found
        if [ ! -d "$worktree_path" ]; then
            local match=$(cmd_cd "$arg" 2>/dev/null)
            if [ -n "$match" ] && [ -d "$match" ]; then
                worktree_path="$match"
            fi
        fi
        if [ ! -d "$worktree_path" ]; then
            echo -e "${RED}Error: Worktree not found: $arg${NC}"
            exit 1
        fi
        worktree_name=$(basename "$worktree_path")
        via_argument=true
    # 1. Check if inside a worktree directly
    elif [[ "$current_dir" == "$WORKTREES_DIR"/* ]]; then
        worktree_name=$(basename "$current_dir")
        worktree_path="$current_dir"
    # 2. Check if current symlink is set
    elif worktree_name=$(get_current_from_symlink 2>/dev/null); then
        # @ = main (can't run server from main)
        if [ "$worktree_name" = "@" ]; then
            echo -e "${RED}Error: current points to main (@)${NC}"
            echo "Use: pwt use <worktree>  # switch to a worktree first"
            exit 1
        fi
        worktree_path="$WORKTREES_DIR/$worktree_name"
        via_symlink=true
    else
        echo -e "${RED}Error: Not inside a worktree and no current set${NC}"
        echo ""
        echo "Options:"
        echo "  pwt server <worktree>  # specify worktree"
        echo "  cd into a worktree directory"
        echo "  pwt use <worktree>  # set current first"
        exit 1
    fi

    local port=$(get_metadata "$worktree_name" "port")

    if [ -z "$port" ]; then
        echo -e "${YELLOW}Warning: Port not found in metadata${NC}"
        port="3000"
    fi

    # Warning if running via symlink
    if [ "$via_symlink" = true ]; then
        echo -e "${YELLOW}⚠️  Running server via symlink path${NC}"
        echo -e "${DIM}   → resolved to: $worktree_path${NC}"
        echo -e "${DIM}   Tip: Run from worktree path for better LSP/watcher support${NC}"
        echo ""
    fi

    # Set context for Pwtfile
    export PWT_WORKTREE="$worktree_name"
    export PWT_WORKTREE_PATH="$worktree_path"
    export PWT_PORT="$port"
    export PWT_PROJECT="$CURRENT_PROJECT"
    export MAIN_APP="$MAIN_APP"

    echo -e "${BLUE}Starting server on port $port...${NC}"

    # Actually cd to worktree path (for Pwtfile commands that use pwd)
    cd "$worktree_path" || exit 1

    # Run Pwtfile server phase
    run_pwtfile "server"
}

# Command: current
# Show current worktree info
# Works from ANYWHERE (uses symlink, not just pwd)
# Default output: SYMLINK path on stdout (pipe-friendly), context on stderr
# Use --resolved to get actual worktree path
# Usage: pwt current [--name|--port|--branch|--path|--resolved|--json]
cmd_current() {
    local format="default"
    local show_resolved=false

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --name) format="name"; shift ;;
            --port) format="port"; shift ;;
            --branch) format="branch"; shift ;;
            --path) format="path"; shift ;;
            --resolved) show_resolved=true; shift ;;
            --json) format="json"; shift ;;
            *) shift ;;
        esac
    done

    # Detect current worktree (priority: symlink > pwd)
    local current_dir=$(pwd)
    local name=""
    local is_main=false
    local from_symlink=false

    # 1. Try symlink first (works from anywhere)
    if name=$(get_current_from_symlink 2>/dev/null); then
        from_symlink=true
        # @ means symlink points to main
        [ "$name" = "@" ] && is_main=true
    # 2. Fall back to pwd detection
    elif [[ "$current_dir" == "$WORKTREES_DIR"/* ]]; then
        name=$(basename "$current_dir")
    elif [[ "$current_dir" == "$MAIN_APP"* ]]; then
        is_main=true
        name="@"
    # 3. If project was explicitly specified, default to main
    elif [ "$PROJECT_EXPLICIT" = true ] && [ -n "$MAIN_APP" ]; then
        is_main=true
        name="@"
    else
        # No symlink and not in a worktree
        if [ "$format" = "json" ]; then
            echo '{"in_worktree":false}'
        else
            echo -e "${YELLOW}Not in a worktree (and no current set)${NC}" >&2
            echo "Run 'pwt use <worktree>' to set current" >&2
        fi
        return 1
    fi

    # Get info
    local port=""
    local branch=""
    local resolved_path=""
    local symlink_path=$(get_current_symlink_path)
    local marker=""
    local desc=""

    if [ "$is_main" = true ]; then
        resolved_path="$MAIN_APP"
        branch=$(git -C "$MAIN_APP" branch --show-current 2>/dev/null || echo "main")
    else
        resolved_path="$WORKTREES_DIR/$name"
        port=$(get_metadata "$name" "port")
        marker=$(get_metadata "$name" "marker")
        desc=$(get_metadata "$name" "description")
        branch=$(git -C "$resolved_path" branch --show-current 2>/dev/null || echo "?")
    fi

    # Determine which path to output (symlink by default, resolved with --resolved)
    local output_path="$symlink_path"
    [ "$show_resolved" = true ] && output_path="$resolved_path"

    # Output based on format
    case "$format" in
        name)
            echo "$name"
            ;;
        port)
            echo "${port:-}"
            ;;
        branch)
            echo "$branch"
            ;;
        path)
            # --path respects --resolved flag
            echo "$output_path"
            ;;
        json)
            local json="{"
            json+="\"in_worktree\":true,"
            json+="\"name\":\"$name\","
            json+="\"branch\":\"$branch\","
            json+="\"symlink_path\":\"$symlink_path\","
            json+="\"resolved_path\":\"$resolved_path\""
            [ -n "$port" ] && json+=",\"port\":$port"
            [ -n "$marker" ] && json+=",\"marker\":\"$marker\""
            [ -n "$desc" ] && json+=",\"description\":\"$desc\""
            [ "$from_symlink" = true ] && json+=",\"from_symlink\":true"
            json+="}"
            echo "$json"
            ;;
        default)
            # stdout=symlink path (stable), stderr=context (Unix-style)
            # Use --resolved to get actual worktree path
            echo "$output_path"
            if [ "$is_main" = true ]; then
                echo -e "current@${BLUE}@${NC} (main) on ${GREEN}$branch${NC}" >&2
            else
                local status=$(get_status_symbols "$resolved_path")
                local port_str=""
                [ -n "$port" ] && port_str=":${port}"
                local status_str=""
                [ -n "$status" ] && status_str=" [${status}]"
                echo -e "current@${BLUE}$name${NC} $port_str$status_str on ${GREEN}$branch${NC}" >&2
            fi
            ;;
    esac
}

# Save last-used worktree for a project
save_last_used() {
    local name="$1"
    local project="${CURRENT_PROJECT:-unknown}"
    local last_file="$PWT_DIR/projects/$project/last"
    mkdir -p "$(dirname "$last_file")"
    echo "$name" > "$last_file"
}

# Get last-used worktree for a project
get_last_used() {
    local project="${CURRENT_PROJECT:-unknown}"
    local last_file="$PWT_DIR/projects/$project/last"
    if [ -f "$last_file" ]; then
        cat "$last_file"
    fi
}

# Save previous worktree for "pwt -" navigation (like cd -)
save_previous() {
    local name="$1"
    local project="${CURRENT_PROJECT:-unknown}"
    local prev_file="$PWT_DIR/projects/$project/previous"
    mkdir -p "$(dirname "$prev_file")"
    echo "$name" > "$prev_file"
}

# Get previous worktree for "pwt -" navigation
get_previous() {
    local project="${CURRENT_PROJECT:-unknown}"
    local prev_file="$PWT_DIR/projects/$project/previous"
    if [ -f "$prev_file" ]; then
        cat "$prev_file"
    fi
}

# ============================================
# Current Symlink Functions (Capistrano-style)
# ============================================

# Get symlink path for current project
get_current_symlink_path() {
    local project="${CURRENT_PROJECT:-unknown}"
    echo "$PROJECTS_DIR/$project/current"
}

# Read current worktree from symlink
# Returns "@" if pointing to MAIN_APP, otherwise worktree name
get_current_from_symlink() {
    local symlink_path=$(get_current_symlink_path)
    [ -L "$symlink_path" ] || return 1
    local target=$(readlink "$symlink_path" 2>/dev/null) || return 1
    [ -d "$target" ] || return 1

    # Check if pointing to main app
    if [ "$target" = "$MAIN_APP" ]; then
        echo "@"
    else
        basename "$target"
    fi
}

# Update symlink atomically
set_current_worktree() {
    local name="$1"
    local symlink_path=$(get_current_symlink_path)
    local target_path="$WORKTREES_DIR/$name"

    [ -d "$target_path" ] || { echo "Worktree not found: $name" >&2; return 1; }

    mkdir -p "$(dirname "$symlink_path")"
    ln -sfn "$target_path" "$symlink_path"
    save_last_used "$name"
}

# Clear current symlink
clear_current_symlink() {
    local symlink_path=$(get_current_symlink_path)
    rm -f "$symlink_path"
}

# ============================================
# Command: ps1
# ============================================
# Fast prompt helper - NO git, NO directory scanning
# Designed for shell prompts, status bars, tmux
# Usage: pwt ps1
#   Output: pwt@WORKTREE-NAME (or empty if no current)
#   Adds ! suffix if pwd differs from current (mismatch warning)
cmd_ps1() {
    # Fast path: read symlink directly
    local symlink_path="$PROJECTS_DIR/${CURRENT_PROJECT:-unknown}/current"

    # No symlink = no output
    [ -L "$symlink_path" ] || return 0

    local target=$(readlink "$symlink_path" 2>/dev/null) || return 0
    [ -d "$target" ] || return 0

    local name=$(basename "$target")

    # Check for mismatch: pwd is in a different worktree than current
    local mismatch=""
    local current_dir=$(pwd)
    if [ -d "$WORKTREES_DIR" ] && [[ "$current_dir" == "$WORKTREES_DIR"/* ]]; then
        local pwd_name=$(basename "$current_dir")
        if [ "$pwd_name" != "$name" ]; then
            mismatch="!"
        fi
    fi

    echo "pwt@${name}${mismatch}"
}

# ============================================
# Command: use
# ============================================
# Switch the current symlink to a different worktree
# Usage: pwt use <worktree>
#   Atomically swaps the symlink, does NOT:
#   - Open editor
#   - Kill processes
#   - Change shell directory
cmd_use() {
    local target="${1:-}"

    if [ -z "$target" ]; then
        echo -e "${RED}Usage: pwt use <worktree>${NC}" >&2
        echo "Switches the current symlink to point to the specified worktree" >&2
        exit 1
    fi

    # @ = main worktree (special case)
    if [ "$target" = "@" ]; then
        # Point symlink to main app (always have a current)
        local symlink_path=$(get_current_symlink_path)
        mkdir -p "$(dirname "$symlink_path")"
        ln -sfn "$MAIN_APP" "$symlink_path"
        save_last_used "@"
        local branch=$(git -C "$MAIN_APP" branch --show-current 2>/dev/null || echo "?")
        echo -e "current → ${BLUE}@ (main)${NC} (branch ${GREEN}$branch${NC})"
        return 0
    fi

    # Check if it's a worktree name (exact match)
    local worktree_path="$WORKTREES_DIR/$target"
    local resolved_name="$target"

    if [ ! -d "$worktree_path" ]; then
        # Try partial match by directory name
        local matches=()
        if [ -d "$WORKTREES_DIR" ]; then
            for dir in "$WORKTREES_DIR"/*/; do
                local name=$(basename "$dir")
                if [[ "$name" == *"$target"* ]]; then
                    matches+=("$name")
                fi
            done
        fi

        # If no directory match, try matching by branch name
        if [ ${#matches[@]} -eq 0 ] && [ -d "$WORKTREES_DIR" ]; then
            local normalized_target="${target//\//-}"  # feature/foo → feature-foo
            for dir in "$WORKTREES_DIR"/*/; do
                local name=$(basename "$dir")
                local branch=$(git -C "$dir" branch --show-current 2>/dev/null)
                if [[ -n "$branch" ]] && [[ "$branch" == *"$target"* || "$branch" == *"$normalized_target"* ]]; then
                    matches+=("$name")
                fi
            done
        fi

        if [ ${#matches[@]} -eq 1 ]; then
            resolved_name="${matches[0]}"
            worktree_path="$WORKTREES_DIR/$resolved_name"
        elif [ ${#matches[@]} -gt 1 ]; then
            echo -e "${RED}Multiple matches for '$target':${NC}" >&2
            for m in "${matches[@]}"; do
                echo "  $m" >&2
            done
            exit 1
        else
            # No worktree match - check if target matches main app's branch
            local main_branch=$(git -C "$MAIN_APP" branch --show-current 2>/dev/null)
            if [[ -n "$main_branch" && "$main_branch" == *"$target"* ]]; then
                # Target matches main app branch - use @
                local symlink_path=$(get_current_symlink_path)
                mkdir -p "$(dirname "$symlink_path")"
                ln -sfn "$MAIN_APP" "$symlink_path"
                save_last_used "@"
                echo -e "current → ${BLUE}@ (main)${NC} (branch ${GREEN}$main_branch${NC})"
                return 0
            fi
            echo -e "${RED}Worktree not found: $target${NC}" >&2
            exit 1
        fi
    fi

    # Swap symlink
    set_current_worktree "$resolved_name" || exit 1

    # Output context
    local port=$(get_metadata "$resolved_name" "port")
    local branch=$(git -C "$worktree_path" branch --show-current 2>/dev/null || echo "?")
    echo -e "current → ${BLUE}$resolved_name${NC} (branch ${GREEN}$branch${NC})"
    [ -n "$port" ] && echo -e "         port ${CYAN}:$port${NC}"
    return 0
}

# Command: info
cmd_info() {
    local name="$1"

    # If no name specified, try to detect from current directory
    if [ -z "$name" ]; then
        local current_dir=$(pwd)
        if [[ "$current_dir" == "$WORKTREES_DIR"/* ]]; then
            name=$(basename "$current_dir")
        else
            echo -e "${RED}Error: Worktree not specified${NC}"
            echo "Usage: pwt info <worktree>"
            echo "Or run from inside a worktree"
            exit 1
        fi
    fi

    local worktree_dir="$WORKTREES_DIR/$name"

    if [ ! -d "$worktree_dir" ]; then
        echo -e "${RED}Error: Worktree not found: $name${NC}"
        exit 1
    fi

    # Extract information
    local port=$(get_metadata "$name" "port")
    if [ -z "$port" ]; then
        # Legacy: extract from directory name if ends with -XXXX
        if [[ "$name" =~ -([0-9]{4})$ ]]; then
            port="${BASH_REMATCH[1]}"
        else
            port="-"
        fi
    fi
    local ticket="$name"
    local branch=$(git -C "$worktree_dir" branch --show-current 2>/dev/null || echo "detached")
    local upstream=$(git -C "$worktree_dir" rev-parse --abbrev-ref "${branch}@{upstream}" 2>/dev/null || echo "-")
    local commit=$(git -C "$worktree_dir" rev-parse --short HEAD 2>/dev/null || echo "-")
    local commit_msg=$(git -C "$worktree_dir" log -1 --format='%s' 2>/dev/null | head -c 50)

    # Server status (check port, not pidfile)
    local server_status="${YELLOW}stopped${NC}"
    if [ -n "$port" ] && [[ "$port" =~ ^[0-9]+$ ]]; then
        local pids=$(get_pids_on_port "$port")
        if [ -n "$pids" ]; then
            local first_pid=$(echo "$pids" | head -1)
            server_status="${GREEN}running${NC} (PID $first_pid)"
        fi
    fi

    # Commits ahead/behind
    local ahead_behind=""
    if [ "$upstream" != "-" ]; then
        local ahead=$(git -C "$worktree_dir" rev-list --count "${upstream}..${branch}" 2>/dev/null || echo "0")
        local behind=$(git -C "$worktree_dir" rev-list --count "${branch}..${upstream}" 2>/dev/null || echo "0")
        if [ "$ahead" -gt 0 ] || [ "$behind" -gt 0 ]; then
            ahead_behind=" (↑${ahead} ↓${behind})"
        fi
    fi

    # Output
    echo ""
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${YELLOW}$name${NC}"
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
    echo -e "  ${BLUE}Ticket:${NC}    $ticket"
    echo -e "  ${BLUE}Branch:${NC}    $branch"
    echo -e "  ${BLUE}Based on:${NC}  $upstream$ahead_behind"
    echo -e "  ${BLUE}Commit:${NC}    $commit - $commit_msg"
    echo ""
    echo -e "  ${BLUE}Port:${NC}      $port"
    echo -e "  ${BLUE}Server:${NC}    $server_status"
    echo -e "  ${BLUE}Directory:${NC} $worktree_dir"
    echo ""

    # Show modified files if any
    local modified=$(git -C "$worktree_dir" status --porcelain 2>/dev/null | wc -l | tr -d ' ')
    if [ "$modified" -gt 0 ]; then
        echo -e "  ${YELLOW}Modified files:${NC} $modified"
        git -C "$worktree_dir" status --porcelain 2>/dev/null | head -5 | sed 's/^/    /'
        if [ "$modified" -gt 5 ]; then
            echo "    ... and $((modified - 5)) more"
        fi
        echo ""
    fi
}

# Command: fix-port
# Reallocate a worktree to a new free port
cmd_fix_port() {
    local name="$1"

    # If no name specified, try to detect from current directory
    if [ -z "$name" ]; then
        local current_dir=$(pwd)
        if [[ "$current_dir" == "$WORKTREES_DIR"/* ]]; then
            name=$(basename "$current_dir")
        else
            echo -e "${RED}Error: Worktree name not specified${NC}"
            echo "Usage: pwt fix-port <worktree>"
            echo "Or run from inside a worktree"
            exit 1
        fi
    fi

    local worktree_dir="$WORKTREES_DIR/$name"

    if [ ! -d "$worktree_dir" ]; then
        echo -e "${RED}Error: Worktree not found: $name${NC}"
        exit 1
    fi

    # Get current port from metadata, fallback to directory name
    local old_port=$(get_metadata "$name" "port")
    if [ -z "$old_port" ]; then
        # Legacy: extract from directory name if ends with -XXXX
        if [[ "$name" =~ -([0-9]{4})$ ]]; then
            old_port="${BASH_REMATCH[1]}"
        fi
    fi

    if [ -z "$old_port" ] || ! [[ "$old_port" =~ ^[0-9]+$ ]]; then
        echo -e "${RED}Error: Could not find port for worktree: $name${NC}"
        echo "Check metadata with: pwt meta show $name"
        exit 1
    fi

    # Check if current port is actually occupied
    if is_port_pair_free "$old_port"; then
        echo -e "${GREEN}Port $old_port is already free!${NC}"
        echo "No changes needed."
        exit 0
    fi

    # Analyze what's occupying the port
    local pids=$(get_pids_on_port "$old_port")
    local procs_info=""

    if has_lsof && [ -n "$pids" ]; then
        for pid in $pids; do
            local proc=$(ps -p "$pid" -o comm= 2>/dev/null || echo "?")
            procs_info="${procs_info}  PID $pid: $proc\n"
        done
    fi

    echo -e "${YELLOW}Port $old_port is occupied:${NC}"
    if [ -n "$procs_info" ]; then
        echo -e "$procs_info"
    else
        echo "  (could not identify processes)"
    fi
    echo ""

    echo -e "${BLUE}Options:${NC}"
    echo "  1) Kill processes and keep port $old_port"
    echo "  2) Reallocate to new port"
    echo "  3) Cancel"
    echo ""
    read -p "Choose (1/2/3): " -n 1 -r choice
    echo ""

    case "$choice" in
        1)
            if [ -n "$pids" ]; then
                echo ""
                echo -e "${YELLOW}Killing processes...${NC}"
                for pid in $pids; do
                    kill -9 "$pid" 2>/dev/null && echo "  ✓ PID $pid killed"
                done
                sleep 1

                # Check if freed
                if is_port_free "$old_port"; then
                    echo ""
                    echo -e "${GREEN}✓ Port $old_port freed!${NC}"
                    echo ""
                    echo "Now you can start the server:"
                    echo -e "  ${BLUE}pwt server${NC}"
                    exit 0
                else
                    echo -e "${RED}Port still occupied. Reallocating...${NC}"
                fi
            else
                echo "No processes found to kill."
            fi
            ;;
        2)
            echo ""
            echo "Reallocating to new port..."
            ;;
        *)
            echo "Cancelled."
            exit 0
            ;;
    esac

    # Find new port
    local new_port=$(next_available_port)

    echo -e "${BLUE}Reallocating to port $new_port...${NC}"
    echo "  Port: $old_port → $new_port"
    echo ""

    # Update metadata (use JSON for numeric port)
    update_metadata_json "$name" "port" "$new_port"
    echo -e "  ${GREEN}✓${NC} Metadata updated"

    # Set context for hook (project can update configs via hook)
    export PWT_OLD_PORT="$old_port"
    export PWT_PORT="$new_port"
    export PWT_WORKTREE="$name"
    export PWT_WORKTREE_PATH="$worktree_dir"
    export PWT_PROJECT="$CURRENT_PROJECT"
    export MAIN_APP="$MAIN_APP"

    # Run project hook (for config updates like .env, databases, etc.)
    run_hook "post-fix-port"

    echo ""
    echo -e "${GREEN}✓ Port reallocated successfully!${NC}"
    echo ""
    echo "To start server:"
    echo -e "  ${BLUE}pwt server${NC}  # Starts on port $new_port"
}

# Command: meta
# View or edit worktree metadata
cmd_meta() {
    local action="$1"
    local name="$2"
    local field="$3"
    local value="$4"

    init_metadata

    local project="${CURRENT_PROJECT:-unknown}"

    case "$action" in
        ""|list)
            # List all metadata for current project (key=value format)
            echo -e "${BLUE}Worktree Metadata ($project):${NC}"
            echo ""
            jq -r --arg project "$project" '
              .[$project] // {} | to_entries[] |
              "\(.key):",
              "  path=\(.value.path // "")",
              "  branch=\(.value.branch // "")",
              "  base=\(.value.base // "")@\(.value.base_commit // "")",
              "  port=\(.value.port // "")",
              "  description=\(.value.description // "")",
              "  created=\(.value.created_at // "")",
              ""
            ' "$METADATA_FILE"
            ;;
        show)
            if [ -z "$name" ]; then
                echo -e "${RED}Error: Worktree name required${NC}"
                echo "Usage: pwt meta show <worktree>"
                exit 1
            fi
            local meta=$(jq --arg project "$project" --arg name "$name" '.[$project][$name]' "$METADATA_FILE")
            if [ "$meta" = "null" ]; then
                echo -e "${YELLOW}No metadata found for: $name${NC}"
            else
                echo -e "${BLUE}Metadata for $name:${NC}"
                echo "$meta" | jq '.'
            fi
            ;;
        set)
            if [ -z "$name" ] || [ -z "$field" ] || [ -z "$value" ]; then
                echo -e "${RED}Error: Missing arguments${NC}"
                echo "Usage: pwt meta set <worktree> <field> <value>"
                echo ""
                echo "Fields: base, description, branch"
                exit 1
            fi
            update_metadata "$name" "$field" "$value"
            echo -e "${GREEN}✓ Updated $name.$field = $value${NC}"
            clear_list_cache  # Invalidate cache so next list shows updated metadata
            ;;
        -h|--help|help)
            echo "Usage: pwt meta [command] [args]"
            echo ""
            echo "Manage worktree metadata."
            echo ""
            echo "Commands:"
            echo "  list                           List all worktree metadata (default)"
            echo "  show <worktree>                Show metadata for a worktree"
            echo "  set <worktree> <field> <value> Update a metadata field"
            echo "  import                         Import metadata for existing worktrees"
            echo ""
            echo "Fields: branch, base, description, port"
            echo ""
            echo "Options:"
            echo "  -h, --help, help    Show this help"
            return 0
            ;;
        import)
            # Import metadata for existing worktrees
            echo -e "${BLUE}Importing metadata for existing worktrees...${NC}"
            if [ -d "$WORKTREES_DIR" ] && [ "$(ls -A "$WORKTREES_DIR" 2>/dev/null)" ]; then
                for dir in "$WORKTREES_DIR"/*/; do
                    [ -d "$dir" ] || continue
                    local wt_name=$(basename "$dir")
                    local existing=$(get_metadata "$wt_name" "path")
                    if [ -z "$existing" ]; then
                        local wt_branch=$(git -C "$dir" branch --show-current 2>/dev/null || echo "?")
                        # Try to extract port from directory name (legacy format)
                        local wt_port=""
                        if [[ "$wt_name" =~ -([0-9]{4})$ ]]; then
                            wt_port="${BASH_REMATCH[1]}"
                        else
                            # Allocate new port for new format directories
                            wt_port=$(next_available_port)
                        fi
                        local wt_base_commit=$(git -C "$dir" merge-base HEAD "origin/${DEFAULT_BRANCH:-master}" 2>/dev/null)
                        local wt_base_short=$(git -C "$dir" rev-parse --short "$wt_base_commit" 2>/dev/null || echo "?")
                        local wt_desc=$(echo "$wt_branch" | sed -E 's|^[a-z]+/||' | tr '-' ' ')

                        save_metadata "$wt_name" "$dir" "$wt_branch" "${DEFAULT_BRANCH:-master}" "$wt_base_short" "$wt_port" "$wt_desc"
                        echo -e "  ${GREEN}✓${NC} Imported: $wt_name (port $wt_port)"
                    else
                        echo -e "  ${YELLOW}○${NC} Exists: $wt_name"
                    fi
                done
            fi
            echo -e "${GREEN}Done!${NC}"
            ;;
        *)
            echo -e "${RED}Unknown action: $action${NC}"
            echo "Usage: pwt meta [list|show|set|import]"
            echo ""
            echo "Commands:"
            echo "  list              - List all worktree metadata"
            echo "  show <name>       - Show metadata for a worktree"
            echo "  set <name> <field> <value> - Update a metadata field"
            echo "  import            - Import metadata for existing worktrees"
            exit 1
            ;;
    esac
}

# Command: alias
# Get/set/clear project alias (auto-detects current project)
# Usage: pwt alias [<alias>|--clear]
cmd_alias() {
    local new_alias="${1:-}"
    local config_file="$PROJECTS_DIR/$CURRENT_PROJECT/config.json"

    if [ ! -f "$config_file" ]; then
        echo -e "${RED}Project config not found: $CURRENT_PROJECT${NC}"
        exit 1
    fi

    if [ -z "$new_alias" ]; then
        # Show current project and alias
        local current=$(jq -r '.alias // empty' "$config_file")
        if [ -n "$current" ]; then
            echo -e "${GREEN}$CURRENT_PROJECT${NC} → ${CYAN}$current${NC}"
        else
            echo -e "${GREEN}$CURRENT_PROJECT${NC} (no alias)"
        fi
    elif [ "$new_alias" = "--clear" ]; then
        # Clear alias
        local tmp_file
        tmp_file="$(mktemp "${config_file}.tmp.XXXXXX")"
        jq 'del(.alias)' "$config_file" > "$tmp_file" && mv "$tmp_file" "$config_file"
        echo -e "${GREEN}✓ Cleared alias for $CURRENT_PROJECT${NC}"
    else
        # Set alias - validate first
        local reserved_commands="list create remove cd server test meta port project help version config init show set path alias"
        for cmd in $reserved_commands; do
            if [ "$new_alias" = "$cmd" ]; then
                echo -e "${RED}Error: '$new_alias' is a reserved command name${NC}"
                exit 1
            fi
        done
        # Check if alias conflicts with existing project name
        if [ -f "$PROJECTS_DIR/$new_alias/config.json" ]; then
            echo -e "${RED}Error: '$new_alias' is already a project name${NC}"
            exit 1
        fi
        # Check if alias already used by another project
        for cfg in "$PROJECTS_DIR"/*/config.json; do
            [ -f "$cfg" ] || continue
            local proj_dir=$(dirname "$cfg")
            local proj_name=$(basename "$proj_dir")
            [ "$proj_name" = "$CURRENT_PROJECT" ] && continue
            local other_alias=$(jq -r '.alias // empty' "$cfg")
            if [ "$other_alias" = "$new_alias" ]; then
                echo -e "${RED}Error: Alias '$new_alias' already used by project '$proj_name'${NC}"
                exit 1
            fi
        done
        # Set alias
        local tmp_file
        tmp_file="$(mktemp "${config_file}.tmp.XXXXXX")"
        jq --arg alias "$new_alias" '.alias = $alias' "$config_file" > "$tmp_file" && mv "$tmp_file" "$config_file"
        echo -e "${GREEN}✓ $CURRENT_PROJECT${NC} → ${CYAN}$new_alias${NC}"
    fi
}

# Command: cd (internal)
# Output path for worktree navigation
# Usage: pwt _cd [worktree|@|-]
#   @ or empty = main worktree
#   - = previous worktree (like cd -)
#   worktree = specific worktree
cmd_cd() {
    local target="${1:-}"

    # No target: try last-used, fallback to main
    if [ -z "$target" ]; then
        local last=$(get_last_used)
        if [ -n "$last" ] && [ -d "$WORKTREES_DIR/$last" ]; then
            target="$last"
        else
            target="@"
        fi
    fi

    # - = previous worktree (like cd -)
    if [ "$target" = "-" ]; then
        local prev=$(get_previous)
        if [ -z "$prev" ]; then
            echo "No previous worktree" >&2
            return 1
        fi
        target="$prev"
        # Show where we're going (like cd - does)
        if [ "$target" = "@" ]; then
            echo -e "${DIM}~${NC}" >&2
        else
            echo -e "${DIM}$target${NC}" >&2
        fi
    fi

    # Helper to save navigation history
    _save_navigation() {
        local new_target="$1"
        local current=$(get_last_used)
        # Save current as previous (for pwt -)
        if [ -n "$current" ] && [ "$current" != "$new_target" ]; then
            save_previous "$current"
        fi
        save_last_used "$new_target"
    }

    # @ = main worktree
    if [ "$target" = "@" ]; then
        _save_navigation "@"
        echo "$MAIN_APP"
        return 0
    fi

    # current = symlink path (stable path for editors)
    if [ "$target" = "current" ]; then
        local symlink_path=$(get_current_symlink_path)
        if [ -L "$symlink_path" ]; then
            echo "$symlink_path"
            return 0
        else
            echo "No current worktree set. Run 'pwt use <worktree>' first." >&2
            return 1
        fi
    fi

    # Check if it's a worktree name
    local worktree_path="$WORKTREES_DIR/$target"
    if [ -d "$worktree_path" ]; then
        _save_navigation "$target"
        echo "$worktree_path"
        return 0
    fi

    # Try partial match
    local matches=()
    if [ -d "$WORKTREES_DIR" ]; then
        for dir in "$WORKTREES_DIR"/*/; do
            local name=$(basename "$dir")
            if [[ "$name" == *"$target"* ]]; then
                matches+=("$dir")
            fi
        done
    fi

    if [ ${#matches[@]} -eq 1 ]; then
        local matched_name=$(basename "${matches[0]%/}")
        _save_navigation "$matched_name"
        echo "${matches[0]%/}"
        return 0
    elif [ ${#matches[@]} -gt 1 ]; then
        echo "Multiple matches for '$target':" >&2
        for m in "${matches[@]}"; do
            echo "  $(basename "${m%/}")" >&2
        done
        return 1
    fi

    echo "Worktree not found: $target" >&2
    return 1
}

# Resolve worktree path without side effects (no navigation history)
# Usage: resolve_worktree_path <target>
#   @ = main worktree
#   - = previous worktree
#   name = exact or fuzzy match
# Returns: path on stdout, or empty string on failure
resolve_worktree_path() {
    local target="$1"

    # @ = main worktree
    if [ "$target" = "@" ]; then
        echo "$MAIN_APP"
        return 0
    fi

    # - = previous worktree
    if [ "$target" = "-" ]; then
        local prev=$(get_previous)
        if [ -z "$prev" ]; then
            return 1
        fi
        if [ "$prev" = "@" ]; then
            echo "$MAIN_APP"
        else
            echo "$WORKTREES_DIR/$prev"
        fi
        return 0
    fi

    # Exact match
    if [ -d "$WORKTREES_DIR/$target" ]; then
        echo "$WORKTREES_DIR/$target"
        return 0
    fi

    # Fuzzy match (contains)
    local matches=()
    if [ -d "$WORKTREES_DIR" ]; then
        for dir in "$WORKTREES_DIR"/*/; do
            [ -d "$dir" ] || continue
            local name=$(basename "$dir")
            if [[ "$name" == *"$target"* ]]; then
                matches+=("${dir%/}")
            fi
        done
    fi

    if [ ${#matches[@]} -eq 1 ]; then
        echo "${matches[0]}"
        return 0
    fi

    return 1
}

# Command: run
# Run a command in a worktree without changing directory
# Usage: pwt run <worktree> <command...>
#   @ = main worktree
cmd_run() {
    local target="$1"
    shift

    if [ -z "$target" ]; then
        echo -e "${RED}Usage: pwt run <worktree> <command...>${NC}"
        exit 1
    fi

    if [ $# -eq 0 ]; then
        echo -e "${RED}No command specified${NC}"
        exit 1
    fi

    local worktree_path

    if [ "$target" = "@" ]; then
        worktree_path="$MAIN_APP"
    else
        worktree_path="$WORKTREES_DIR/$target"
        # Try partial match if not found
        if [ ! -d "$worktree_path" ]; then
            local match=$(cmd_cd "$target" 2>/dev/null)
            if [ -n "$match" ] && [ -d "$match" ]; then
                worktree_path="$match"
            fi
        fi
    fi

    if [ ! -d "$worktree_path" ]; then
        echo -e "${RED}Worktree not found: $target${NC}"
        exit 1
    fi

    echo -e "${BLUE}Running in $worktree_path:${NC} $*"
    (cd "$worktree_path" && "$@")
}

# Command: shell
# Start an interactive subshell in a worktree with PWT context
# Usage: pwt shell <worktree>
#   @ = main worktree
#   - = previous worktree
cmd_shell() {
    local target="${1:-}"

    if [ -z "$target" ]; then
        echo "Usage: pwt shell <worktree>"
        echo "       pwt shell @              # main app"
        echo "       pwt shell ACME-17744  # specific worktree"
        echo "       pwt shell 17744          # fuzzy match"
        return 1
    fi

    # Resolve worktree path (use || true to prevent set -e from exiting on not found)
    local wt_path
    wt_path=$(resolve_worktree_path "$target") || true

    if [ -z "$wt_path" ] || [ ! -d "$wt_path" ]; then
        echo -e "${RED}Worktree not found: $target${NC}"
        return 1
    fi

    # Set up context
    export PWT_WORKTREE="$target"
    export PWT_WORKTREE_PATH="$wt_path"
    export PWT_PROJECT="$CURRENT_PROJECT"

    # Extract port if worktree
    if [ "$target" != "@" ] && [[ "$wt_path" == *"$WORKTREES_DIR"* ]]; then
        local wt_name=$(basename "$wt_path")
        export PWT_PORT=$(echo "$wt_name" | grep -oE '[0-9]+$' || true)
        export PWT_BRANCH=$(get_metadata "$wt_name" "branch" 2>/dev/null || git -C "$wt_path" branch --show-current 2>/dev/null || echo "")
    else
        export PWT_PORT=""
        export PWT_BRANCH=$(git -C "$wt_path" branch --show-current 2>/dev/null || echo "master")
    fi

    # Custom prompt
    local wt_display="$target"
    [ "$target" = "@" ] && wt_display="main"

    export PWT_SHELL_PS1="[pwt:${CURRENT_PROJECT}@${wt_display}]\$ "

    # Mark as pwt subshell (user can detect in .zshrc)
    export PWT_SHELL=1

    # Print banner
    local banner_text="pwt subshell: ${CURRENT_PROJECT} @ ${wt_display}"
    local exit_hint="Ctrl+D or 'exit' to return"
    local banner_len=${#banner_text}
    local exit_len=${#exit_hint}
    local content_width=$((banner_len > exit_len ? banner_len : exit_len))
    local box_width=$((content_width + 4))
    local border=$(printf '─%.0s' $(seq 1 $((box_width - 2))))

    echo ""
    echo -e "${BLUE}┌${border}┐${NC}"
    printf "${BLUE}│${NC}  %-${content_width}s  ${BLUE}│${NC}\n" "$banner_text"
    printf "${BLUE}│${NC}  ${DIM}%-${content_width}s${NC}  ${BLUE}│${NC}\n" "$exit_hint"
    echo -e "${BLUE}└${border}┘${NC}"
    echo ""

    # Start subshell
    (cd "$wt_path" && PWT_SHELL=1 exec "${SHELL:-/bin/bash}")

    echo -e "${GREEN}Exited pwt shell${NC}"
}

# Command: exec
# Run multiple commands in a worktree, separated by --
# Usage: pwt <project> <worktree> -- cmd1 [-- cmd2 ...]
# Commands run in sequence; stops on first failure (like &&)
cmd_exec() {
    local target="${1:-}"
    shift

    if [ -z "$target" ]; then
        echo "Usage: pwt <project> <worktree> -- cmd1 [-- cmd2 ...]"
        return 1
    fi

    # Skip the first -- (already consumed)
    if [ "${1:-}" = "--" ]; then
        shift
    fi

    # Resolve worktree (use || true to prevent set -e from exiting on not found)
    local wt_path
    wt_path=$(resolve_worktree_path "$target") || true

    if [ -z "$wt_path" ] || [ ! -d "$wt_path" ]; then
        echo -e "${RED}Worktree not found: $target${NC}"
        return 1
    fi

    # Parse commands (split by --)
    local commands=()
    local current_cmd=""

    for arg in "$@"; do
        if [ "$arg" = "--" ]; then
            [ -n "$current_cmd" ] && commands+=("$current_cmd")
            current_cmd=""
        else
            current_cmd="${current_cmd:+$current_cmd }$arg"
        fi
    done
    [ -n "$current_cmd" ] && commands+=("$current_cmd")

    if [ ${#commands[@]} -eq 0 ]; then
        echo -e "${RED}No commands specified${NC}"
        return 1
    fi

    # Set up context
    export PWT_WORKTREE="$target"
    export PWT_WORKTREE_PATH="$wt_path"
    export PWT_PROJECT="$CURRENT_PROJECT"

    # Extract port if worktree
    if [ "$target" != "@" ] && [[ "$wt_path" == *"$WORKTREES_DIR"* ]]; then
        local wt_name=$(basename "$wt_path")
        export PWT_PORT=$(echo "$wt_name" | grep -oE '[0-9]+$' || true)
    else
        export PWT_PORT=""
    fi

    # Execute commands
    cd "$wt_path" || return 1

    for cmd in "${commands[@]}"; do
        echo -e "${BLUE}→ $cmd${NC}"
        eval "$cmd"
        local status=$?
        if [ $status -ne 0 ]; then
            echo -e "${RED}Command failed with status $status${NC}"
            return $status
        fi
    done
}

# Command: restore
# Recover backed up changes from ~/.pwt/trash/
# Backups are created automatically when removing dirty worktrees
# Usage:
#   pwt restore                       # List available backups
#   pwt restore <backup>              # Auto-create worktree and restore
#   pwt restore <backup> <worktree>   # Apply to existing worktree
cmd_restore() {
    local TRASH_DIR="$HOME/.pwt/trash"
    local first_arg="${1:-}"

    # Handle help first (doesn't need trash directory)
    case "$first_arg" in
        help|--help|-h)
            echo "Usage: pwt [project] restore [backup] [worktree]"
            echo ""
            echo "  pwt restore                   List available backups"
            echo "  pwt restore <backup>          Recreate worktree and apply backup"
            echo "  pwt restore <backup> <wt>     Apply backup to existing worktree"
            echo ""
            echo "Backups are created automatically when removing dirty worktrees."
            echo "Location: ~/.pwt/trash/"
            return 0
            ;;
    esac

    # Ensure trash directory exists
    if [ ! -d "$TRASH_DIR" ]; then
        echo -e "${YELLOW}No backups found.${NC}"
        echo "Backups are created when removing worktrees with uncommitted changes."
        return 0
    fi

    # No argument = list backups
    if [ -z "$first_arg" ]; then
        _restore_list
        return $?
    fi

    # Argument provided = treat as backup name (exact or fuzzy match)
    local backup_name=""

    # Try exact match first
    if [ -f "$TRASH_DIR/${first_arg}.json" ] || [ -f "$TRASH_DIR/${first_arg}.patch" ]; then
        backup_name="$first_arg"
    else
        # Try fuzzy match by worktree name prefix (most recent)
        local matching=$(find "$TRASH_DIR" -maxdepth 1 -name "${first_arg}*.json" -print0 2>/dev/null | \
            xargs -0 ls -t 2>/dev/null | head -1)

        if [ -n "$matching" ]; then
            backup_name=$(basename "$matching" .json)
            echo -e "${DIM}Found: $backup_name${NC}"
        fi
    fi

    if [ -z "$backup_name" ]; then
        echo -e "${RED}Backup not found: $first_arg${NC}"
        echo "Use 'pwt restore' to see available backups."
        return 1
    fi

    local target_worktree="${2:-}"
    _restore_backup "$backup_name" "$target_worktree"
}

# Helper: list available backups
_restore_list() {
    local TRASH_DIR="$HOME/.pwt/trash"

    echo -e "${BLUE}Available backups:${NC}"
    echo ""

    local found=false
    local json_files=()

    # Collect JSON metadata files (newest first)
    while IFS= read -r -d '' file; do
        json_files+=("$file")
        found=true
    done < <(find "$TRASH_DIR" -maxdepth 1 -name "*.json" -print0 2>/dev/null | sort -z -r)

    if [ "$found" = false ]; then
        # Fall back to patch files without JSON (legacy)
        local patches=()
        while IFS= read -r -d '' file; do
            patches+=("$file")
            found=true
        done < <(find "$TRASH_DIR" -maxdepth 1 -name "*.patch" -print0 2>/dev/null | sort -z -r)

        if [ "$found" = false ]; then
            echo -e "${YELLOW}No backups found.${NC}"
            return 0
        fi

        for patch in "${patches[@]}"; do
            local basename=$(basename "$patch" .patch)
            local wt_name=$(echo "$basename" | sed -E 's/_[0-9]{8}_[0-9]{6}$//')
            echo -e "  ${GREEN}$basename${NC} ${DIM}(legacy)${NC}"
            echo -e "     Worktree: ${CYAN}$wt_name${NC}"
            echo ""
        done
    else
        for json_file in "${json_files[@]}"; do
            local basename=$(basename "$json_file" .json)
            local wt_name=$(jq -r '.worktree // empty' "$json_file" 2>/dev/null)
            local branch=$(jq -r '.branch // empty' "$json_file" 2>/dev/null)
            local date=$(jq -r '.date // empty' "$json_file" 2>/dev/null)

            # Check what backup files exist
            local has_patch=false
            local has_untracked=false
            [ -f "$TRASH_DIR/${basename}.patch" ] && has_patch=true
            [ -d "$TRASH_DIR/${basename}_untracked" ] && has_untracked=true

            local contents=""
            [ "$has_patch" = true ] && contents="patch"
            [ "$has_untracked" = true ] && contents="${contents:+$contents+}untracked"

            echo -e "  ${GREEN}$wt_name${NC}  ${DIM}$date${NC}  ${YELLOW}[$contents]${NC}"
            [ -n "$branch" ] && echo -e "     Branch: ${CYAN}$branch${NC}"
            echo ""
        done
    fi

    echo -e "${DIM}Usage: pwt restore <worktree-name> [target-worktree]${NC}"
}

# Helper: restore a backup to a worktree
# Usage: _restore_backup <backup_name> [target_worktree]
#   If target_worktree is empty, auto-creates from backup metadata
_restore_backup() {
    local backup_name="$1"
    local target_worktree="$2"
    local TRASH_DIR="$HOME/.pwt/trash"

    local json_file="$TRASH_DIR/${backup_name}.json"
    local patch_file="$TRASH_DIR/${backup_name}.patch"
    local untracked_dir="$TRASH_DIR/${backup_name}_untracked"

    # Check backup exists
    if [ ! -f "$json_file" ] && [ ! -f "$patch_file" ] && [ ! -d "$untracked_dir" ]; then
        echo -e "${RED}Backup not found: $backup_name${NC}"
        return 1
    fi

    local target_dir=""

    # If target worktree specified, resolve it
    if [ -n "$target_worktree" ]; then
        target_dir=$(resolve_worktree_path "$target_worktree") || true
        if [ -z "$target_dir" ] || [ ! -d "$target_dir" ]; then
            echo -e "${RED}Worktree not found: $target_worktree${NC}"
            return 1
        fi
        echo -e "${BLUE}Restoring to existing worktree: $target_worktree${NC}"
    else
        # Auto-create worktree from metadata
        if [ ! -f "$json_file" ]; then
            echo -e "${RED}Cannot auto-create worktree: no metadata (legacy backup)${NC}"
            echo "Specify target worktree: pwt restore $backup_name <worktree>"
            return 1
        fi

        local branch=$(jq -r '.branch // empty' "$json_file" 2>/dev/null)
        local base=$(jq -r '.base // empty' "$json_file" 2>/dev/null)
        local desc=$(jq -r '.description // empty' "$json_file" 2>/dev/null)

        if [ -z "$branch" ]; then
            echo -e "${RED}Cannot auto-create worktree: no branch in metadata${NC}"
            echo "Specify target worktree: pwt restore $backup_name <worktree>"
            return 1
        fi

        echo -e "${BLUE}Creating worktree from backup metadata...${NC}"
        echo -e "  Branch: ${YELLOW}$branch${NC}"
        echo -e "  Base:   ${base:-master}"
        echo ""

        # Create the worktree using cmd_create
        # Pass description if available
        if [ -n "$desc" ]; then
            cmd_create "$branch" "${base:-master}" "$desc"
        else
            cmd_create "$branch" "${base:-master}"
        fi

        local create_status=$?
        if [ $create_status -ne 0 ]; then
            echo -e "${RED}Failed to create worktree${NC}"
            return 1
        fi

        # Find the newly created worktree
        target_dir=$(resolve_worktree_path "$branch") || true
        if [ -z "$target_dir" ] || [ ! -d "$target_dir" ]; then
            echo -e "${RED}Could not find created worktree${NC}"
            return 1
        fi

        echo ""
    fi

    local restored_something=false

    # Apply patch if exists
    if [ -f "$patch_file" ]; then
        echo -e "${BLUE}Applying patch...${NC}"

        if git -C "$target_dir" apply --check "$patch_file" 2>/dev/null; then
            if git -C "$target_dir" apply "$patch_file"; then
                echo -e "${GREEN}✓ Patch applied successfully${NC}"
                restored_something=true
            else
                echo -e "${RED}Failed to apply patch${NC}"
                echo -e "${YELLOW}Manual: git apply $patch_file${NC}"
            fi
        else
            echo -e "${YELLOW}⚠️  Patch cannot be applied cleanly${NC}"
            echo "Options:"
            echo "  git apply --3way $patch_file"
            echo "  git apply --reject $patch_file"
        fi
    fi

    # Copy untracked files if exist
    if [ -d "$untracked_dir" ]; then
        echo -e "${BLUE}Restoring untracked files...${NC}"

        find "$untracked_dir" -type f | while read -r file; do
            local rel_path="${file#$untracked_dir/}"
            local dest_file="$target_dir/$rel_path"
            local dest_dir=$(dirname "$dest_file")

            mkdir -p "$dest_dir"

            if [ -f "$dest_file" ]; then
                echo -e "  ${YELLOW}⚠️  Skip (exists): $rel_path${NC}"
            else
                cp "$file" "$dest_file"
                echo -e "  ${GREEN}✓ $rel_path${NC}"
            fi
        done

        restored_something=true
    fi

    if [ "$restored_something" = true ]; then
        echo ""
        echo -e "${GREEN}✓ Restore complete!${NC}"
        echo -e "${DIM}Worktree: $target_dir${NC}"
    fi
}

# Command: editor
# Open worktree in configured editor
# Usage: pwt editor [worktree]
#   If no worktree specified, uses current directory or main app
cmd_editor() {
    local target="${1:-}"
    local worktree_path

    # Get editor from config or default to cursor
    local editor_cmd
    editor_cmd=$(get_project_config "$CURRENT_PROJECT" "editor" 2>/dev/null)
    [ -z "$editor_cmd" ] && editor_cmd="${EDITOR:-cursor}"

    if [ -z "$target" ] || [ "$target" = "@" ]; then
        worktree_path="$MAIN_APP"
    else
        worktree_path=$(cmd_cd "$target" 2>/dev/null)
        if [ -z "$worktree_path" ] || [ ! -d "$worktree_path" ]; then
            echo -e "${RED}Worktree not found: $target${NC}"
            exit 1
        fi
    fi

    echo -e "${BLUE}Opening in $editor_cmd:${NC} $worktree_path"
    "$editor_cmd" "$worktree_path"
}

# Command: ai
# Start AI coding tool in worktree
# Usage: pwt ai [worktree] [-- args...]
cmd_ai() {
    local target="${1:-}"
    local worktree_path
    local ai_args=()

    # Shift past target if provided and not --
    if [ -n "$target" ] && [ "$target" != "--" ]; then
        shift
    else
        target=""
    fi

    # Collect args after --
    if [ "$1" = "--" ]; then
        shift
        ai_args=("$@")
    fi

    # Get AI tool from config or default to claude
    local ai_cmd
    ai_cmd=$(get_project_config "$CURRENT_PROJECT" "ai" 2>/dev/null)
    [ -z "$ai_cmd" ] && ai_cmd="claude"

    if [ -z "$target" ] || [ "$target" = "@" ]; then
        worktree_path="$MAIN_APP"
    else
        worktree_path=$(cmd_cd "$target" 2>/dev/null)
        if [ -z "$worktree_path" ] || [ ! -d "$worktree_path" ]; then
            echo -e "${RED}Worktree not found: $target${NC}"
            exit 1
        fi
    fi

    echo -e "${BLUE}Starting $ai_cmd in:${NC} $worktree_path"
    (cd "$worktree_path" && "$ai_cmd" "${ai_args[@]}")
}

# Command: open
# Open worktree in Finder/file manager
# Usage: pwt open [worktree]
cmd_open() {
    local target="${1:-}"
    local worktree_path

    if [ -z "$target" ] || [ "$target" = "@" ]; then
        worktree_path="$MAIN_APP"
    else
        worktree_path=$(cmd_cd "$target" 2>/dev/null)
        if [ -z "$worktree_path" ] || [ ! -d "$worktree_path" ]; then
            echo -e "${RED}Worktree not found: $target${NC}"
            exit 1
        fi
    fi

    echo -e "${BLUE}Opening in Finder:${NC} $worktree_path"
    open "$worktree_path"
}

# Command: diff
# Show diff between worktrees or worktree vs main
# Usage: pwt diff <worktree1> [worktree2]
cmd_diff() {
    local wt1="$1"
    local wt2="${2:-@}"

    if [ -z "$wt1" ]; then
        echo -e "${RED}Usage: pwt diff <worktree1> [worktree2]${NC}"
        echo "  worktree2 defaults to @ (main app)"
        exit 1
    fi

    local path1 path2

    # Resolve worktree1
    if [ "$wt1" = "@" ]; then
        path1="$MAIN_APP"
    else
        path1=$(cmd_cd "$wt1" 2>/dev/null)
        if [ -z "$path1" ] || [ ! -d "$path1" ]; then
            echo -e "${RED}Worktree not found: $wt1${NC}"
            exit 1
        fi
    fi

    # Resolve worktree2
    if [ "$wt2" = "@" ]; then
        path2="$MAIN_APP"
    else
        path2=$(cmd_cd "$wt2" 2>/dev/null)
        if [ -z "$path2" ] || [ ! -d "$path2" ]; then
            echo -e "${RED}Worktree not found: $wt2${NC}"
            exit 1
        fi
    fi

    echo -e "${BLUE}Comparing:${NC}"
    echo "  $wt1: $path1"
    echo "  $wt2: $path2"
    echo ""

    # Get branch and commit info
    local branch1=$(git -C "$path1" branch --show-current 2>/dev/null || echo "detached")
    local branch2=$(git -C "$path2" branch --show-current 2>/dev/null || echo "detached")
    local commit1=$(git -C "$path1" rev-parse HEAD 2>/dev/null)
    local commit2=$(git -C "$path2" rev-parse HEAD 2>/dev/null)

    if [ -z "$commit1" ] || [ -z "$commit2" ]; then
        echo -e "${RED}Error: Could not get commit hashes${NC}"
        exit 1
    fi

    echo -e "${BLUE}Branches:${NC} $branch1 vs $branch2"
    echo -e "${BLUE}Commits:${NC} ${commit1:0:8} vs ${commit2:0:8}"
    echo ""

    # Show git diff using commit hashes (works across worktrees via main repo)
    git -C "$MAIN_APP" diff "$commit2".."$commit1" --stat
}

# Command: conflicts
# Show file overlap between worktrees (files modified in multiple worktrees)
# Usage: pwt conflicts [worktree1] [worktree2]
#   No args: show all overlaps
#   Two args: compare specific pair
cmd_conflicts() {
    require_project --info-only

    local wt1="$1"
    local wt2="$2"

    if [ -n "$wt1" ] && [ -n "$wt2" ]; then
        # Compare specific pair
        compare_worktree_conflicts "$wt1" "$wt2"
    else
        # Compare all worktrees
        show_all_conflicts
    fi
}

# Helper: get modified files for a worktree (vs default branch)
get_modified_files() {
    local dir="$1"
    git -C "$dir" diff --name-only "origin/${DEFAULT_BRANCH:-master}" 2>/dev/null || true
}

# Helper: compare two worktrees for conflicts
compare_worktree_conflicts() {
    local wt1="$1"
    local wt2="$2"

    local path1 path2

    # Resolve paths
    if [ "$wt1" = "@" ]; then
        path1="$MAIN_APP"
    else
        path1="$WORKTREES_DIR/$wt1"
    fi

    if [ "$wt2" = "@" ]; then
        path2="$MAIN_APP"
    else
        path2="$WORKTREES_DIR/$wt2"
    fi

    if [ ! -d "$path1" ]; then
        echo -e "${RED}Worktree not found: $wt1${NC}"
        exit 1
    fi
    if [ ! -d "$path2" ]; then
        echo -e "${RED}Worktree not found: $wt2${NC}"
        exit 1
    fi

    echo -e "${BLUE}Comparing:${NC} $wt1 vs $wt2"
    echo ""

    local files1=$(get_modified_files "$path1")
    local files2=$(get_modified_files "$path2")

    local conflicts=$(comm -12 <(echo "$files1" | sort) <(echo "$files2" | sort))

    if [ -z "$conflicts" ]; then
        echo -e "${GREEN}No file conflicts found${NC}"
    else
        local count=$(echo "$conflicts" | wc -l | tr -d ' ')
        echo -e "${YELLOW}⚠️  $count file(s) modified in both worktrees:${NC}"
        echo "$conflicts" | while read -r file; do
            echo "  $file"
        done
    fi
}

# Helper: show all conflicts across all worktrees
show_all_conflicts() {
    if [ ! -d "$WORKTREES_DIR" ]; then
        echo -e "${YELLOW}No worktrees found${NC}"
        return 0
    fi

    local tmpfile=$(mktemp)
    trap "rm -f '$tmpfile'" EXIT

    # Collect all modified files with their worktree names
    for dir in "$WORKTREES_DIR"/*/; do
        [ -d "$dir" ] || continue
        local name=$(basename "$dir")
        get_modified_files "$dir" | while read -r file; do
            [ -n "$file" ] && echo "$name:$file" >> "$tmpfile"
        done
    done

    if [ ! -s "$tmpfile" ]; then
        echo -e "${GREEN}No modified files in any worktree${NC}"
        return 0
    fi

    # Find files that appear in multiple worktrees
    local duplicates=$(cut -d: -f2 "$tmpfile" | sort | uniq -d)

    if [ -z "$duplicates" ]; then
        echo -e "${GREEN}No file conflicts found${NC}"
        echo ""
        echo -e "${BLUE}Summary:${NC}"
        echo "  Worktrees with changes: $(cut -d: -f1 "$tmpfile" | sort -u | wc -l | tr -d ' ')"
        echo "  Total files modified: $(cut -d: -f2 "$tmpfile" | sort -u | wc -l | tr -d ' ')"
    else
        local count=$(echo "$duplicates" | wc -l | tr -d ' ')
        echo -e "${YELLOW}⚠️  $count file(s) modified in multiple worktrees:${NC}"
        echo ""
        echo "$duplicates" | while read -r file; do
            echo -e "${YELLOW}$file${NC}"
            grep ":$file$" "$tmpfile" | cut -d: -f1 | sed 's/^/  /'
        done
    fi
}

# Command: context
# Generate markdown context for AI agents about worktrees
# Usage: pwt context [worktree]
#   No args: context for all worktrees
#   worktree: context focused on specific worktree
cmd_context() {
    require_project --info-only

    local focus_wt="$1"

    echo "# Worktree Context: ${CURRENT_PROJECT}"
    echo ""
    echo "Generated: $(date '+%Y-%m-%d %H:%M')"
    echo ""

    # Project info
    echo "## Project"
    echo ""
    echo "| Key | Value |"
    echo "|-----|-------|"
    echo "| Project | ${CURRENT_PROJECT} |"
    echo "| Main App | ${MAIN_APP} |"
    echo "| Worktrees Dir | ${WORKTREES_DIR} |"
    [ -n "$PROJECT_REMOTE" ] && echo "| Remote | ${PROJECT_REMOTE} |"
    echo ""

    # Active worktrees
    echo "## Active Worktrees"
    echo ""
    echo "| Worktree | Branch | Base | Status | Ahead/Behind |"
    echo "|----------|--------|------|--------|--------------|"

    # Main app
    local main_branch=$(git -C "$MAIN_APP" branch --show-current 2>/dev/null || echo "?")
    local main_hash=$(get_short_hash "$MAIN_APP")
    local main_status=$(get_status_symbols "$MAIN_APP")
    echo "| @ (main) | ${main_branch} | - | ${main_status:-clean} | - |"

    # Worktrees
    if [ -d "$WORKTREES_DIR" ]; then
        for dir in "$WORKTREES_DIR"/*/; do
            [ -d "$dir" ] || continue
            local name=$(basename "$dir")
            local branch=$(git -C "$dir" branch --show-current 2>/dev/null || echo "?")
            local base=$(get_base_branch "$name" "$dir")
            local status=$(get_status_symbols "$dir")
            local divergence=$(get_divergence "$dir" "origin/${DEFAULT_BRANCH:-master}")

            # Get description from metadata
            local desc=$(get_metadata "$name" "description")

            echo "| ${name} | ${branch} | ${base} | ${status:-clean} | ${divergence:-synced} |"
        done
    fi
    echo ""

    # Worktree descriptions
    echo "## Worktree Details"
    echo ""
    if [ -d "$WORKTREES_DIR" ]; then
        for dir in "$WORKTREES_DIR"/*/; do
            [ -d "$dir" ] || continue
            local name=$(basename "$dir")

            # If focus_wt is set, only show that worktree
            if [ -n "$focus_wt" ] && [ "$name" != "$focus_wt" ]; then
                continue
            fi

            local desc=$(get_metadata "$name" "description")
            local branch=$(git -C "$dir" branch --show-current 2>/dev/null || echo "?")
            local base=$(get_base_branch "$name" "$dir")

            echo "### ${name}"
            echo ""
            [ -n "$desc" ] && echo "**Purpose:** ${desc}"
            echo ""
            echo "- **Branch:** ${branch}"
            echo "- **Base:** ${base}"
            echo "- **Path:** ${dir}"
            echo ""

            # Recent commits (last 5)
            echo "**Recent commits:**"
            echo ""
            echo '```'
            git -C "$dir" log --oneline -5 2>/dev/null || echo "No commits"
            echo '```'
            echo ""

            # Modified files (summary)
            local modified=$(git -C "$dir" diff --name-only "origin/${DEFAULT_BRANCH:-master}" 2>/dev/null | wc -l | tr -d ' ')
            if [ "$modified" -gt 0 ]; then
                echo "**Modified files:** ${modified} file(s) changed from ${base}"
                echo ""
                if [ "$modified" -le 20 ]; then
                    echo '```'
                    git -C "$dir" diff --name-only "origin/${DEFAULT_BRANCH:-master}" 2>/dev/null
                    echo '```'
                else
                    echo '```'
                    git -C "$dir" diff --name-only "origin/${DEFAULT_BRANCH:-master}" 2>/dev/null | head -15
                    echo "... and $((modified - 15)) more files"
                    echo '```'
                fi
                echo ""
            fi
        done
    fi

    # Conflicts section
    if [ -z "$focus_wt" ]; then
        echo "## Potential Conflicts"
        echo ""
        echo "Files modified in multiple worktrees:"
        echo ""

        local tmpfile=$(mktemp)
        trap "rm -f '$tmpfile'" EXIT

        # Collect all modified files
        for dir in "$WORKTREES_DIR"/*/; do
            [ -d "$dir" ] || continue
            local name=$(basename "$dir")
            get_modified_files "$dir" | while read -r file; do
                [ -n "$file" ] && echo "$name:$file" >> "$tmpfile"
            done
        done

        if [ -s "$tmpfile" ]; then
            local duplicates=$(cut -d: -f2 "$tmpfile" | sort | uniq -d)
            if [ -n "$duplicates" ]; then
                local count=$(echo "$duplicates" | wc -l | tr -d ' ')
                echo "⚠️ **${count} file(s)** have potential merge conflicts:"
                echo ""
                echo '```'
                echo "$duplicates" | head -20
                [ $(echo "$duplicates" | wc -l) -gt 20 ] && echo "... and more"
                echo '```'
            else
                echo "✅ No conflicting files detected."
            fi
        else
            echo "No modified files in worktrees."
        fi
        echo ""
    fi

    # Instructions for AI
    echo "## Instructions for AI Agents"
    echo ""
    echo "When working in a worktree:"
    echo ""
    echo "1. **Stay focused** on the worktree's purpose (see description above)"
    echo "2. **Avoid modifying** files that are being changed in other worktrees (see conflicts)"
    echo "3. **Coordinate** if you need to touch a conflicting file"
    echo "4. **Base branch** - always create PRs against the base branch shown"
    echo "5. **Status symbols:** + = staged, ! = modified, ? = untracked"
    echo ""
}

# Command: copy
# Copy files between worktrees
# Usage: pwt copy <src> <dest> <patterns...>
#   src/dest can be @ for main app
cmd_copy() {
    local src="$1"
    local dest="$2"
    shift 2

    if [ -z "$src" ] || [ -z "$dest" ] || [ $# -eq 0 ]; then
        echo -e "${RED}Usage: pwt copy <src> <dest> <patterns...>${NC}"
        echo "  src/dest can be @ for main app"
        echo ""
        echo "Examples:"
        echo "  pwt copy @ TICKET-123 \".env*\"          # main → worktree"
        echo "  pwt copy TICKET-123 @ \".env*\"          # worktree → main"
        echo "  pwt copy TICKET-123 TICKET-456 \"*.json\" # between worktrees"
        exit 1
    fi

    local src_path dest_path

    # Resolve source
    if [ "$src" = "@" ]; then
        src_path="$MAIN_APP"
    else
        src_path=$(cmd_cd "$src" 2>/dev/null)
        if [ -z "$src_path" ] || [ ! -d "$src_path" ]; then
            echo -e "${RED}Worktree not found: $src${NC}"
            exit 1
        fi
    fi

    # Resolve destination
    if [ "$dest" = "@" ]; then
        dest_path="$MAIN_APP"
    else
        dest_path=$(cmd_cd "$dest" 2>/dev/null)
        if [ -z "$dest_path" ] || [ ! -d "$dest_path" ]; then
            echo -e "${RED}Worktree not found: $dest${NC}"
            exit 1
        fi
    fi

    echo -e "${BLUE}Copying from $src to $dest:${NC}"

    local count=0
    for pattern in "$@"; do
        # Use find with -name (pattern is a filename glob, not a path)
        while IFS= read -r -d '' file; do
            local rel_path="${file#$src_path/}"
            local dest_file="$dest_path/$rel_path"

            # Create parent directory if needed
            mkdir -p "$(dirname "$dest_file")"

            cp "$file" "$dest_file"
            echo "  ✓ $rel_path"
            count=$((count + 1))
        done < <(find "$src_path" -name "$pattern" -type f -print0 2>/dev/null)
    done

    if [ $count -eq 0 ]; then
        echo "  No files matched"
    else
        echo -e "${GREEN}Copied $count file(s)${NC}"
    fi
}

# Command: doctor
# Check system health and configuration
# Usage: pwt doctor
cmd_doctor() {
    echo -e "${BLUE}pwt doctor${NC}"
    echo ""

    local errors=0

    # Check git
    if command -v git &>/dev/null; then
        local git_version=$(git --version | cut -d' ' -f3)
        echo -e "${GREEN}✓${NC} Git: $git_version"
    else
        echo -e "${RED}✗${NC} Git: not installed"
        errors=$((errors + 1))
    fi

    # Check jq
    if command -v jq &>/dev/null; then
        local jq_version=$(jq --version 2>/dev/null || echo "?")
        echo -e "${GREEN}✓${NC} jq: $jq_version"
    else
        echo -e "${RED}✗${NC} jq: not installed (required)"
        errors=$((errors + 1))
    fi

    # Check lsof
    if has_lsof; then
        echo -e "${GREEN}✓${NC} lsof: installed"
    else
        echo -e "${YELLOW}⚠${NC} lsof: not installed (port detection will be limited)"
        echo "    macOS:  (should be pre-installed)"
        echo "    Ubuntu: sudo apt install lsof"
    fi

    # Check fzf
    if command -v fzf &>/dev/null; then
        local fzf_version=$(fzf --version 2>/dev/null | head -1 || echo "?")
        echo -e "${GREEN}✓${NC} fzf: $fzf_version"
    else
        echo -e "${YELLOW}⚠${NC} fzf: not installed (needed for pwt select)"
    fi

    echo ""

    # Check project configuration
    if [ -n "$CURRENT_PROJECT" ]; then
        echo -e "${GREEN}✓${NC} Project: $CURRENT_PROJECT"

        if [ -n "$MAIN_APP" ] && [ -d "$MAIN_APP" ]; then
            echo -e "${GREEN}✓${NC} Main app: $MAIN_APP"
        else
            echo -e "${RED}✗${NC} Main app: not found"
            errors=$((errors + 1))
        fi

        if [ -n "$WORKTREES_DIR" ]; then
            if [ -d "$WORKTREES_DIR" ]; then
                local wt_count=$(ls -d "$WORKTREES_DIR"/*/ 2>/dev/null | wc -l | tr -d ' ')
                echo -e "${GREEN}✓${NC} Worktrees dir: $WORKTREES_DIR ($wt_count worktrees)"
            else
                echo -e "${YELLOW}⚠${NC} Worktrees dir: $WORKTREES_DIR (not created yet)"
            fi
        fi

        # Check Pwtfile
        if [ -n "${PWTFILE:-}" ] && [ -f "$PWTFILE" ]; then
            echo -e "${GREEN}✓${NC} Pwtfile: $PWTFILE"
        elif [ -f "$MAIN_APP/Pwtfile" ]; then
            echo -e "${GREEN}✓${NC} Pwtfile: $MAIN_APP/Pwtfile"
        else
            echo -e "${YELLOW}⚠${NC} Pwtfile: not found (optional)"
        fi

        # Check editor config
        local editor_cfg=$(get_project_config "$CURRENT_PROJECT" "editor" 2>/dev/null)
        if [ -n "$editor_cfg" ]; then
            if command -v "$editor_cfg" &>/dev/null; then
                echo -e "${GREEN}✓${NC} Editor: $editor_cfg"
            else
                echo -e "${YELLOW}⚠${NC} Editor: $editor_cfg (not found in PATH)"
            fi
        fi

        # Check AI config
        local ai_cfg=$(get_project_config "$CURRENT_PROJECT" "ai" 2>/dev/null)
        if [ -n "$ai_cfg" ]; then
            if command -v "$ai_cfg" &>/dev/null; then
                echo -e "${GREEN}✓${NC} AI: $ai_cfg"
            else
                echo -e "${YELLOW}⚠${NC} AI: $ai_cfg (not found in PATH)"
            fi
        fi
    else
        echo -e "${YELLOW}⚠${NC} Project: not detected (run from project directory)"
    fi

    echo ""
    if [ $errors -gt 0 ]; then
        echo -e "${RED}$errors error(s) found${NC}"
        exit 1
    else
        echo -e "${GREEN}All checks passed!${NC}"
    fi
}

# Command: benchmark
# Show disk usage comparison between worktrees and clones
# Usage: pwt benchmark [N]
cmd_benchmark() {
    require_project

    local n="${1:-1}"

    # Validate N
    if ! [[ "$n" =~ ^[0-9]+$ ]] || [ "$n" -lt 1 ]; then
        echo -e "${RED}Error: N must be a positive integer${NC}"
        echo "Usage: pwt benchmark [N]"
        exit 1
    fi

    local run_id="bench-$$"
    local bench_dir=$(mktemp -d)

    echo -e "${BLUE}pwt benchmark${NC}"
    echo "Repo: $MAIN_APP"
    echo "N:    $n"
    echo ""

    # Cleanup via inline trap (captures variables)
    trap "
        if [ -d '$bench_dir/worktrees' ]; then
            for d in '$bench_dir/worktrees'/*; do
                [ -d \"\$d\" ] || continue
                git -C '$MAIN_APP' worktree remove \"\$d\" --force 2>/dev/null || true
            done
            git -C '$MAIN_APP' branch --list 'bench/$run_id-*' 2>/dev/null | xargs -r git -C '$MAIN_APP' branch -d 2>/dev/null || true
        fi
        rm -rf '$bench_dir' 2>/dev/null || true
    " EXIT

    # Helper for human-readable sizes
    _human_du() { du -sh "$1" 2>/dev/null | cut -f1; }

    # Show main repo sizes
    local main_git=$(_human_du "$MAIN_APP/.git")
    local main_objects=$(_human_du "$MAIN_APP/.git/objects")
    echo "Main repo:"
    echo -e "  .git:         ${GREEN}$main_git${NC}"
    echo -e "  .git/objects: ${GREEN}$main_objects${NC}"
    echo ""

    # Benchmark worktrees
    echo "Creating $n worktree(s)..."
    mkdir -p "$bench_dir/worktrees"

    for i in $(seq 1 "$n"); do
        local wt="$bench_dir/worktrees/wt-$i"
        local br="bench/$run_id-$i"
        git -C "$MAIN_APP" worktree add "$wt" -b "$br" HEAD --quiet 2>/dev/null
        printf "  wt-%d .git: %s\n" "$i" "$(_human_du "$wt/.git")"
    done

    echo ""
    echo "After $n worktree(s):"
    echo -e "  main .git:        ${GREEN}$(_human_du "$MAIN_APP/.git")${NC}"
    echo -e "  main objects:     ${GREEN}$(_human_du "$MAIN_APP/.git/objects")${NC}"
    echo -e "  worktrees total:  ${GREEN}$(_human_du "$bench_dir/worktrees")${NC}"
    echo ""

    # Benchmark clones
    echo "Creating $n clone(s)..."
    mkdir -p "$bench_dir/clones"

    for i in $(seq 1 "$n"); do
        local c="$bench_dir/clones/clone-$i"
        git clone --quiet "$MAIN_APP" "$c" 2>/dev/null
        printf "  clone-%d .git: %s\n" "$i" "$(_human_du "$c/.git")"
    done

    echo ""
    echo "After $n clone(s):"
    echo -e "  clones total:     ${GREEN}$(_human_du "$bench_dir/clones")${NC}"
    echo ""

    # Summary
    local wt_total=$(_human_du "$bench_dir/worktrees")
    local clone_total=$(_human_du "$bench_dir/clones")

    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""
    echo -e "Summary (${GREEN}$n${NC} instances):"
    echo -e "  Worktrees: ${GREEN}$wt_total${NC} (shared .git)"
    echo -e "  Clones:    ${GREEN}$clone_total${NC} (.git × $n)"
    echo ""
    echo "Worktrees share Git objects, not files."
    echo "Clones duplicate everything."
    echo ""
    echo -e "${GREEN}✓${NC} Done (cleanup automatic)"
}

# Command: select
# Interactive worktree selector using fzf
# Usage: pwt select [--preview] [--dirty]
cmd_select() {
    local show_preview=true
    local show_dirty_only=false

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --preview|-p)
                show_preview=true
                shift
                ;;
            --no-preview)
                show_preview=false
                shift
                ;;
            --dirty)
                show_dirty_only=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    # Check if fzf is installed
    if ! command -v fzf &>/dev/null; then
        echo -e "${RED}Error: fzf is required for pwt select${NC}"
        echo "Install with: brew install fzf"
        exit 1
    fi

    # Build enriched list of worktrees
    # Format: name|branch|port|status|marker|description
    local items=()

    # Add main app
    if [ -d "$MAIN_APP" ]; then
        local main_branch=$(git -C "$MAIN_APP" branch --show-current 2>/dev/null || echo "main")
        local main_status=$(get_status_symbols "$MAIN_APP")
        if [ "$show_dirty_only" = false ] || [ -n "$main_status" ]; then
            items+=("@|$main_branch|·|${main_status:-·}|·|main app")
        fi
    fi

    # Add worktrees with metadata
    if [ -d "$WORKTREES_DIR" ] && [ "$(ls -A "$WORKTREES_DIR" 2>/dev/null)" ]; then
        for dir in "$WORKTREES_DIR"/*/; do
            [ -d "$dir" ] || continue
            local name=$(basename "$dir")
            local branch=$(git -C "$dir" branch --show-current 2>/dev/null || echo "?")
            local port=$(get_metadata "$name" "port")
            local marker=$(get_metadata "$name" "marker")
            local desc=$(get_metadata "$name" "description")
            local status=$(get_status_symbols "$dir")

            # Filter by dirty if requested
            if [ "$show_dirty_only" = true ] && [ -z "$status" ]; then
                continue
            fi

            # Truncate description to 30 chars
            [ -n "$desc" ] && desc="${desc:0:30}"

            items+=("$name|$branch|:${port:-·}|${status:-·}|${marker:-·}|${desc:-·}")
        done
    fi

    if [ ${#items[@]} -eq 0 ]; then
        if [ "$show_dirty_only" = true ]; then
            echo -e "${YELLOW}No dirty worktrees found${NC}"
        else
            echo -e "${YELLOW}No worktrees found${NC}"
        fi
        exit 0
    fi

    # Format with column for aligned display
    local formatted
    formatted=$(printf '%s\n' "${items[@]}" | column -t -s'|')

    # Build preview command
    local preview_cmd="name=\$(echo {} | awk '{print \$1}'); "
    preview_cmd+="if [ \"\$name\" = \"@\" ]; then "
    preview_cmd+="  echo '=== Main App ===' && git -C \"$MAIN_APP\" status -sb && echo '' && git -C \"$MAIN_APP\" diff --stat 2>/dev/null | head -15; "
    preview_cmd+="else "
    preview_cmd+="  pwt info \"\$name\" 2>/dev/null || (echo \"Worktree: \$name\" && git -C \"$WORKTREES_DIR/\$name\" status -sb && echo '' && git -C \"$WORKTREES_DIR/\$name\" diff --stat 2>/dev/null | head -15); "
    preview_cmd+="fi"

    # Run fzf with enhanced options
    local fzf_opts=(
        --height=60%
        --reverse
        --ansi
        --header=$'Worktree selector\n↵:cd  ^E:editor  ^A:ai  ^O:open  Esc:cancel'
        --bind="ctrl-e:execute-silent(pwt editor \$(echo {} | awk '{print \$1}'))+abort"
        --bind="ctrl-a:execute-silent(pwt ai \$(echo {} | awk '{print \$1}'))+abort"
        --bind="ctrl-o:execute-silent(pwt open \$(echo {} | awk '{print \$1}'))+abort"
    )

    if [ "$show_preview" = true ]; then
        fzf_opts+=(
            --preview="$preview_cmd"
            --preview-window=right:45%:wrap
        )
    fi

    local selected
    selected=$(echo "$formatted" | fzf "${fzf_opts[@]}")

    if [ -z "$selected" ]; then
        exit 0
    fi

    # Extract worktree name (first column)
    local target=$(echo "$selected" | awk '{print $1}')

    # Output for shell function to cd
    if [ "$target" = "@" ]; then
        echo "$MAIN_APP"
    else
        echo "$WORKTREES_DIR/$target"
    fi
}

# Internal command: _select
# Used by shell function to get selection and cd
cmd__select() {
    local result
    result=$(cmd_select "$@")
    echo "$result"
}

# Command: pick
# Interactive selector + auto-use (sets current symlink)
# Usage: pwt pick [--dirty]
#   Like select, but automatically runs 'pwt use' on selection
cmd_pick() {
    local show_dirty_only=false

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --dirty)
                show_dirty_only=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    # Check if fzf is installed
    if ! command -v fzf &>/dev/null; then
        echo -e "${RED}Error: fzf is required for pwt pick${NC}"
        echo "Install with: brew install fzf"
        exit 1
    fi

    # Build enriched list of worktrees (same as select)
    local items=()

    # Add main app
    if [ -d "$MAIN_APP" ]; then
        local main_branch=$(git -C "$MAIN_APP" branch --show-current 2>/dev/null || echo "main")
        local main_status=$(get_status_symbols "$MAIN_APP")
        if [ "$show_dirty_only" = false ] || [ -n "$main_status" ]; then
            items+=("@|$main_branch|·|${main_status:-·}|·|main app")
        fi
    fi

    # Add worktrees with metadata
    if [ -d "$WORKTREES_DIR" ] && [ "$(ls -A "$WORKTREES_DIR" 2>/dev/null)" ]; then
        for dir in "$WORKTREES_DIR"/*/; do
            [ -d "$dir" ] || continue
            local name=$(basename "$dir")
            local branch=$(git -C "$dir" branch --show-current 2>/dev/null || echo "?")
            local port=$(get_metadata "$name" "port")
            local marker=$(get_metadata "$name" "marker")
            local desc=$(get_metadata "$name" "description")
            local status=$(get_status_symbols "$dir")

            if [ "$show_dirty_only" = true ] && [ -z "$status" ]; then
                continue
            fi

            [ -n "$desc" ] && desc="${desc:0:30}"
            items+=("$name|$branch|:${port:-·}|${status:-·}|${marker:-·}|${desc:-·}")
        done
    fi

    if [ ${#items[@]} -eq 0 ]; then
        if [ "$show_dirty_only" = true ]; then
            echo -e "${YELLOW}No dirty worktrees found${NC}"
        else
            echo -e "${YELLOW}No worktrees found${NC}"
        fi
        exit 0
    fi

    local formatted
    formatted=$(printf '%s\n' "${items[@]}" | column -t -s'|')

    # Build preview command
    local preview_cmd="name=\$(echo {} | awk '{print \$1}'); "
    preview_cmd+="if [ \"\$name\" = \"@\" ]; then "
    preview_cmd+="  echo '=== Main App ===' && git -C \"$MAIN_APP\" status -sb; "
    preview_cmd+="else "
    preview_cmd+="  pwt info \"\$name\" 2>/dev/null || echo \"Worktree: \$name\"; "
    preview_cmd+="fi"

    # Run fzf
    local selected
    selected=$(echo "$formatted" | fzf \
        --height=60% \
        --reverse \
        --ansi \
        --header=$'Pick worktree to set as current\n↵:use  Esc:cancel' \
        --preview="$preview_cmd" \
        --preview-window=right:45%:wrap)

    if [ -z "$selected" ]; then
        exit 0
    fi

    # Extract worktree name and call use
    local target=$(echo "$selected" | awk '{print $1}')
    cmd_use "$target"
}

# Command: topology
# Show project topology (shared vs per-worktree) using LLM
# Usage: pwt topology [ai_tool] [--json]
cmd_topology() {
    local output_format="ascii"
    local ai_override=""

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --json)
                output_format="json"
                shift
                ;;
            -h|--help)
                echo "Usage: pwt topology [ai_tool] [--json]"
                echo ""
                echo "Analyze Pwtfile to show project topology:"
                echo "  - [SHARED] services (postgres, redis, solr)"
                echo "  - [PER-WT] per-worktree services (rails, vite)"
                echo "  - [WARN] potential risks"
                echo ""
                echo "Arguments:"
                echo "  ai_tool     AI to use (claude, codex, ollama, etc.)"
                echo ""
                echo "Options:"
                echo "  --json      Output as JSON"
                echo ""
                echo "Examples:"
                echo "  pwt topology              # uses default (claude)"
                echo "  pwt topology codex        # use codex"
                echo ""
                echo "Note: Runs an LLM, may take a moment"
                return 0
                ;;
            -*)
                echo -e "${RED}Unknown option: $1${NC}" >&2
                return 1
                ;;
            *)
                # First non-option argument is the AI tool
                if [ -z "$ai_override" ]; then
                    ai_override="$1"
                fi
                shift
                ;;
        esac
    done

    # Get AI command: arg > config > default
    local ai_cmd
    if [ -n "$ai_override" ]; then
        ai_cmd="$ai_override"
    else
        ai_cmd=$(get_project_config "$CURRENT_PROJECT" "ai" 2>/dev/null)
        [ -z "$ai_cmd" ] && ai_cmd="claude"
    fi

    # Check if AI command exists
    if ! command -v "$ai_cmd" &>/dev/null; then
        echo -e "${RED}Error: AI command '$ai_cmd' not found${NC}" >&2
        echo "Install it or configure: pwt project set $CURRENT_PROJECT ai <command>" >&2
        return 1
    fi

    # Determine project root
    local project_root="$MAIN_APP"
    if [ ! -d "$project_root" ]; then
        echo -e "${RED}Error: Project root not found${NC}" >&2
        return 1
    fi

    local start_time=$(date +%s)
    echo -e "${BLUE}Analyzing project topology...${NC}" >&2

    # Gather context - focus on Pwtfile and pwt config only
    local context=""
    local files_found=""

    # Pwtfile (primary source of truth)
    local pwtfile_path=""
    pwtfile_path=$(get_project_config "$CURRENT_PROJECT" "pwtfile" 2>/dev/null)
    [ -z "$pwtfile_path" ] && pwtfile_path="$project_root/Pwtfile"
    if [ -f "$pwtfile_path" ]; then
        context+="=== Pwtfile ===\n$(cat "$pwtfile_path")\n\n"
        files_found+="Pwtfile "
    fi

    # pwt project config
    local project_config="$PROJECTS_DIR/$CURRENT_PROJECT/config.json"
    if [ -f "$project_config" ]; then
        context+="=== pwt project config ===\n$(cat "$project_config")\n\n"
        files_found+="pwt-config "
    fi

    # Worktree info
    local worktree_info=""
    if [ -d "$WORKTREES_DIR" ]; then
        local wt_count=$(ls -d "$WORKTREES_DIR"/*/ 2>/dev/null | wc -l | tr -d ' ')
        worktree_info+="Worktrees: $wt_count\n"
        worktree_info+="Directory: $WORKTREES_DIR\n"

        # Port allocation (sample)
        init_metadata
        for wt_path in $(ls -d "$WORKTREES_DIR"/*/ 2>/dev/null | head -3); do
            local wt_name=$(basename "$wt_path")
            local wt_port=$(get_metadata "$wt_name" "port" 2>/dev/null)
            [ -n "$wt_port" ] && worktree_info+="  $wt_name: :$wt_port\n"
        done
    fi
    [ -n "$worktree_info" ] && context+="=== Worktrees ===\n$worktree_info\n"

    if [ -z "$files_found" ]; then
        echo -e "${YELLOW}No Pwtfile found. Create one with: pwt init${NC}" >&2
        return 1
    fi

    echo -e "${DIM}Sources: ${files_found}${NC}" >&2

    # Build the prompt
    # Note: LLMs don't reliably output ANSI escape codes, so we use text markers
    local color_instruction="Do NOT use ANSI color codes. Use text markers instead:
- Mark shared services with [SHARED]
- Mark per-worktree services with [PER-WT]
- Mark warnings/risks with [WARN]
Keep the diagram clean and readable."

    local format_instruction=""
    if [ "$output_format" = "json" ]; then
        format_instruction="Output ONLY valid JSON with this structure:
{
  \"shared\": [{\"name\": \"...\", \"type\": \"...\", \"port\": \"...\", \"evidence\": \"...\"}],
  \"per_worktree\": [{\"name\": \"...\", \"type\": \"...\", \"evidence\": \"...\"}],
  \"relationships\": [{\"from\": \"...\", \"to\": \"...\", \"type\": \"uses\"}],
  \"risks\": [\"...\"]
}"
    else
        format_instruction="Output an ASCII diagram with:
1. Unicode box-drawing characters (┌ ┐ └ ┘ │ ─ ┬ ┴ ├ ┤ ┼)
2. Arrows showing relationships (→ ← ↑ ↓ ◀ ▶)
3. Clear labels inside boxes
4. A legend at the bottom
5. Brief risk notes if applicable

Example style:
┌─────────────────┐
│  Rails (WT)     │
│  per-worktree   │
└────────┬────────┘
         │ uses
         ▼
┌─────────────────┐
│  Postgres       │
│  shared :5432   │
└─────────────────┘"
    fi

    local prompt="Analyze this Pwtfile for 'pwt' (a git worktree manager).

CONTEXT: Multiple worktrees run simultaneously, each with its own port (5002, 5004, etc).

FROM THE PWTFILE, identify:
1. [SHARED] - services shared across worktrees (e.g., postgres, redis, solr)
2. [PER-WT] - services each worktree runs its own (e.g., rails, vite)
3. [WARN] - potential risks (namespace collisions, shared state)

$format_instruction

$color_instruction

$context

PROJECT: $CURRENT_PROJECT

OUTPUT: Compact ASCII diagram. No ANSI codes. Max 40 lines."

    # Call the AI
    echo "" >&2
    echo -e "$prompt" | "$ai_cmd" -p 2>/dev/null || {
        echo -e "$prompt" | "$ai_cmd" --print 2>/dev/null
    }

    # Show timing
    local end_time=$(date +%s)
    local elapsed=$((end_time - start_time))
    echo "" >&2
    echo -e "${DIM}Generated in ${elapsed}s${NC}" >&2
}

# Command: marker
# Set/get/clear marker on worktree
# Usage: pwt marker [worktree] [marker]
#        pwt marker TICKET-123 🚧      # set marker
#        pwt marker TICKET-123         # show marker
#        pwt marker --clear            # clear current worktree marker
#        pwt marker TICKET-123 --clear # clear specific marker
cmd_marker() {
    local target=""
    local marker=""
    local clear=false

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --clear|-c)
                clear=true
                shift
                ;;
            -*)
                echo -e "${RED}Unknown option: $1${NC}"
                exit 1
                ;;
            *)
                if [ -z "$target" ]; then
                    target="$1"
                else
                    marker="$1"
                fi
                shift
                ;;
        esac
    done

    # If no target, use current worktree
    if [ -z "$target" ]; then
        if [ -n "${PWT_WORKTREE:-}" ]; then
            target="$PWT_WORKTREE"
        else
            # Try to detect from PWD
            if [[ "$PWD" == *"-worktrees/"* ]]; then
                target=$(basename "$PWD")
            else
                echo -e "${RED}Error: Not in a worktree. Specify target.${NC}"
                exit 1
            fi
        fi
    fi

    # Verify worktree exists
    local worktree_dir="$WORKTREES_DIR/$target"
    if [ ! -d "$worktree_dir" ]; then
        echo -e "${RED}Error: Worktree not found: $target${NC}"
        exit 1
    fi

    # Clear marker
    if [ "$clear" = true ]; then
        update_metadata "$target" "marker" ""
        echo -e "${GREEN}✓${NC} Cleared marker for $target"
        return 0
    fi

    # Show current marker
    if [ -z "$marker" ]; then
        local current=$(get_metadata "$target" "marker")
        if [ -n "$current" ]; then
            echo "$current"
        else
            echo "(no marker)"
        fi
        return 0
    fi

    # Set marker
    update_metadata "$target" "marker" "$marker"
    echo -e "${GREEN}✓${NC} Set marker for $target: $marker"
}

# Command: for-each
# Run command in all worktrees
# Usage: pwt for-each <command...>
# If command is a Pwtfile function, runs it via run_pwtfile
cmd_for_each() {
    if [ $# -eq 0 ]; then
        echo -e "${RED}Error: No command specified${NC}"
        echo "Usage: pwt for-each <command...>"
        exit 1
    fi

    local first_arg="$1"
    local is_pwtfile_cmd=false

    # Check if first arg is a Pwtfile command
    if has_pwtfile_command "$first_arg"; then
        is_pwtfile_cmd=true
    fi

    local cmd="$*"
    local count=0

    # Helper to run command in a worktree
    _run_in_worktree() {
        local wt_name="$1"
        local wt_path="$2"
        shift 2

        if [ "$is_pwtfile_cmd" = true ]; then
            # Run as Pwtfile command
            PWT_WORKTREE="$wt_name"
            PWT_WORKTREE_PATH="$wt_path"
            PWT_PORT=$(get_metadata "$wt_name" "port" 2>/dev/null || echo "")
            PWT_BRANCH=$(get_metadata "$wt_name" "branch" 2>/dev/null || echo "")
            export PWT_ARGS="${*:2}"  # All args after command name
            (
                cd "$wt_path" || exit 1
                run_pwtfile "$first_arg"
            )
        else
            # Run as shell command
            (
                cd "$wt_path" || exit 1
                export PWT_WORKTREE="$wt_name"
                export PWT_WORKTREE_PATH="$wt_path"
                eval "$cmd"
            )
        fi
    }

    # Run in main app
    echo -e "${BLUE}=== @ (main) ===${NC}"
    _run_in_worktree "@" "$MAIN_APP" "$@"
    echo ""

    # Run in worktrees
    if [ -d "$WORKTREES_DIR" ] && [ "$(ls -A "$WORKTREES_DIR" 2>/dev/null)" ]; then
        for dir in "$WORKTREES_DIR"/*/; do
            [ -d "$dir" ] || continue
            local name=$(basename "$dir")
            count=$((count + 1))

            echo -e "${BLUE}=== $name ===${NC}"
            _run_in_worktree "$name" "$dir" "$@"
            echo ""
        done
    fi

    echo -e "${GREEN}✓ Ran in $((count + 1)) worktrees${NC}"
}

# Command: steps
# List available steps from Pwtfile (functions prefixed with step_)
# Usage: pwt steps
cmd_steps() {
    detect_project
    local pwtfile=$(get_project_pwtfile)

    if [ -z "$pwtfile" ] || [ ! -f "$pwtfile" ]; then
        echo -e "${RED}No Pwtfile found${NC}"
        return 1
    fi

    # Extract step_* function names
    local steps
    steps=$(grep -oE "^step_[a-zA-Z0-9_]+" "$pwtfile" 2>/dev/null | sed 's/^step_//' | sort -u || true)

    if [ -z "$steps" ]; then
        echo -e "${YELLOW}No steps found in Pwtfile${NC}"
        echo "Steps are functions prefixed with 'step_', e.g.:"
        echo "  step_install_deps() { bundle install; }"
        return 0
    fi

    echo -e "${BLUE}Steps ($CURRENT_PROJECT):${NC}"
    echo "$steps" | while read -r step; do
        echo "  $step"
    done
    echo ""
    echo "Usage: pwt step <name>"
}

# Command: step
# Run a single step from Pwtfile
# Usage: pwt step <name> [args...]
cmd_step() {
    local step_name="${1:-}"

    if [ -z "$step_name" ]; then
        echo "Usage: pwt step <name>"
        echo "Run 'pwt steps' to list available steps"
        return 1
    fi

    detect_project
    local pwtfile=$(get_project_pwtfile)
    local func_name="step_${step_name}"

    if [ -z "$pwtfile" ] || [ ! -f "$pwtfile" ]; then
        echo -e "${RED}No Pwtfile found${NC}"
        return 1
    fi

    if ! has_command_in_file "$pwtfile" "$func_name"; then
        echo -e "${RED}Step not found: $step_name${NC}"
        echo "Run 'pwt steps' to list available steps"
        return 1
    fi

    # Set up context from current directory
    local current_dir=$(pwd -P)
    local resolved_worktrees_dir=""
    local resolved_main_app=""

    if [ -n "$WORKTREES_DIR" ] && [ -d "$WORKTREES_DIR" ]; then
        resolved_worktrees_dir=$(cd "$WORKTREES_DIR" 2>/dev/null && pwd -P)
    fi
    if [ -n "$MAIN_APP" ] && [ -d "$MAIN_APP" ]; then
        resolved_main_app=$(cd "$MAIN_APP" 2>/dev/null && pwd -P)
    fi

    if [ -n "$resolved_worktrees_dir" ] && [[ "$current_dir" == "$resolved_worktrees_dir"/* ]]; then
        PWT_WORKTREE=$(basename "$current_dir")
        PWT_WORKTREE_PATH="$current_dir"
        PWT_PORT=$(get_metadata "$PWT_WORKTREE" "port" 2>/dev/null || echo "")
        PWT_BRANCH=$(get_metadata "$PWT_WORKTREE" "branch" 2>/dev/null || echo "")
    elif [ -n "$resolved_main_app" ] && [[ "$current_dir" == "$resolved_main_app"* ]]; then
        PWT_WORKTREE="@"
        PWT_WORKTREE_PATH="$resolved_main_app"
        PWT_PORT=""
        PWT_BRANCH=$(git -C "$MAIN_APP" branch --show-current 2>/dev/null || echo "master")
    else
        PWT_WORKTREE="@"
        PWT_WORKTREE_PATH="${resolved_main_app:-$MAIN_APP}"
        PWT_PORT=""
        PWT_BRANCH=$(git -C "$MAIN_APP" branch --show-current 2>/dev/null || echo "master")
    fi

    shift  # Remove step name
    export PWT_ARGS="$*"

    run_single_pwtfile "$pwtfile" "$func_name" "Step"
}

# Command: prompt
# Output ready-to-use prompt integration snippets
# Usage: pwt prompt [zsh|bash|starship]
cmd_prompt() {
    local shell_type="${1:-zsh}"

    case "$shell_type" in
        zsh)
            cat << 'EOF'
# pwt zsh prompt integration
# Add to ~/.zshrc after eval "$(pwt shell-init)"

# Option 1: Simple - show worktree name in prompt
pwt_prompt_info() {
    if [[ -n "$PWT_WORKTREE" ]]; then
        echo "[${PWT_WORKTREE}] "
    fi
}
PROMPT='$(pwt_prompt_info)'$PROMPT

# Option 2: Rich - show name + port + status (slower)
pwt_prompt_rich() {
    local info=$(pwt current --name 2>/dev/null)
    if [[ -n "$info" && "$info" != "Not in a worktree" ]]; then
        local port=$(pwt current --port 2>/dev/null)
        [[ -n "$port" ]] && info+=":$port"
        echo "[$info] "
    fi
}
# PROMPT='$(pwt_prompt_rich)'$PROMPT

# Option 3: RPROMPT (right side) - non-blocking
RPROMPT='${PWT_WORKTREE:+[$PWT_WORKTREE]}'
EOF
            ;;
        bash)
            cat << 'EOF'
# pwt bash prompt integration
# Add to ~/.bashrc after eval "$(pwt shell-init)"

pwt_prompt_info() {
    if [[ -n "$PWT_WORKTREE" ]]; then
        echo "[${PWT_WORKTREE}] "
    fi
}
PS1='$(pwt_prompt_info)'$PS1
EOF
            ;;
        starship)
            cat << 'EOF'
# pwt starship integration
# Add to ~/.config/starship.toml

[custom.pwt]
command = "echo $PWT_WORKTREE"
when = "[[ -n $PWT_WORKTREE ]]"
format = "[$output]($style) "
style = "bold blue"
EOF
            ;;
        fish)
            cat << 'EOF'
# pwt fish prompt integration
# Add to ~/.config/fish/config.fish

# Option 1: Using pwt ps1 (fast, works from anywhere)
function fish_right_prompt
    set -l pwt_info (pwt ps1 2>/dev/null)
    if test -n "$pwt_info"
        set_color blue
        echo -n "[$pwt_info]"
        set_color normal
    end
end

# Option 2: Using environment variable (only in pwt cd)
function fish_right_prompt
    if test -n "$PWT_WORKTREE"
        set_color blue
        echo -n "[pwt:$PWT_WORKTREE]"
        set_color normal
    end
end
EOF
            ;;
        *)
            echo "Usage: pwt prompt [zsh|bash|starship|fish]"
            echo ""
            echo "Outputs ready-to-use prompt integration code."
            echo ""
            echo "Examples:"
            echo "  pwt prompt zsh      # For zsh users"
            echo "  pwt prompt bash     # For bash users"
            echo "  pwt prompt starship # For starship prompt"
            echo "  pwt prompt fish     # For fish users"
            ;;
    esac
}

# Command: shell-init
# Output shell function for cd integration
# Usage: eval "$(pwt shell-init)"
cmd_shell_init() {
    local pwt_path
    pwt_path=$(which pwt 2>/dev/null || echo "$0")

    cat << EOF
# pwt shell integration
# Add to ~/.zshrc: eval "\$(pwt shell-init)"
pwt() {
    if [[ "\$1" == "cd" ]] || [[ "\$2" == "cd" ]]; then
        # pwt cd or pwt <project> cd - change to worktree directory
        local input target
        if [[ "\$1" == "cd" ]]; then
            input="\$2"
        else
            # pwt <project> cd <target>
            local project="\$1"
            input="\$3"
        fi

        # Handle "-" for previous worktree (like cd -)
        if [[ "\$input" == "-" ]]; then
            if [[ -z "\$PWT_PREVIOUS_PATH" ]]; then
                echo "No previous worktree" >&2
                return 1
            fi
            target="\$PWT_PREVIOUS_PATH"
        else
            if [[ "\$1" == "cd" ]]; then
                target=\$("$pwt_path" _cd "\$input" 2>&1)
            else
                target=\$("$pwt_path" "\$project" _cd "\$input" 2>&1)
            fi
            if [[ \$? -ne 0 ]] || [[ ! -d "\$target" ]]; then
                echo "\$target"
                return 1
            fi
        fi

        # Save current path as previous (if different)
        if [[ "\$PWD" != "\$target" ]]; then
            export PWT_PREVIOUS_PATH="\$PWD"
        fi

        builtin cd "\$target"

        # Set PWT_WORKTREE for prompts and scripts
        if [[ "\$target" == *"-worktrees/"* ]]; then
            export PWT_WORKTREE=\$(basename "\$target")
        else
            unset PWT_WORKTREE
        fi
    elif [[ "\$1" == "select" ]] || [[ "\$2" == "select" ]]; then
        # pwt select or pwt <project> select - interactive selection with cd
        local target
        if [[ "\$1" == "select" ]]; then
            shift
            target=\$("$pwt_path" _select "\$@" 2>&1)
        else
            # pwt <project> select
            local project="\$1"
            shift 2
            target=\$("$pwt_path" "\$project" _select "\$@" 2>&1)
        fi
        if [[ \$? -ne 0 ]] || [[ -z "\$target" ]]; then
            [[ -n "\$target" ]] && echo "\$target"
            return 0
        fi
        if [[ ! -d "\$target" ]]; then
            echo "\$target"
            return 1
        fi

        # Save current path as previous (if different)
        if [[ "\$PWD" != "\$target" ]]; then
            export PWT_PREVIOUS_PATH="\$PWD"
        fi

        builtin cd "\$target"

        # Set PWT_WORKTREE for prompts and scripts
        if [[ "\$target" == *"-worktrees/"* ]]; then
            export PWT_WORKTREE=\$(basename "\$target")
        else
            unset PWT_WORKTREE
        fi
    elif [[ "\$1" == "use" ]] || [[ "\$2" == "use" ]]; then
        # pwt use or pwt <project> use - run command then follow symlink if inside current
        "$pwt_path" "\$@"
        local exit_code=\$?

        # If we're inside a 'current' symlink, cd to follow it
        if [[ "\$PWD" == *"/current" ]] || [[ "\$PWD" == *"/current/"* ]]; then
            # Re-enter the symlink to follow the new target
            local current_path="\${PWD%%/current*}/current"
            if [[ -L "\$current_path" ]]; then
                builtin cd "\$current_path"
                export PWT_WORKTREE=\$(basename "\$(readlink "\$current_path")")
            fi
        fi
        return \$exit_code
    else
        "$pwt_path" "\$@"
    fi
}
EOF
}

# Command: setup-shell
# Install shell integration into user's shell config
# Usage: pwt setup-shell
cmd_setup_shell() {
    local shell_name=$(basename "$SHELL")
    local rc_file=""
    local init_line='eval "$(pwt shell-init)"'
    local needs_source=false

    # Detect shell config file
    case "$shell_name" in
        zsh)
            rc_file="$HOME/.zshrc"
            ;;
        bash)
            # macOS uses .bash_profile, Linux uses .bashrc
            if [ -f "$HOME/.bash_profile" ]; then
                rc_file="$HOME/.bash_profile"
            else
                rc_file="$HOME/.bashrc"
            fi
            ;;
        fish)
            rc_file="$HOME/.config/fish/config.fish"
            init_line='pwt shell-init | source'
            ;;
        *)
            echo -e "${RED}Unsupported shell: $shell_name${NC}"
            echo "Add manually to your shell config:"
            echo "  $init_line"
            return 1
            ;;
    esac

    # Check/add shell-init integration
    if grep -q "pwt shell-init" "$rc_file" 2>/dev/null; then
        echo -e "${GREEN}✓ Shell integration already configured${NC}"
    else
        echo "" >> "$rc_file"
        echo "# pwt shell integration (added by pwt setup-shell)" >> "$rc_file"
        echo "$init_line" >> "$rc_file"
        echo -e "${GREEN}✓ Shell integration installed${NC}"
        needs_source=true
    fi

    # Check/add subshell prompt indicator (zsh/bash only)
    if [[ "$shell_name" == "zsh" || "$shell_name" == "bash" ]]; then
        if grep -q "PWT_SHELL" "$rc_file" 2>/dev/null; then
            echo -e "${GREEN}✓ Subshell prompt already configured${NC}"
        else
            echo "" >> "$rc_file"
            echo "# pwt subshell prompt indicator (added by pwt setup-shell)" >> "$rc_file"
            if [[ "$shell_name" == "zsh" ]]; then
                echo '[[ -n "$PWT_SHELL" ]] && PROMPT="%F{blue}(pwt)%f $PROMPT"' >> "$rc_file"
            else
                echo '[[ -n "$PWT_SHELL" ]] && PS1="(pwt) $PS1"' >> "$rc_file"
            fi
            echo -e "${GREEN}✓ Subshell prompt indicator installed${NC}"
            needs_source=true
        fi
    fi

    echo "  File: $rc_file"

    if [ "$needs_source" = true ]; then
        echo ""
        echo "To activate now, run:"
        echo -e "  ${BLUE}source $rc_file${NC}"
        echo ""
        echo "Or restart your terminal."
    fi
}

# Command: config
# Configure current project (zero-config override)
cmd_config() {
    local key="$1"
    local value="$2"

    # Ensure project is detected
    if [ -z "$CURRENT_PROJECT" ]; then
        echo -e "${RED}Error: No project detected${NC}"
        echo "Run from inside a git repository."
        exit 1
    fi

    local config_dir="$PWT_PROJECTS_DIR/$CURRENT_PROJECT"
    local config_file="$config_dir/config.json"

    # Create config dir if needed
    mkdir -p "$config_dir/hooks"

    # Initialize config file if needed
    if [ ! -f "$config_file" ]; then
        echo "{}" > "$config_file"
    fi

    case "$key" in
        -h|--help|help)
            echo "Usage: pwt config [key] [value]"
            echo ""
            echo "View or set project configuration."
            echo ""
            echo "Commands:"
            echo "  show                 Show all settings (default)"
            echo "  <key>                Show value for key"
            echo "  <key> <value>        Set value for key"
            echo ""
            echo "Keys:"
            echo "  main_app       - Path to main project"
            echo "  worktrees_dir  - Path to worktrees directory"
            echo "  branch_prefix  - Prefix for branches (e.g., gl/)"
            echo "  base_port      - Base port for allocation (default: 5000)"
            echo ""
            echo "Options:"
            echo "  -h, --help, help    Show this help"
            echo ""
            echo "Config location: ~/.pwt/projects/<project>/config.json"
            return 0
            ;;
        ""|show)
            # Show current config
            echo -e "${BLUE}Project: $CURRENT_PROJECT${NC}"
            echo ""
            echo "Current settings:"
            echo "  main_app:      ${MAIN_APP:-"(auto-detected)"}"
            echo "  worktrees_dir: ${WORKTREES_DIR:-"(auto-detected)"}"
            echo "  branch_prefix: ${BRANCH_PREFIX:-"(none)"}"
            echo "  base_port:     ${BASE_PORT:-5000}"
            echo ""
            if [ -f "$config_file" ] && [ "$(cat "$config_file")" != "{}" ]; then
                echo "Saved overrides ($config_file):"
                jq '.' "$config_file"
            else
                echo "No saved overrides (using auto-detected values)."
            fi
            ;;
        main_app|worktrees_dir|branch_prefix|base_port)
            if [ -z "$value" ]; then
                # Show current value
                local current=$(jq -r ".$key // empty" "$config_file" 2>/dev/null)
                echo "${current:-"(not set)"}"
            else
                # Set value (create tmp in same dir for atomic mv)
                local tmp_file
                tmp_file="$(mktemp "${config_file}.tmp.XXXXXX")"
                jq --arg key "$key" --arg value "$value" '.[$key] = $value' "$config_file" > "$tmp_file" && mv "$tmp_file" "$config_file"
                echo -e "${GREEN}✓ Set $key = $value${NC}"
            fi
            ;;
        *)
            echo -e "${RED}Unknown config key: $key${NC}"
            echo ""
            echo "Available keys:"
            echo "  main_app       - Path to main project"
            echo "  worktrees_dir  - Path to worktrees directory"
            echo "  branch_prefix  - Prefix for branches (e.g., user/)"
            echo "  base_port      - Base port for allocation"
            exit 1
            ;;
    esac
}

# Command: project
# Manage project configurations
cmd_project() {
    local action="$1"
    local project="$2"
    local arg3="$3"
    local arg4="$4"

    init_metadata

    case "$action" in
        ""|list)
            # List all projects
            echo -e "${BLUE}Configured Projects:${NC}"
            echo ""
            if [ -d "$PROJECTS_DIR" ] && [ "$(ls -A "$PROJECTS_DIR" 2>/dev/null)" ]; then
                for dir in "$PROJECTS_DIR"/*/; do
                    [ -d "$dir" ] || continue
                    local proj_name=$(basename "$dir")
                    local config_file="$dir/config.json"
                    if [ -f "$config_file" ]; then
                        local main_app=$(jq -r '.main_app // "(not set)"' "$config_file")
                        local prefix=$(jq -r '.branch_prefix // "(not set)"' "$config_file")
                        # Get alias if set
                        local proj_alias=$(jq -r '.alias // empty' "$config_file")
                        if [ -n "$proj_alias" ]; then
                            echo -e "  ${GREEN}$proj_name${NC} (${CYAN}$proj_alias${NC})"
                        else
                            echo -e "  ${GREEN}$proj_name${NC}"
                        fi
                        echo "    main_app: $main_app"
                        echo "    branch_prefix: $prefix"
                        # Count hooks
                        local hook_count=$(ls "$dir/hooks" 2>/dev/null | wc -l | tr -d ' ')
                        if [ "$hook_count" -gt 0 ]; then
                            echo "    hooks: $hook_count"
                        fi
                        echo ""
                    fi
                done
            else
                echo "  No projects configured yet."
                echo ""
                echo "  Use: pwt project init <name>"
            fi
            ;;
        init)
            if [ -z "$project" ]; then
                echo -e "${RED}Error: Project name required${NC}"
                echo "Usage: pwt project init <name>"
                exit 1
            fi
            init_project "$project"
            echo ""
            echo "Edit the config at: $PROJECTS_DIR/$project/config.json"
            echo "Add hooks in: $PROJECTS_DIR/$project/hooks/"
            ;;
        show)
            if [ -z "$project" ]; then
                echo -e "${RED}Error: Project name required${NC}"
                echo "Usage: pwt project show <name>"
                exit 1
            fi
            local config_file="$PROJECTS_DIR/$project/config.json"
            if [ ! -f "$config_file" ]; then
                echo -e "${RED}Project not found: $project${NC}"
                exit 1
            fi
            echo -e "${BLUE}Project: $project${NC}"
            echo ""
            echo "Config:"
            jq '.' "$config_file"
            echo ""
            echo "Hooks:"
            ls -la "$PROJECTS_DIR/$project/hooks/" 2>/dev/null || echo "  (none)"
            ;;
        set)
            if [ -z "$project" ] || [ -z "$arg3" ] || [ -z "$arg4" ]; then
                echo -e "${RED}Error: Missing arguments${NC}"
                echo "Usage: pwt project set <name> <key> <value>"
                exit 1
            fi
            local config_file="$PROJECTS_DIR/$project/config.json"
            if [ ! -f "$config_file" ]; then
                echo -e "${RED}Project not found: $project${NC}"
                echo "Use: pwt project init $project"
                exit 1
            fi
            # Create tmp in same dir for atomic mv
            local tmp_file
            tmp_file="$(mktemp "${config_file}.tmp.XXXXXX")"
            jq --arg key "$arg3" --arg value "$arg4" '.[$key] = $value' "$config_file" > "$tmp_file" && mv "$tmp_file" "$config_file"
            echo -e "${GREEN}✓ Updated $project.$arg3 = $arg4${NC}"
            ;;
        path)
            if [ -z "$project" ]; then
                echo -e "${RED}Error: Project name required${NC}"
                exit 1
            fi
            echo "$PROJECTS_DIR/$project"
            ;;
        alias)
            # pwt project alias <project> [alias|--clear]
            local new_alias="$arg3"

            if [ -z "$project" ]; then
                echo -e "${RED}Error: Project name required${NC}"
                echo "Usage: pwt project alias <project> [<alias>|--clear]"
                exit 1
            fi

            local config_file="$PROJECTS_DIR/$project/config.json"
            if [ ! -f "$config_file" ]; then
                echo -e "${RED}Project not found: $project${NC}"
                exit 1
            fi

            if [ -z "$new_alias" ]; then
                # Show current alias
                local current=$(jq -r '.alias // empty' "$config_file")
                if [ -n "$current" ]; then
                    echo "$current"
                else
                    echo "(no alias set)"
                fi
            elif [ "$new_alias" = "--clear" ]; then
                # Clear alias
                local tmp_file
                tmp_file="$(mktemp "${config_file}.tmp.XXXXXX")"
                jq 'del(.alias)' "$config_file" > "$tmp_file" && mv "$tmp_file" "$config_file"
                echo -e "${GREEN}✓ Cleared alias for $project${NC}"
            else
                # Set alias - validate first
                local reserved_commands="list create remove cd server test meta port project help version config init show set path alias"
                for cmd in $reserved_commands; do
                    if [ "$new_alias" = "$cmd" ]; then
                        echo -e "${RED}Error: '$new_alias' is a reserved command name${NC}"
                        exit 1
                    fi
                done
                # Check if alias conflicts with existing project name
                if [ -f "$PROJECTS_DIR/$new_alias/config.json" ]; then
                    echo -e "${RED}Error: '$new_alias' is already a project name${NC}"
                    exit 1
                fi
                # Check if alias already used by another project
                for cfg in "$PROJECTS_DIR"/*/config.json; do
                    [ -f "$cfg" ] || continue
                    local proj_dir=$(dirname "$cfg")
                    local proj_name=$(basename "$proj_dir")
                    [ "$proj_name" = "$project" ] && continue
                    local other_alias=$(jq -r '.alias // empty' "$cfg")
                    if [ "$other_alias" = "$new_alias" ]; then
                        echo -e "${RED}Error: Alias '$new_alias' already used by project '$proj_name'${NC}"
                        exit 1
                    fi
                done
                # Set alias
                local tmp_file
                tmp_file="$(mktemp "${config_file}.tmp.XXXXXX")"
                jq --arg alias "$new_alias" '.alias = $alias' "$config_file" > "$tmp_file" && mv "$tmp_file" "$config_file"
                echo -e "${GREEN}✓ Set alias '$new_alias' for $project${NC}"
            fi
            ;;
        -h|--help|help)
            echo "Usage: pwt project [command] [args]"
            echo ""
            echo "Manage project configurations."
            echo ""
            echo "Commands:"
            echo "  list                           List all configured projects (default)"
            echo "  init <name>                    Initialize a new project config"
            echo "  show <name>                    Show project config and hooks"
            echo "  set <name> <key> <value>       Update project config value"
            echo "  path <name>                    Print project config directory path"
            echo "  alias <name> [alias|--clear]   Get/set/clear project alias"
            echo ""
            echo "Options:"
            echo "  -h, --help, help    Show this help"
            echo ""
            echo "Config location: ~/.pwt/projects/<project>/config.json"
            echo "Hooks location: ~/.pwt/projects/<project>/hooks/"
            return 0
            ;;
        *)
            echo -e "${RED}Unknown action: $action${NC}"
            echo "Usage: pwt project [list|init|show|set|path|alias]"
            echo ""
            echo "Commands:"
            echo "  list                    - List all configured projects"
            echo "  init <name>             - Initialize a new project config"
            echo "  show <name>             - Show project config and hooks"
            echo "  set <name> <k> <v>      - Update project config value"
            echo "  path <name>             - Print project config directory path"
            echo "  alias <name> [a|--clear] - Get/set/clear project alias"
            exit 1
            ;;
    esac
}

# Command: port
# Get port for a worktree
cmd_port() {
    local name="$1"

    # If no name, try to detect from current directory
    if [ -z "$name" ]; then
        local current_dir=$(pwd)
        if [[ "$current_dir" == "$WORKTREES_DIR"/* ]]; then
            name=$(basename "$current_dir")
        else
            echo -e "${RED}Error: Not in a worktree directory${NC}" >&2
            exit 1
        fi
    fi

    init_metadata
    local port=$(get_metadata "$name" "port")

    if [ -z "$port" ]; then
        echo -e "${RED}Error: No port found for worktree: $name${NC}" >&2
        exit 1
    fi

    echo "$port"
}

# Parse global flags
while [[ "${1:-}" == --* ]]; do
    case "$1" in
        --project)
            CURRENT_PROJECT="$2"
            PROJECT_EXPLICIT=true
            shift 2
            ;;
        --help|-h)
            set -- "help"
            break
            ;;
        *)
            echo -e "${RED}Unknown option: $1${NC}"
            exit 1
            ;;
    esac
done

# Initialize pwt
init_pwt

# Check if first argument is a project name or alias (before command dispatch)
# This allows: pwt myproject list (instead of pwt --project myproject list)
if [ -n "${1:-}" ]; then
    _resolved=$(resolve_project_alias "$1")
    if [ -d "$PWT_PROJECTS_DIR/${_resolved}" ]; then
        # Existing project
        if [ "${2:-}" = "init" ]; then
            # pwt <existing-project> init → show already configured
            echo -e "${YELLOW}Already configured: $_resolved${NC}"
            echo ""
            cat "$PWT_PROJECTS_DIR/${_resolved}/config.json"
            exit 0
        fi
        # Load config and shift for other commands
        CURRENT_PROJECT="$_resolved"
        PROJECT_EXPLICIT=true
        load_project_config "$_resolved"
        shift

        # Check for: pwt <project> <worktree> <pwtfile-cmd|-->
        # e.g., pwt acme @ clean
        #       pwt acme WORKTREE-123 clean
        #       pwt acme @ -- git status
        #       pwt acme 17744 -- git status -- rspec
        if [ -n "${1:-}" ] && [ -n "${2:-}" ]; then
            _wt_target="$1"
            _second_arg="$2"
            _wt_path=""

            # Resolve worktree path (supports @, exact match, and fuzzy match)
            _wt_path=$(resolve_worktree_path "$_wt_target" 2>/dev/null) || true

            if [ -n "$_wt_path" ] && [ -d "$_wt_path" ]; then
                # Check if second arg is -- (exec mode)
                if [ "$_second_arg" = "--" ]; then
                    shift 2  # Remove worktree and -- from args
                    cmd_exec "$_wt_target" -- "$@"
                    exit 0
                fi

                # Check if second arg is a Pwtfile command
                if has_pwtfile_command "$_second_arg"; then
                    shift 2  # Remove worktree and command from args
                    # Set up context and run
                    if [ "$_wt_target" = "@" ]; then
                        PWT_WORKTREE="@"
                        PWT_WORKTREE_PATH="$MAIN_APP"
                        PWT_PORT=""
                        PWT_BRANCH=$(git -C "$MAIN_APP" branch --show-current 2>/dev/null || echo "master")
                    else
                        PWT_WORKTREE="$_wt_target"
                        PWT_WORKTREE_PATH="$_wt_path"
                        _wt_name=$(basename "$_wt_path")
                        PWT_PORT=$(get_metadata "$_wt_name" "port" 2>/dev/null || echo "")
                        PWT_BRANCH=$(get_metadata "$_wt_name" "branch" 2>/dev/null || echo "")
                    fi
                    export PWT_ARGS="$*"
                    run_pwtfile "$_second_arg"
                    exit 0
                fi
            fi
            unset _wt_target _second_arg _wt_path
        fi
    elif [ "${2:-}" = "init" ] && [ "$1" != "project" ]; then
        # New project name + init command: pwt <name> init [url]
        # Exclude "project" to allow: pwt project init <name>
        cmd_init_named "$1" "${3:-}"
        exit 0
    fi
    unset _resolved
fi

# Detect project from current directory (unless already set via --project or first arg)
detect_project

# Check required dependencies
check_dependencies

# Main command dispatch
case "${1:-}" in
    init)
        cmd_init "${2:-}"
        ;;
    create)
        require_project --clone
        shift  # remove "create" from args
        cmd_create "$@"
        ;;
    list|ls)
        require_project --info-only
        shift  # remove "list" from args
        cmd_list "$@"
        ;;
    tree)
        shift  # remove "tree" from args
        cmd_tree "$@"
        ;;
    info|show)
        require_project --info-only
        cmd_info "${2:-}"
        ;;
    current)
        require_project --info-only
        shift  # remove "current" from args
        cmd_current "$@"
        ;;
    use)
        require_project
        shift  # remove "use" from args
        cmd_use "$@"
        ;;
    ps1)
        require_project --info-only
        cmd_ps1
        ;;
    remove|rm)
        require_project
        shift  # remove "remove" from args
        cmd_remove "$@"
        ;;
    server|s)
        require_project
        cmd_server "${2:-}"
        ;;
    repair|fix)
        require_project
        cmd_repair "${2:-}"
        ;;
    auto-remove|cleanup)
        require_project
        shift  # remove "auto-remove" from args
        cmd_auto_remove "$@"
        ;;
    restore)
        shift  # remove "restore" from args
        cmd_restore "$@"
        ;;
    fix-port)
        require_project
        cmd_fix_port "${2:-}"
        ;;
    meta)
        cmd_meta "${2:-}" "${3:-}" "${4:-}" "${5:-}"
        ;;
    alias)
        require_project --info-only
        cmd_alias "${2:-}"
        ;;
    config)
        cmd_config "${2:-}" "${3:-}"
        ;;
    -)
        # Shortcut: pwt - = pwt cd - (go to previous worktree)
        require_project --info-only
        cmd_cd "-"
        _cd_status=$?
        [ -t 1 ] && echo -e "${DIM}Tip: eval \"\$(pwt shell-init)\" for actual cd${NC}" >&2
        exit $_cd_status
        ;;
    cd)
        # Public cd - outputs path (use shell-init for actual directory change)
        require_project --info-only
        cmd_cd "${2:-}"
        _cd_status=$?
        # Hint only if interactive (not piped)
        [ -t 1 ] && echo -e "${DIM}Tip: eval \"\$(pwt shell-init)\" for actual cd${NC}" >&2
        exit $_cd_status
        ;;
    _cd)
        # Internal: output path for cd (used by shell function)
        require_project --info-only
        cmd_cd "${2:-}"
        ;;
    run)
        require_project
        shift  # remove "run" from args
        cmd_run "$@"
        ;;
    shell)
        require_project
        shift  # remove "shell" from args
        cmd_shell "$@"
        ;;
    editor|e)
        require_project
        cmd_editor "${2:-}"
        ;;
    ai)
        require_project
        shift  # remove "ai" from args
        cmd_ai "$@"
        ;;
    open)
        require_project
        cmd_open "${2:-}"
        ;;
    diff)
        require_project
        cmd_diff "${2:-}" "${3:-}"
        ;;
    conflicts)
        require_project
        cmd_conflicts "${2:-}" "${3:-}"
        ;;
    context)
        require_project
        cmd_context "${2:-}"
        ;;
    copy|cp)
        require_project
        shift  # remove "copy" from args
        cmd_copy "$@"
        ;;
    marker)
        require_project
        shift  # remove "marker" from args
        cmd_marker "$@"
        ;;
    for-each)
        require_project
        shift  # remove "for-each" from args
        cmd_for_each "$@"
        ;;
    steps)
        require_project
        cmd_steps
        ;;
    step)
        require_project
        shift  # remove "step" from args
        cmd_step "$@"
        ;;
    doctor)
        cmd_doctor
        ;;
    benchmark)
        shift  # remove "benchmark" from args
        cmd_benchmark "$@"
        ;;
    select)
        require_project --info-only
        shift  # remove "select" from args
        cmd_select "$@"
        ;;
    _select)
        require_project --info-only
        shift
        cmd__select "$@"
        ;;
    pick)
        require_project
        shift  # remove "pick" from args
        cmd_pick "$@"
        ;;
    topology)
        require_project
        shift  # remove "topology" from args
        cmd_topology "$@"
        ;;
    prompt)
        shift  # remove "prompt" from args
        cmd_prompt "$@"
        ;;
    shell-init)
        cmd_shell_init "${2:-}"
        ;;
    setup-shell)
        cmd_setup_shell
        ;;
    project)
        cmd_project "${2:-}" "${3:-}" "${4:-}" "${5:-}"
        ;;
    port)
        cmd_port "${2:-}"
        ;;
    help|"")
        echo "pwt - Power Worktrees"
        echo "A tool for managing git worktrees across multiple projects"
        echo ""
        if [ -n "$CURRENT_PROJECT" ]; then
            echo -e "Current project: ${GREEN}$CURRENT_PROJECT${NC}"
            echo ""
        fi
        echo "Commands:"
        echo "  init [url]                     Initialize project (clone URL or configure current repo)"
        echo "  <name> init [url]              Initialize with specific name (pwt pc init <url>)"
        echo "  create <branch> [base] [desc]  Create new worktree (-e -a --from --from-current --dry-run)"
        echo "  list [flags]                   List worktrees (-v/--verbose, --dirty, --porcelain)"
        echo "  list statusline                Output for shell prompts"
        echo "  tree [--all|--dirty|--ports]   Visual tree view of worktrees"
        echo "  select [--preview]             Interactive worktree selector (fzf)"
        echo "  info [worktree]                Show worktree details"
        echo "  current [--name|--resolved]    Show current (symlink path, --resolved for actual)"
        echo "  use <worktree>                 Set worktree as current (atomic symlink swap)"
        echo "  pick                           Interactive select + auto-use (fzf)"
        echo "  ps1                            Fast prompt helper (O(1), no git)"
        echo "  topology [--json]              Show project topology using LLM (shared vs per-wt)"
        echo "  remove [worktree] [flags]      Remove worktree (--with-branch, --force-branch)"
        echo "  cd [worktree|@|-]              Navigate to worktree (@ main, - previous)"
        echo "  run <worktree> <cmd>           Run command in worktree"
        echo "  for-each <cmd>                 Run command in all worktrees"
        echo "  editor [worktree]              Open worktree in editor"
        echo "  ai [worktree] [-- args]        Start AI tool in worktree"
        echo "  open [worktree]                Open worktree in Finder"
        echo "  diff <wt1> [wt2]               Show diff between worktrees"
        echo "  conflicts [wt1] [wt2]          Show file overlap between worktrees"
        echo "  context [worktree]             Generate markdown context for AI"
        echo "  copy <src> <dest> <patterns>   Copy files between worktrees"
        echo "  marker [worktree] [emoji]      Set/show worktree marker (--clear)"
        echo "  server [worktree]              Start dev server (from Pwtfile)"
        echo "  fix-port [worktree]            Fix port conflict"
        echo "  auto-remove [target] [--execute] Remove worktrees merged into target"
        echo "  restore [backup] [worktree]    Recover backed up changes from trash"
        echo "  doctor                         Check system health and configuration"
        echo "  benchmark                      Compare worktree vs clone disk usage"
        echo "  shell-init                     Output shell function for cd integration"
        echo "  prompt [zsh|bash|starship]     Output prompt integration snippets"
        echo "  meta [action] [args]           Manage worktree metadata"
        echo "  project [action] [args]        Manage project configs"
        echo ""
        echo "Project selection (in order of priority):"
        echo "  1. pwt <project> <command>     Project as first argument"
        echo "  2. pwt --project <name> ...    Explicit flag"
        echo "  3. Auto-detect from pwd        Inside project or worktree dir"
        echo ""
        echo "First time setup:"
        echo "  pwt project init myproject"
        echo "  pwt project set myproject main_app ~/path/to/app"
        echo "  pwt project set myproject worktrees_dir ~/path/to/worktrees"
        echo "  pwt project set myproject branch_prefix \"user/\""
        echo ""
        echo "Examples:"
        echo "  pwt init git@github.com:user/app.git       # Clone and configure"
        echo "  pwt create TICKET-123 master \"fix\" -e -a  # Create + open editor + start AI"
        echo "  pwt create hotfix --from v1.2.3            # Create from tag"
        echo "  pwt list --dirty                           # Only show dirty worktrees"
        echo "  pwt run TICKET-123 npm test                # Run command in worktree"
        echo "  pwt diff TICKET-123                        # Diff worktree vs main"
        echo "  pwt auto-remove master                     # Preview cleanup (dry-run by default)"
        echo "  pwt restore list                           # List available backups"
        echo "  pwt restore apply BACKUP-NAME              # Restore backup to current dir"
        echo "  pwt doctor                                 # Check configuration"
        echo ""
        echo "Shell integration (add to ~/.zshrc):"
        echo "  eval \"\$(pwt shell-init)\""
        echo ""
        echo "After shell-init:"
        echo "  \$PWT_WORKTREE      Current worktree name (when in worktree)"
        echo "  \$PWT_PREVIOUS_PATH Previous path (enables 'pwt cd -')"
        ;;
    *)
        # Try to run as Pwtfile command
        _pwtfile_cmd="$1"
        shift

        # Check if project has Pwtfile with this function
        if has_pwtfile_command "$_pwtfile_cmd"; then
            require_project --info-only

            # If project was explicitly specified (pwt <project> <cmd>), require worktree
            # e.g., "pwt acme clean" should error, use "pwt acme @ clean" instead
            if [ "$PROJECT_EXPLICIT" = true ]; then
                echo -e "${RED}Error: Pwtfile command '$_pwtfile_cmd' requires worktree context${NC}"
                echo ""
                echo "Usage:"
                echo "  pwt $CURRENT_PROJECT @ $_pwtfile_cmd              # Run in main app"
                echo "  pwt $CURRENT_PROJECT <worktree> $_pwtfile_cmd     # Run in specific worktree"
                echo "  pwt $CURRENT_PROJECT for-each $_pwtfile_cmd       # Run in all worktrees"
                echo "  cd <worktree> && pwt $_pwtfile_cmd                # Run in current directory"
                exit 1
            fi

            run_pwtfile_command "$_pwtfile_cmd" "$@"
        else
            echo -e "${RED}Unknown command: $_pwtfile_cmd${NC}"
            echo "Run 'pwt help' for usage"
            exit 1
        fi
        ;;
esac
