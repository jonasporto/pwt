#!/bin/bash
# pwt - Power Worktrees
# A generic tool for managing git worktrees across multiple projects
#
# Usage:
#   pwt create <branch> [base] [desc]   # Create worktree from branch
#   pwt list                            # List worktrees and status
#   pwt info [worktree]                 # Show worktree details
#   pwt remove <worktree>               # Remove worktree
#   pwt server                          # Start dev server
#   pwt fix-port [worktree]             # Fix port conflict
#   pwt auto-remove [target]            # Remove worktrees merged into target
#   pwt meta [action] [args]            # Manage worktree metadata
#   pwt project [action] [args]         # Manage project configs
#
# Project auto-detection:
#   pwt detects the current project from your working directory
#   or you can specify: pwt myproject create ...
#   or use flag: pwt --project myproject create ...
#
# First time setup:
#   pwt project init myproject
#   pwt project set myproject main_app ~/path/to/main/app
#   pwt project set myproject worktrees_dir ~/path/to/worktrees

set -euo pipefail

# PWT directory structure
# PWT_DIR can be overridden via environment for testing/sandbox
PWT_DIR="${PWT_DIR:-$HOME/.pwt}"
PWT_META_FILE="$PWT_DIR/meta.json"
PWT_PROJECTS_DIR="$PWT_DIR/projects"

# Legacy support - will be overridden by project config
METADATA_DIR="$PWT_DIR"
METADATA_FILE="$PWT_META_FILE"
PROJECTS_DIR="$PWT_PROJECTS_DIR"

# Current project context (set by detect_project or --project flag)
CURRENT_PROJECT=""
PROJECT_EXPLICIT=false  # true if project was specified via --project or first arg
MAIN_APP=""
WORKTREES_DIR=""
BRANCH_PREFIX=""
PROJECT_REMOTE=""
DEFAULT_BRANCH=""  # Detected from remote (master or main)
BASE_PORT=5000

# Version
PWT_VERSION="1.0.0"

# Exit codes (for scripting)
EXIT_SUCCESS=0
EXIT_ERROR=1        # General error
EXIT_USAGE=2        # Usage/argument error
EXIT_NOT_FOUND=3    # Resource not found (worktree, project, branch)
EXIT_CONFLICT=4     # Conflict (already exists, port in use)

# Output control (set via --quiet or --verbose flags)
PWT_QUIET=false
PWT_VERBOSE=false

# Performance: List cache and fetch state
LIST_CACHE_DIR="$PWT_DIR/cache"
LIST_CACHE_TTL=300  # 5 minutes
PREFETCH_DONE=false  # Track if we already fetched remote refs
LIST_QUICK_MODE=false  # Skip network operations
LIST_REFRESH_MODE=false  # Force refresh cache

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
DIM='\033[2m'
NC='\033[0m' # No Color

# Cross-platform sed in-place edit (BSD/GNU compatible)
sed_inplace() {
    local expr="$1"
    local file="$2"
    if sed --version >/dev/null 2>&1; then
        sed -i "$expr" "$file"        # GNU sed
    else
        sed -i '' "$expr" "$file"     # BSD sed (macOS)
    fi
}

# Output helpers for --quiet/--verbose control
# Usage: pwt_info "message"     - Normal output (suppressed with --quiet)
# Usage: pwt_debug "message"    - Debug output (only with --verbose)
# Usage: pwt_warn "message"     - Warning (always shown unless --quiet)
# Usage: pwt_error "message"    - Error (always shown)
pwt_info() {
    [ "$PWT_QUIET" = true ] || echo -e "$@"
}

pwt_debug() {
    [ "$PWT_VERBOSE" = true ] && echo -e "${DIM}[debug] $*${NC}" >&2
    return 0
}

pwt_warn() {
    [ "$PWT_QUIET" = true ] || echo -e "${YELLOW}$*${NC}" >&2
}

pwt_error() {
    echo -e "${RED}$*${NC}" >&2
}

# Find similar string from a list (for "did you mean?" suggestions)
# Usage: find_similar "input" "candidate1 candidate2 ..."
# Returns the closest match if similarity > 50%, empty otherwise
find_similar() {
    local input="$1"
    local candidates="$2"
    local best_match=""
    local best_score=0
    local input_len=${#input}

    for candidate in $candidates; do
        local score=0
        local cand_len=${#candidate}

        # Skip if lengths are too different (more than 3 chars apart)
        local len_diff=$((input_len - cand_len))
        [ "$len_diff" -lt 0 ] && len_diff=$((-len_diff))
        [ "$len_diff" -gt 3 ] && continue

        # Check prefix match (strongest signal)
        local prefix_len=2
        [ "$input_len" -lt 2 ] && prefix_len="$input_len"
        if [[ "${candidate:0:$prefix_len}" == "${input:0:$prefix_len}" ]]; then
            score=$((score + 30))
        fi

        # Count common characters
        local i=0
        while [ $i -lt $input_len ]; do
            local char="${input:$i:1}"
            if [[ "$candidate" == *"$char"* ]]; then
                score=$((score + 5))
            fi
            i=$((i + 1))
        done

        # Bonus for similar length
        if [ "$len_diff" -eq 0 ]; then
            score=$((score + 10))
        elif [ "$len_diff" -eq 1 ]; then
            score=$((score + 5))
        fi

        # Update best match
        if [ "$score" -gt "$best_score" ]; then
            best_score="$score"
            best_match="$candidate"
        fi
    done

    # Only suggest if similarity is reasonable (score > 40)
    if [ "$best_score" -gt 40 ]; then
        echo "$best_match"
    fi
}

# Check required command exists
# Usage: require_cmd <cmd> [optional]
# If optional=true, just warn instead of exit
require_cmd() {
    local cmd="$1"
    local optional="${2:-false}"

    if ! command -v "$cmd" >/dev/null 2>&1; then
        if [ "$optional" = true ]; then
            return 1
        else
            pwt_error "Error: Required command not found: $cmd"
            # Provide install hints for common tools
            case "$cmd" in
                git)
                    echo "Install: https://git-scm.com/downloads" >&2
                    echo "  macOS:  xcode-select --install" >&2
                    echo "  Ubuntu: sudo apt install git" >&2
                    ;;
                jq)
                    echo "Install: https://jqlang.github.io/jq/download/" >&2
                    echo "  macOS:  brew install jq" >&2
                    echo "  Ubuntu: sudo apt install jq" >&2
                    ;;
                fzf)
                    echo "Install: https://github.com/junegunn/fzf" >&2
                    echo "  macOS:  brew install fzf" >&2
                    echo "  Ubuntu: sudo apt install fzf" >&2
                    ;;
                lsof)
                    echo "Install:" >&2
                    echo "  macOS:  (pre-installed)" >&2
                    echo "  Ubuntu: sudo apt install lsof" >&2
                    ;;
                *)
                    echo "Please install $cmd to use this feature." >&2
                    ;;
            esac
            exit 1
        fi
    fi
    return 0
}

# Check dependencies early
check_dependencies() {
    require_cmd git
    require_cmd jq
    # Optional: lsof (for port checking), fzf (for select)
    # These are checked where needed, not at startup
}

# Ask user for confirmation (returns 0 for yes, 1 for no)
confirm_action() {
    local prompt="${1:-Continue?}"
    local response
    echo -n "$prompt [y/N] "
    read -r response
    case "$response" in
        [yY]|[yY][eE][sS]) return 0 ;;
        *) return 1 ;;
    esac
}

# Detect submodules and warn user (worktrees + submodules can be problematic)
# Returns 0 if ok to proceed, 1 if user aborted
detect_submodules() {
    local repo_path="${1:-$MAIN_APP}"

    # Check if .gitmodules exists
    if [ ! -f "$repo_path/.gitmodules" ]; then
        return 0
    fi

    echo -e "${YELLOW}⚠  Submodules detected (.gitmodules found)${NC}"

    # Check if any submodule is initialized
    if git -C "$repo_path" submodule status --recursive 2>/dev/null | grep -q '^[ +-]'; then
        echo -e "${YELLOW}⚠  Submodules are initialized${NC}"
        echo ""
        echo "Worktrees + submodules may behave unexpectedly."
        echo "Consider using clone mode for this project."
        echo ""
        echo "Options:"
        echo "  - Continue with worktree (may have issues)"
        echo "  - Use clone mode: pwt create --clone ..."
        echo ""

        if ! confirm_action "Continue with worktree?"; then
            echo "Aborted."
            return 1
        fi
    fi

    return 0
}

# Check if lsof is available (cache result for performance)
_lsof_available=""
has_lsof() {
    if [ -z "$_lsof_available" ]; then
        if command -v lsof >/dev/null 2>&1; then
            _lsof_available="yes"
        else
            _lsof_available="no"
        fi
    fi
    [ "$_lsof_available" = "yes" ]
}

# Get PIDs using a port (returns empty if lsof unavailable)
# Usage: get_pids_on_port <port>
get_pids_on_port() {
    local port="$1"
    if has_lsof; then
        lsof -ti ":$port" 2>/dev/null || true
    fi
    # Without lsof, we can't detect - return empty (assume free)
}

# Check if a port is occupied (returns 1 if occupied or unknown, 0 if free)
# Usage: is_port_free <port>
is_port_free() {
    local port="$1"
    if ! has_lsof; then
        # Without lsof, assume port is free (best effort)
        return 0
    fi
    ! lsof -ti ":$port" > /dev/null 2>&1
}

# Initialize PWT directory
init_pwt() {
    # Create directory structure if it doesn't exist
    if [ ! -d "$PWT_DIR" ]; then
        mkdir -p "$PWT_DIR"
        mkdir -p "$PWT_PROJECTS_DIR"
    fi

    # Create empty metadata file if it doesn't exist
    if [ ! -f "$PWT_META_FILE" ]; then
        echo '{}' > "$PWT_META_FILE"
    fi
}

# Alias for compatibility
init_metadata() {
    init_pwt
}

# ============================================
# List Cache Functions (performance optimization)
# ============================================

# Initialize cache directory
init_cache_dir() {
    [ -d "$LIST_CACHE_DIR" ] || mkdir -p "$LIST_CACHE_DIR"
}

# Get cache file path for current project
get_list_cache_file() {
    local project="${CURRENT_PROJECT:-unknown}"
    echo "$LIST_CACHE_DIR/list-${project}.txt"
}

# Check if cache exists and is fresh (< TTL)
is_list_cache_valid() {
    local cache_file=$(get_list_cache_file)
    [ ! -f "$cache_file" ] && return 1

    # Get cache file age in seconds
    local now=$(date +%s)
    local cache_mtime
    if stat --version >/dev/null 2>&1; then
        cache_mtime=$(stat -c %Y "$cache_file" 2>/dev/null)  # GNU stat
    else
        cache_mtime=$(stat -f %m "$cache_file" 2>/dev/null)  # BSD stat (macOS)
    fi
    [ -z "$cache_mtime" ] && return 1

    local age=$((now - cache_mtime))
    [ "$age" -lt "$LIST_CACHE_TTL" ]
}

# Read cached list output
read_list_cache() {
    local cache_file=$(get_list_cache_file)
    [ -f "$cache_file" ] && cat "$cache_file"
}

# Write list output to cache
write_list_cache() {
    init_cache_dir
    local cache_file=$(get_list_cache_file)
    cat > "$cache_file"
}

# Clear list cache for current project
clear_list_cache() {
    local cache_file=$(get_list_cache_file)
    [ -f "$cache_file" ] && rm -f "$cache_file" || true
}

# Read cached list with dirty-only filter
# Keeps headers (first 3 lines) and filters data lines for dirty status (! or ?)
read_list_cache_filtered() {
    local cache_file=$(get_list_cache_file)
    [ ! -f "$cache_file" ] && return 1
    head -3 "$cache_file"
    tail -n +4 "$cache_file" | grep -E '[!?]' || true
}

# Detect default branch from remote (master or main)
# Usage: detect_default_branch <repo_path>
# Sets DEFAULT_BRANCH global variable
detect_default_branch() {
    local repo="${1:-$MAIN_APP}"
    if [ -z "$repo" ] || [ ! -d "$repo" ]; then
        return
    fi

    # Try to get from remote HEAD
    local remote_head=$(git -C "$repo" symbolic-ref refs/remotes/origin/HEAD 2>/dev/null)
    if [ -n "$remote_head" ]; then
        DEFAULT_BRANCH="${remote_head#refs/remotes/origin/}"
        return
    fi

    # Fallback: check if main or master exists
    if git -C "$repo" rev-parse --verify origin/main >/dev/null 2>&1; then
        DEFAULT_BRANCH="main"
    elif git -C "$repo" rev-parse --verify origin/master >/dev/null 2>&1; then
        DEFAULT_BRANCH="master"
    else
        # Last resort default
        DEFAULT_BRANCH="master"
    fi
}

# Detect project from current directory
# Sets CURRENT_PROJECT, MAIN_APP, WORKTREES_DIR, BRANCH_PREFIX
detect_project() {
    local current_dir="${1:-}"
    # Get current dir, resolve symlinks for consistent comparison
    [ -z "$current_dir" ] && current_dir=$(pwd)
    # Resolve symlinks (e.g., /var -> /private/var on macOS)
    current_dir=$(cd "$current_dir" 2>/dev/null && pwd -P)

    # Already set via --project flag
    if [ -n "$CURRENT_PROJECT" ]; then
        load_project_config "$CURRENT_PROJECT"
        return 0
    fi

    # Search through existing configured projects
    if [ -d "$PWT_PROJECTS_DIR" ]; then
        for project_dir in "$PWT_PROJECTS_DIR"/*/; do
            [ -d "$project_dir" ] || continue
            local project_name=$(basename "$project_dir")
            local config_file="$project_dir/config.json"
            [ -f "$config_file" ] || continue

            local main_app=$(jq -r '.path // .main_app // empty' "$config_file")
            local worktrees_dir=$(jq -r '.worktrees_dir // empty' "$config_file")

            # Check if current dir is main_app or inside worktrees_dir
            # Resolve symlinks in config paths for consistent comparison
            if [ -n "$main_app" ] && [ -d "$main_app" ]; then
                local resolved_main=$(cd "$main_app" 2>/dev/null && pwd -P)
                case "$current_dir" in
                    "$resolved_main"*|"$resolved_main")
                        CURRENT_PROJECT="$project_name"
                        load_project_config "$project_name"
                        return 0
                        ;;
                esac
            fi
            if [ -n "$worktrees_dir" ] && [ -d "$worktrees_dir" ]; then
                local resolved_wt=$(cd "$worktrees_dir" 2>/dev/null && pwd -P)
                case "$current_dir" in
                    "$resolved_wt"*|"$resolved_wt")
                        CURRENT_PROJECT="$project_name"
                        load_project_config "$project_name"
                        return 0
                        ;;
                esac
            fi
        done
    fi

    # No configured project found - try auto-detect from git
    auto_detect_project "$current_dir" || true
    return 0
}

# Auto-detect project from git repository (zero-config)
auto_detect_project() {
    local current_dir="$1"

    # Find git root
    local git_root=$(git -C "$current_dir" rev-parse --show-toplevel 2>/dev/null)
    [ -z "$git_root" ] && return 1

    # Project name = directory name
    local project_name=$(basename "$git_root")

    # Check if we're in a worktree (git-common-dir points to main repo's .git)
    local git_dir=$(git -C "$current_dir" rev-parse --git-dir 2>/dev/null)
    local git_common=$(git -C "$current_dir" rev-parse --git-common-dir 2>/dev/null)

    # In a worktree: git_dir is .git file, git_common is path to main's .git
    # In main repo: git_dir == git_common == .git
    if [ -n "$git_common" ] && [ "$git_dir" != "$git_common" ]; then
        # We're in a worktree, find the main repo
        # git_common = /path/to/main/.git, so main = dirname
        local main_repo=$(dirname "$git_common")
        if [ -d "$main_repo" ]; then
            git_root="$main_repo"
            project_name=$(basename "$git_root")
        fi
    fi

    # Set globals using conventions
    CURRENT_PROJECT="$project_name"
    MAIN_APP="$git_root"
    WORKTREES_DIR="$(dirname "$git_root")/${project_name}-worktrees"
    BRANCH_PREFIX=""

    return 0
}

# Resolve project alias to real project name
# Scans all project configs for "aliases" array or "alias" string
resolve_project_alias() {
    local name="$1"

    # First check if it's a real project
    if [ -f "$PWT_PROJECTS_DIR/$name/config.json" ]; then
        # Check it's not just an alias pointer (legacy) - check both .path and .main_app
        local has_main=$(jq -r '.path // .main_app // empty' "$PWT_PROJECTS_DIR/$name/config.json")
        if [ -n "$has_main" ]; then
            echo "$name"
            return 0
        fi
    fi

    # Scan all projects for alias match
    for config in "$PWT_PROJECTS_DIR"/*/config.json; do
        [ -f "$config" ] || continue

        # Check "aliases" array first (preferred format)
        local found_in_aliases=$(jq -r --arg name "$name" '.aliases // [] | index($name) // empty' "$config" 2>/dev/null)
        if [ -n "$found_in_aliases" ]; then
            basename "$(dirname "$config")"
            return 0
        fi

        # Fall back to legacy "alias" string
        local proj_alias=$(jq -r '.alias // empty' "$config")
        if [ "$proj_alias" = "$name" ]; then
            basename "$(dirname "$config")"
            return 0
        fi
    done

    # Not found, return original (might be auto-detected)
    echo "$name"
}

# Load project configuration into global variables
# Falls back to auto-detect if config doesn't exist
# Supports alias: config can have "alias": "pc"
load_project_config() {
    local project="$1"

    # Resolve alias to real project name
    project=$(resolve_project_alias "$project")
    local config_file="$PWT_PROJECTS_DIR/$project/config.json"

    CURRENT_PROJECT="$project"

    if [ -f "$config_file" ]; then
        # Load from config file
        # path is preferred, main_app for backwards compatibility
        local cfg_path=$(jq -r '.path // .main_app // empty' "$config_file")
        local cfg_wt=$(jq -r '.worktrees_dir // empty' "$config_file")
        local cfg_prefix=$(jq -r '.branch_prefix // empty' "$config_file")
        local cfg_port=$(jq -r '.base_port // empty' "$config_file")
        local cfg_remote=$(jq -r '.remote // empty' "$config_file")

        [ -n "$cfg_path" ] && MAIN_APP="$cfg_path"
        [ -n "$cfg_wt" ] && WORKTREES_DIR="$cfg_wt"
        [ -n "$cfg_prefix" ] && BRANCH_PREFIX="$cfg_prefix"
        [ -n "$cfg_port" ] && BASE_PORT="$cfg_port"
        [ -n "$cfg_remote" ] && PROJECT_REMOTE="$cfg_remote"
    fi

    # Detect default branch after MAIN_APP is set
    detect_default_branch "$MAIN_APP"

    return 0
}

# Require project context for commands that need it
# Auto-creates worktrees directory if needed
# Usage: require_project [--clone] [--info-only]
#   --clone     Auto-clone from remote if not cloned
#   --info-only Skip clone check (for list/info commands)
require_project() {
    local auto_clone=false
    local info_only=false
    for arg in "$@"; do
        [ "$arg" = "--clone" ] && auto_clone=true
        [ "$arg" = "--info-only" ] && info_only=true
    done

    if [ -z "$CURRENT_PROJECT" ]; then
        # Check if we're in a git repo (potential new project)
        if git rev-parse --git-dir &>/dev/null; then
            local repo_name=$(basename "$(git rev-parse --show-toplevel 2>/dev/null)")
            echo -e "${YELLOW}Git repository detected: $repo_name${NC}"
            echo ""
            echo "This repo is not configured with pwt yet."
            echo ""
            echo "To set it up:"
            echo "  pwt init                    # configure this repo"
            echo ""
            echo "Or specify a configured project:"
            echo "  pwt <project> <command>     # e.g., pwt acme list"
            echo "  pwt project list            # see configured projects"
        else
            pwt_error "Error: No project detected"
            echo ""
            echo "You're not inside a git repository."
            echo ""
            echo "Options:"
            echo "  pwt <project> <command>     # specify project explicitly"
            echo "  pwt project list            # see configured projects"
            echo "  cd /path/to/repo && pwt init"
        fi
        exit 1
    fi

    if [ -z "$MAIN_APP" ] || [ -z "$WORKTREES_DIR" ]; then
        echo -e "${RED}Error: Could not determine project paths${NC}"
        echo ""
        echo "Run from inside a git repository, or initialize a project:"
        echo "  cd /path/to/repo && pwt init"
        echo "  pwt init git@github.com:user/repo.git"
        echo ""
        echo "Or configure manually:"
        echo "  pwt project set myproject path /path/to/main/app"
        echo "  pwt project set myproject worktrees_dir /path/to/worktrees"
        exit 1
    fi

    # For info-only mode, skip clone/exist checks
    [ "$info_only" = true ] && return 0

    # Check if main app exists
    if [ ! -d "$MAIN_APP" ]; then
        if [ -n "$PROJECT_REMOTE" ]; then
            if [ "$auto_clone" = true ]; then
                echo -e "${BLUE}Cloning from remote: $PROJECT_REMOTE${NC}"
                local parent_dir=$(dirname "$MAIN_APP")
                mkdir -p "$parent_dir"
                if git clone "$PROJECT_REMOTE" "$MAIN_APP"; then
                    echo -e "${GREEN}✓ Cloned successfully${NC}"
                else
                    echo -e "${RED}Error: Failed to clone from $PROJECT_REMOTE${NC}"
                    exit 1
                fi
            else
                echo -e "${RED}Error: Project not cloned${NC}"
                echo ""
                echo "Run: pwt clone $CURRENT_PROJECT"
                echo "Or:  pwt $CURRENT_PROJECT create <branch> <base> <desc>"
                exit 1
            fi
        else
            echo -e "${RED}Error: Main app directory not found: $MAIN_APP${NC}"
            exit 1
        fi
    fi

    # Auto-create worktrees directory if it doesn't exist
    if [ ! -d "$WORKTREES_DIR" ]; then
        echo -e "${BLUE}Creating worktrees directory: $WORKTREES_DIR${NC}"
        mkdir -p "$WORKTREES_DIR"
    fi
}

# Initialize a project (clone from URL or configure current directory)
# Usage: cmd_init [url]
#   With url: clone and configure as pwt project
#   Without url: configure current git repo as pwt project
cmd_init() {
    local url="${1:-}"

    # If URL provided, clone and configure
    if [ -n "$url" ]; then
        # Extract project name from URL
        local project_name=$(basename "$url" .git)
        local target_dir="${PWD}/${project_name}"

        if [ -d "$target_dir" ]; then
            echo -e "${YELLOW}Already exists: $target_dir${NC}"
            echo "To configure: cd $target_dir && pwt init"
            return 0
        fi

        echo -e "${BLUE}Cloning: $url${NC}"
        if ! git clone "$url" "$target_dir"; then
            echo -e "${RED}Error: Failed to clone${NC}"
            exit 1
        fi

        # Configure the project
        local project_dir="$PWT_PROJECTS_DIR/$project_name"
        mkdir -p "$project_dir"

        cat > "$project_dir/config.json" << EOF
{
  "path": "$target_dir",
  "remote": "$url",
  "worktrees_dir": "${target_dir}-worktrees"
}
EOF

        echo -e "${GREEN}✓ Cloned and configured: $project_name${NC}"
        echo ""
        echo "Usage:"
        echo -e "  ${GREEN}pwt $project_name list${NC}"
        echo -e "  ${GREEN}pwt $project_name create TICKET base \"description\"${NC}"
        return 0
    fi

    # No URL - configure current directory
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        pwt_error "Error: Not a git repository"
        echo ""
        echo "Usage:"
        echo "  pwt init <url>    # Clone and configure new project"
        echo "  cd <repo> && pwt init  # Configure existing repo"
        exit 1
    fi

    local repo_root=$(git rev-parse --show-toplevel)
    local project_name=$(basename "$repo_root")
    local remote_url=$(git remote get-url origin 2>/dev/null || echo "")

    # Check if already configured
    if [ -f "$PWT_PROJECTS_DIR/$project_name/config.json" ]; then
        echo -e "${YELLOW}Already configured: $project_name${NC}"
        echo ""
        cat "$PWT_PROJECTS_DIR/$project_name/config.json"
        return 0
    fi

    # Create config
    local project_dir="$PWT_PROJECTS_DIR/$project_name"
    mkdir -p "$project_dir"

    local config="{
  \"path\": \"$repo_root\",
  \"worktrees_dir\": \"${repo_root}-worktrees\""

    if [ -n "$remote_url" ]; then
        config="$config,
  \"remote\": \"$remote_url\""
    fi

    config="$config
}"

    echo "$config" > "$project_dir/config.json"

    echo -e "${GREEN}✓ Configured: $project_name${NC}"
    echo ""
    cat "$project_dir/config.json"
    echo ""
    echo "Usage:"
    echo -e "  ${GREEN}pwt $project_name list${NC}"
    echo -e "  ${GREEN}pwt $project_name create TICKET base \"description\"${NC}"
}

# Initialize a project with explicit name
# Usage: cmd_init_named <project_name> [url]
#   With url: clone to <project_name> directory and configure
#   Without url: configure current git repo as <project_name>
cmd_init_named() {
    local project_name="$1"
    local url="${2:-}"

    if [ -n "$url" ]; then
        # Clone mode: pwt myproj init <url>
        local target_dir="${PWD}/${project_name}"

        if [ -d "$target_dir" ]; then
            echo -e "${YELLOW}Already exists: $target_dir${NC}"
            echo "To configure: cd $target_dir && pwt init"
            return 0
        fi

        echo -e "${BLUE}Cloning: $url${NC}"
        if ! git clone "$url" "$target_dir"; then
            echo -e "${RED}Error: Failed to clone${NC}"
            exit 1
        fi

        # Configure the project
        local project_dir="$PWT_PROJECTS_DIR/$project_name"
        mkdir -p "$project_dir"

        cat > "$project_dir/config.json" << EOF
{
  "path": "$target_dir",
  "remote": "$url",
  "worktrees_dir": "${target_dir}-worktrees"
}
EOF

        echo -e "${GREEN}✓ Cloned and configured: $project_name${NC}"
        echo ""
        echo "Usage:"
        echo -e "  ${GREEN}pwt $project_name list${NC}"
        echo -e "  ${GREEN}pwt $project_name create TICKET base \"description\"${NC}"
        return 0
    fi

    # No URL - configure current directory with given name
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        pwt_error "Error: Not a git repository"
        echo ""
        echo "Usage:"
        echo "  pwt <name> init <url>    # Clone and configure with name"
        echo "  cd <repo> && pwt <name> init  # Configure existing repo with name"
        exit 1
    fi

    local repo_root=$(git rev-parse --show-toplevel)
    local remote_url=$(git remote get-url origin 2>/dev/null || echo "")

    # Check if already configured
    if [ -f "$PWT_PROJECTS_DIR/$project_name/config.json" ]; then
        echo -e "${YELLOW}Already configured: $project_name${NC}"
        echo ""
        cat "$PWT_PROJECTS_DIR/$project_name/config.json"
        return 0
    fi

    # Create config
    local project_dir="$PWT_PROJECTS_DIR/$project_name"
    mkdir -p "$project_dir"

    local config="{
  \"path\": \"$repo_root\",
  \"worktrees_dir\": \"${repo_root}-worktrees\""

    if [ -n "$remote_url" ]; then
        config="$config,
  \"remote\": \"$remote_url\""
    fi

    config="$config
}"

    echo "$config" > "$project_dir/config.json"

    echo -e "${GREEN}✓ Configured as: $project_name${NC}"
    echo ""
    cat "$project_dir/config.json"
    echo ""
    echo "Usage:"
    echo -e "  ${GREEN}pwt $project_name list${NC}"
    echo -e "  ${GREEN}pwt $project_name create TICKET base \"description\"${NC}"
}

# Atomic write to metadata file with file locking
# Usage: atomic_metadata_write <jq_filter> [jq_args...]
atomic_metadata_write() {
    local jq_filter="$1"
    shift

    init_metadata

    local lock_dir="$METADATA_FILE.lock"
    local lock_pid_file="$lock_dir/pid"
    # Create tmp in same directory as metadata for atomic mv (same filesystem)
    local tmp_file
    tmp_file="$(mktemp "${METADATA_FILE}.tmp.XXXXXX")"
    local max_wait=50  # 5 seconds (50 * 0.1s)
    local stale_threshold=60  # seconds - lock older than this is stale
    local already_locked=false

    # Create tmp_file early and set trap to clean it up on any exit
    trap "rm -f '$tmp_file'" RETURN

    # Check if we already own the lock (re-entrant call)
    if [ -d "$lock_dir" ] && [ -f "$lock_pid_file" ]; then
        local current_owner=$(cat "$lock_pid_file" 2>/dev/null)
        if [ "$current_owner" = "$$" ]; then
            already_locked=true
        fi
    fi

    # Acquire lock using mkdir (atomic on all systems), unless we already own it
    local waited=0
    while [ "$already_locked" = false ] && ! mkdir "$lock_dir" 2>/dev/null; do
        # Check for stale lock
        if [ -f "$lock_pid_file" ]; then
            local lock_pid=$(cat "$lock_pid_file" 2>/dev/null)
            local lock_age=0
            # Get lock age in seconds (portable: stat -f %m on macOS, stat -c %Y on Linux)
            if stat --version >/dev/null 2>&1; then
                lock_age=$(( $(date +%s) - $(stat -c %Y "$lock_pid_file" 2>/dev/null || echo 0) ))
            else
                lock_age=$(( $(date +%s) - $(stat -f %m "$lock_pid_file" 2>/dev/null || echo 0) ))
            fi

            # Remove stale lock if process is dead or lock is too old
            if [ -n "$lock_pid" ]; then
                if ! kill -0 "$lock_pid" 2>/dev/null || [ "$lock_age" -gt "$stale_threshold" ]; then
                    rm -rf "$lock_dir" 2>/dev/null
                    continue  # Retry acquiring lock
                fi
            fi
        fi

        waited=$((waited + 1))
        if [ $waited -ge $max_wait ]; then
            echo -e "${RED}Error: Could not acquire lock on metadata file${NC}" >&2
            return 1
        fi
        sleep 0.1
    done

    # Write our PID to the lock (only if we acquired it)
    if [ "$already_locked" = false ]; then
        echo "$$" > "$lock_pid_file"
        # Update trap to also clean lock after acquiring it
        trap "rm -rf '$lock_dir' '$tmp_file'" RETURN
    fi
    # If already_locked, we keep the original trap that only cleans tmp_file

    # Perform atomic write
    if jq "$jq_filter" "$@" "$METADATA_FILE" > "$tmp_file"; then
        mv "$tmp_file" "$METADATA_FILE"
        return 0
    else
        return 1
    fi
    # trap handles cleanup on return
}

# Acquire metadata lock (for operations needing read-modify-write atomicity)
# Usage: acquire_metadata_lock
# Returns: 0 on success, 1 on failure
# IMPORTANT: Must call release_metadata_lock when done
acquire_metadata_lock() {
    init_metadata

    local lock_dir="$METADATA_FILE.lock"
    local lock_pid_file="$lock_dir/pid"
    local max_wait=50  # 5 seconds
    local stale_threshold=60

    local waited=0
    while ! mkdir "$lock_dir" 2>/dev/null; do
        # Check for stale lock
        if [ -f "$lock_pid_file" ]; then
            local lock_pid=$(cat "$lock_pid_file" 2>/dev/null)
            local lock_age=0
            if stat --version >/dev/null 2>&1; then
                lock_age=$(( $(date +%s) - $(stat -c %Y "$lock_pid_file" 2>/dev/null || echo 0) ))
            else
                lock_age=$(( $(date +%s) - $(stat -f %m "$lock_pid_file" 2>/dev/null || echo 0) ))
            fi
            if [ -n "$lock_pid" ]; then
                if ! kill -0 "$lock_pid" 2>/dev/null || [ "$lock_age" -gt "$stale_threshold" ]; then
                    rm -rf "$lock_dir" 2>/dev/null
                    continue
                fi
            fi
        fi

        waited=$((waited + 1))
        if [ $waited -ge $max_wait ]; then
            echo -e "${RED}Error: Could not acquire metadata lock${NC}" >&2
            return 1
        fi
        sleep 0.1
    done

    echo "$$" > "$lock_pid_file"
    return 0
}

# Release metadata lock
# Usage: release_metadata_lock
release_metadata_lock() {
    local lock_dir="$METADATA_FILE.lock"
    rm -rf "$lock_dir" 2>/dev/null
}

# Save worktree metadata (namespaced by project)
# Usage: save_metadata <name> <path> <branch> <base> <base_commit> <port> <description>
save_metadata() {
    local name="$1"
    local path="$2"
    local branch="$3"
    local base="$4"
    local base_commit="$5"
    local port="$6"
    local description="$7"
    local mode="${8:-worktree}"  # worktree or clone
    local created_at=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    local project="${CURRENT_PROJECT:-unknown}"

    atomic_metadata_write \
       '.[$project][$name] = {
           path: $path,
           branch: $branch,
           base: $base,
           base_commit: $base_commit,
           port: $port,
           description: $description,
           mode: $mode,
           created_at: $created_at
       }' \
       --arg project "$project" \
       --arg name "$name" \
       --arg path "$path" \
       --arg branch "$branch" \
       --arg base "$base" \
       --arg base_commit "$base_commit" \
       --argjson port "$port" \
       --arg description "$description" \
       --arg mode "$mode" \
       --arg created_at "$created_at"
}

# Get worktree metadata field (namespaced by project)
# Usage: get_metadata <name> <field>
get_metadata() {
    local name="$1"
    local field="$2"
    local project="${CURRENT_PROJECT:-unknown}"

    init_metadata

    jq -r --arg project "$project" --arg name "$name" --arg field "$field" \
        '.[$project][$name][$field] // empty' "$METADATA_FILE" 2>/dev/null
}

# Get extra metadata fields as key=value string (for Meta column in list)
# Excludes fields already shown as columns: path, branch, base, base_commit, created_at, mode
# Shows: port, description, and any custom fields (only if non-empty)
# Usage: get_extra_metadata <name>
get_extra_metadata() {
    local name="$1"
    local project="${CURRENT_PROJECT:-unknown}"

    init_metadata

    jq -r --arg project "$project" --arg name "$name" '
        .[$project][$name] // {} |
        to_entries |
        map(select(.key | test("^(path|branch|base|base_commit|created_at|mode)$") | not)) |
        map(select(.value != null and .value != "")) |
        map("\(.key)=\(.value)") |
        join(" ")
    ' "$METADATA_FILE" 2>/dev/null
}

# Remove worktree metadata (namespaced by project)
# Usage: remove_metadata <name>
remove_metadata() {
    local name="$1"
    local project="${CURRENT_PROJECT:-unknown}"
    atomic_metadata_write 'del(.[$project][$name])' \
        --arg project "$project" --arg name "$name"
}

# Update worktree metadata field (namespaced by project)
# Usage: update_metadata <name> <field> <value>
# Note: For numeric fields (port), use update_metadata_json
update_metadata() {
    local name="$1"
    local field="$2"
    local value="$3"
    local project="${CURRENT_PROJECT:-unknown}"
    atomic_metadata_write \
       'if .[$project][$name] then .[$project][$name][$field] = $value else . end' \
       --arg project "$project" --arg name "$name" --arg field "$field" --arg value "$value"
}

# Update worktree metadata field with JSON value (for numbers, booleans, etc.)
# Usage: update_metadata_json <name> <field> <json_value>
update_metadata_json() {
    local name="$1"
    local field="$2"
    local json_value="$3"
    local project="${CURRENT_PROJECT:-unknown}"
    atomic_metadata_write \
       'if .[$project][$name] then .[$project][$name][$field] = $value else . end' \
       --arg project "$project" --arg name "$name" --arg field "$field" --argjson value "$json_value"
}

# List all metadata for current project
list_metadata() {
    local project="${CURRENT_PROJECT:-unknown}"
    init_metadata
    jq --arg project "$project" '.[$project] // {}' "$METADATA_FILE"
}

# Get project config directory
# Usage: get_project_dir <project_name>
get_project_dir() {
    local project="$1"
    echo "$PROJECTS_DIR/$project"
}

# Get project config value
# Usage: get_project_config <project_name> <key>
get_project_config() {
    local project="$1"
    local key="$2"
    local config_file="$PROJECTS_DIR/$project/config.json"

    if [ -f "$config_file" ]; then
        jq -r --arg key "$key" '.[$key] // empty' "$config_file" 2>/dev/null
    fi
}

# Pwtfile helpers (available in Pwtfile)
# These are sourced when running a Pwtfile
pwtfile_env() {
    local key="$1"
    local value="$2"
    if [ -f .env ]; then
        if grep -q "^${key}=" .env; then
            sed_inplace "s|^${key}=.*|${key}=${value}|" .env
        else
            echo "${key}=${value}" >> .env
        fi
    fi
}

pwtfile_replace() {
    local file="$1"
    local from="$2"
    local to="$3"
    [ -f "$file" ] && sed_inplace "s|${from}|${to}|g" "$file"
}

# Safe literal string replacement (no regex interpretation)
# Cross-platform: uses perl's \Q...\E for literal matching
# Usage: pwtfile_replace_literal <file> <from> <to>
# Example: pwtfile_replace_literal "config.yml" "localhost:3000" "localhost:5007"
pwtfile_replace_literal() {
    local file="$1"
    local from="$2"
    local to="$3"
    [ -f "$file" ] || return 0

    if command -v perl >/dev/null 2>&1; then
        # \Q...\E quotes metacharacters, making it literal
        perl -i -pe 'BEGIN { $f = shift; $t = shift } s/\Q$f\E/$t/g' "$from" "$to" "$file"
    else
        echo "  ! perl not found, skipping literal replace in $file"
        return 1
    fi
}

# Regex replacement using perl (cross-platform, unlike sed -E)
# Usage: pwtfile_replace_re <file> <pattern> <replacement>
# Example: pwtfile_replace_re "config.yml" "port:\s*\d+" "port: 5007"
pwtfile_replace_re() {
    local file="$1"
    local pattern="$2"
    local replacement="$3"
    [ -f "$file" ] || return 0

    if command -v perl >/dev/null 2>&1; then
        perl -i -pe "s/$pattern/$replacement/g" "$file"
    else
        echo "  ! perl not found, skipping regex replace in $file"
        return 1
    fi
}

pwtfile_database() {
    local action="$1"
    local name="$2"
    case "$action" in
        create) createdb "$name" 2>/dev/null || true ;;
        drop) dropdb "$name" 2>/dev/null || true ;;
    esac
}

pwtfile_rake() {
    bundle exec rake "$@" 2>/dev/null || true
}

pwtfile_run() {
    "$@" 2>/dev/null || true
}

# Symlink from main app to current worktree
# Usage: pwtfile_symlink <path>
# Example: pwtfile_symlink "node_modules"
pwtfile_symlink() {
    local path="$1"
    local source="$MAIN_APP/$path"
    local target="$PWD/$path"

    if [ ! -e "$source" ]; then
        echo "  ! Source not found: $source"
        return 1
    fi

    if [ -e "$target" ] && [ ! -L "$target" ]; then
        echo "  ! Target exists (not a symlink): $target"
        return 1
    fi

    rm -f "$target" 2>/dev/null
    ln -sf "$source" "$target"
    echo "  ✓ Symlinked: $path"
}

# Copy from main app to current worktree
# Usage: pwtfile_copy <path>
# Example: pwtfile_copy ".env"
pwtfile_copy() {
    local path="$1"
    local source="$MAIN_APP/$path"
    local target="$PWD/$path"

    if [ ! -e "$source" ]; then
        echo "  ! Source not found: $source"
        return 1
    fi

    if [ -d "$source" ]; then
        cp -r "$source" "$target"
    else
        cp "$source" "$target"
    fi
    echo "  ✓ Copied: $path"
}

# ============================================================
# List display helpers
# ============================================================

# Format relative time from Unix timestamp or git date
# Usage: format_relative_time <timestamp_or_git_date>
# Output: "30m", "4h", "2d", "3w", "5M"
format_relative_time() {
    local input="$1"
    local now=$(date +%s)
    local timestamp

    # Handle git date format or Unix timestamp
    if [[ "$input" =~ ^[0-9]+$ ]]; then
        timestamp="$input"
    else
        timestamp=$(date -j -f "%Y-%m-%d %H:%M:%S %z" "$input" +%s 2>/dev/null || \
                   date -d "$input" +%s 2>/dev/null || \
                   echo "$now")
    fi

    local diff=$((now - timestamp))

    if [ $diff -lt 60 ]; then
        echo "now"
    elif [ $diff -lt 3600 ]; then
        echo "$((diff / 60))m"
    elif [ $diff -lt 86400 ]; then
        echo "$((diff / 3600))h"
    elif [ $diff -lt 604800 ]; then
        echo "$((diff / 86400))d"
    elif [ $diff -lt 2592000 ]; then
        echo "$((diff / 604800))w"
    else
        echo "$((diff / 2592000))M"
    fi
}

# Get git status symbols
# Usage: get_status_symbols <dir>
# Output: "+!?" format (+ staged, ! modified, ? untracked)
get_status_symbols() {
    local dir="$1"
    local symbols=""

    local staged=$(git -C "$dir" diff --cached --numstat 2>/dev/null | wc -l | tr -d ' ')
    local modified=$(git -C "$dir" diff --numstat 2>/dev/null | wc -l | tr -d ' ')
    local untracked=$(git -C "$dir" ls-files --others --exclude-standard 2>/dev/null | wc -l | tr -d ' ')

    [ "$staged" -gt 0 ] && symbols="${symbols}+"
    [ "$modified" -gt 0 ] && symbols="${symbols}!"
    [ "$untracked" -gt 0 ] && symbols="${symbols}?"

    echo "$symbols"
}

# Get divergence from a ref (ahead/behind)
# Usage: get_divergence <dir> <ref>
# Output: "↑3" or "↓2" or "↑3↓2" or ""
get_divergence() {
    local dir="$1"
    local ref="$2"
    local result=""

    local ahead=$(git -C "$dir" rev-list --count "HEAD...$ref" --left-only 2>/dev/null || echo "0")
    local behind=$(git -C "$dir" rev-list --count "HEAD...$ref" --right-only 2>/dev/null || echo "0")

    # Remove whitespace
    ahead=$(echo "$ahead" | tr -d ' ')
    behind=$(echo "$behind" | tr -d ' ')

    [ "$ahead" -gt 0 ] && result="↑${ahead}"
    [ "$behind" -gt 0 ] && result="${result}↓${behind}"

    echo "$result"
}

# Get remote divergence (vs upstream)
# Usage: get_remote_divergence <dir>
# Output: "⇡3" or "⇣2" or "⇡3⇣2" or ""
get_remote_divergence() {
    local dir="$1"
    local branch=$(git -C "$dir" branch --show-current 2>/dev/null)
    [ -z "$branch" ] && return

    local upstream=$(git -C "$dir" rev-parse --abbrev-ref "${branch}@{upstream}" 2>/dev/null)
    [ -z "$upstream" ] && return

    local result=""
    local ahead=$(git -C "$dir" rev-list --count "${upstream}..HEAD" 2>/dev/null || echo "0")
    local behind=$(git -C "$dir" rev-list --count "HEAD..${upstream}" 2>/dev/null || echo "0")

    # Remove whitespace
    ahead=$(echo "$ahead" | tr -d ' ')
    behind=$(echo "$behind" | tr -d ' ')

    [ "$ahead" -gt 0 ] && result="⇡${ahead}"
    [ "$behind" -gt 0 ] && result="${result}⇣${behind}"

    echo "$result"
}

# Check if path is the previous worktree
# Usage: is_previous_worktree <path>
# Returns: 0 if previous, 1 otherwise
is_previous_worktree() {
    local path="$1"
    [ -n "${PWT_PREVIOUS_PATH:-}" ] && [ "$PWT_PREVIOUS_PATH" = "$path" ]
}

# Calculate visual width of string (accounting for multi-byte Unicode)
# Usage: visual_width <string>
visual_width() {
    local str="$1"
    # Use wc -m to count characters (not bytes)
    # Preserve current locale or fallback to UTF-8 for proper Unicode handling
    local lc="${LC_ALL:-${LC_CTYPE:-${LANG:-C.UTF-8}}}"
    printf "%s" "$str" | LC_ALL="$lc" wc -m | tr -d ' '
}

# Pad string to fixed visual width
# Usage: pad_visual <string> <width>
pad_visual() {
    local str="$1"
    local width="$2"
    local visual=$(visual_width "$str")
    printf "%s" "$str"
    local i
    for ((i=visual; i<width; i++)); do
        printf " "
    done
}

# Get short commit hash
# Usage: get_short_hash <dir>
get_short_hash() {
    local dir="$1"
    git -C "$dir" rev-parse --short HEAD 2>/dev/null || echo "?"
}

# Get base branch from metadata or detect from reflog
# Usage: get_base_branch <worktree_name> <dir>
get_base_branch() {
    local name="$1"
    local dir="$2"

    # First try metadata
    local base=$(get_metadata "$name" "base")
    if [ -n "$base" ]; then
        echo "$base"
        return
    fi

    # Fallback to default branch
    echo "${DEFAULT_BRANCH:-master}"
}

# Hash-based port generation (deterministic)
# Usage: pwtfile_hash_port [name] [base]
# Output: port number
pwtfile_hash_port() {
    local name="${1:-${PWT_WORKTREE:-}}"
    local base="${2:-${PORT_BASE:-5000}}"

    # Hash the name and take first 4 hex chars for offset 0-65535
    # macOS uses 'md5 -q', Linux uses 'md5sum'
    local hash
    if command -v md5sum >/dev/null 2>&1; then
        hash=$(printf "%s" "$name" | md5sum | awk '{print $1}')
    else
        hash=$(printf "%s" "$name" | md5 -q)
    fi
    local offset=$((16#${hash:0:4} % 1000))

    echo $((base + offset))
}

# ============================================================
# End list display helpers
# ============================================================

# Read PORT_BASE from Pwtfile (if defined)
# Sets BASE_PORT global variable
read_port_base() {
    local pwtfile=""

    # Check project config for custom pwtfile path first
    local config_pwtfile=$(get_project_config "$CURRENT_PROJECT" "pwtfile")
    if [ -n "$config_pwtfile" ]; then
        config_pwtfile="${config_pwtfile/#\~/$HOME}"
        [[ "$config_pwtfile" != /* ]] && config_pwtfile="$MAIN_APP/$config_pwtfile"
        [ -f "$config_pwtfile" ] && pwtfile="$config_pwtfile"
    fi

    # Fallback to default location
    if [ -z "$pwtfile" ] && [ -n "$MAIN_APP" ] && [ -f "$MAIN_APP/Pwtfile" ]; then
        pwtfile="$MAIN_APP/Pwtfile"
    fi

    [ -z "$pwtfile" ] && return 0

    # Extract PORT_BASE from Pwtfile (bash only)
    local port_base=$(grep -E "^PORT_BASE=" "$pwtfile" 2>/dev/null | head -1 | cut -d= -f2)

    if [ -n "$port_base" ] && [[ "$port_base" =~ ^[0-9]+$ ]]; then
        # Pwtfile PORT_BASE means "first worktree port"
        # Internal BASE_PORT means "main app port" (worktrees start at BASE_PORT+1)
        # So if PORT_BASE=5001 (first worktree), BASE_PORT=5000 (main app)
        BASE_PORT=$((port_base - 1))
    fi
}

# Run Pwtfile if exists
# Looks for: Pwtfile, Pwtfile.rb, Pwtfile.js
# Usage: run_pwtfile <phase> (setup|teardown|server)
# Execute a single Pwtfile
# Arguments: pwtfile_path phase label
run_single_pwtfile() {
    local pwtfile="$1"
    local phase="$2"
    local label="$3"

    [ ! -f "$pwtfile" ] && return 0

    case "$pwtfile" in
        *.rb)
            echo -e "${BLUE}Running $label ($phase)...${NC}"
            ruby "$pwtfile" "$phase"
            echo -e "  ${GREEN}✓${NC} $label ($phase) completed"
            ;;
        *.js)
            echo -e "${BLUE}Running $label ($phase)...${NC}"
            if command -v bun >/dev/null 2>&1; then
                bun "$pwtfile" "$phase"
            else
                node "$pwtfile" "$phase"
            fi
            echo -e "  ${GREEN}✓${NC} $label ($phase) completed"
            ;;
        *)
            # Bash Pwtfile - source and call function
            # Check if function exists before printing/running
            if ! grep -qE "^${phase}\s*\(\)|^function\s+${phase}\b" "$pwtfile" 2>/dev/null; then
                return 0  # Function doesn't exist, skip silently
            fi

            echo -e "${BLUE}Running $label ($phase)...${NC}"
            (
                cd "$PWT_WORKTREE_PATH"
                # Make helpers available
                env() { pwtfile_env "$@"; }
                replace() { pwtfile_replace "$@"; }
                replace_literal() { pwtfile_replace_literal "$@"; }
                replace_re() { pwtfile_replace_re "$@"; }
                database() { pwtfile_database "$@"; }
                rake() { pwtfile_rake "$@"; }
                run() { pwtfile_run "$@"; }

                source "$pwtfile"

                # Call the phase function if it exists
                if type "$phase" &>/dev/null; then
                    "$phase"
                fi
            )
            echo -e "  ${GREEN}✓${NC} $label ($phase) completed"
            ;;
    esac
}

# Check if a command exists in a specific file
# Usage: has_command_in_file <file> <command>
has_command_in_file() {
    local file="$1"
    local cmd="$2"
    [ -f "$file" ] || return 1
    # Match: "cmd() {" or "function cmd {"
    grep -qE "^${cmd}\s*\(\)|^function\s+${cmd}\b" "$file" 2>/dev/null
}

# Get project Pwtfile path
# Usage: get_project_pwtfile
get_project_pwtfile() {
    detect_project

    local project_pwtfile=""
    local config_pwtfile=$(get_project_config "$CURRENT_PROJECT" "pwtfile")

    if [ -n "$config_pwtfile" ]; then
        config_pwtfile="${config_pwtfile/#\~/$HOME}"
        [[ "$config_pwtfile" != /* ]] && config_pwtfile="$MAIN_APP/$config_pwtfile" || true
        [ -f "$config_pwtfile" ] && project_pwtfile="$config_pwtfile" || true
    fi

    if [ -z "$project_pwtfile" ]; then
        [ -f "$MAIN_APP/Pwtfile" ] && project_pwtfile="$MAIN_APP/Pwtfile" || true
    fi

    echo "$project_pwtfile"
}

# Check if a command exists in project OR global Pwtfile
# Usage: has_pwtfile_command <command>
has_pwtfile_command() {
    local cmd="$1"
    local project_pwtfile=$(get_project_pwtfile)
    local global_pwtfile="$PWT_DIR/Pwtfile"

    # Check project first, then global
    has_command_in_file "$project_pwtfile" "$cmd" && return 0
    has_command_in_file "$global_pwtfile" "$cmd" && return 0
    return 1
}

# Run a Pwtfile command in current worktree context
# Usage: run_pwtfile_command <command> [args...]
run_pwtfile_command() {
    local cmd="$1"
    shift

    # Set up worktree context from current directory
    # Resolve symlinks for consistent comparison (e.g., /var -> /private/var on macOS)
    local current_dir=$(pwd -P)
    local resolved_worktrees_dir=""
    local resolved_main_app=""

    if [ -n "$WORKTREES_DIR" ] && [ -d "$WORKTREES_DIR" ]; then
        resolved_worktrees_dir=$(cd "$WORKTREES_DIR" 2>/dev/null && pwd -P)
    fi
    if [ -n "$MAIN_APP" ] && [ -d "$MAIN_APP" ]; then
        resolved_main_app=$(cd "$MAIN_APP" 2>/dev/null && pwd -P)
    fi

    # Check if we're in a worktree or main app
    if [ -n "$resolved_worktrees_dir" ] && [[ "$current_dir" == "$resolved_worktrees_dir"/* ]]; then
        PWT_WORKTREE=$(basename "$current_dir")
        PWT_WORKTREE_PATH="$current_dir"
    elif [ -n "$resolved_main_app" ] && [[ "$current_dir" == "$resolved_main_app"* ]]; then
        PWT_WORKTREE="@"
        PWT_WORKTREE_PATH="$resolved_main_app"
    else
        # Default to main app
        PWT_WORKTREE="@"
        PWT_WORKTREE_PATH="${resolved_main_app:-$MAIN_APP}"
    fi

    # Get port and other metadata
    if [ "$PWT_WORKTREE" != "@" ]; then
        PWT_PORT=$(get_metadata "$PWT_WORKTREE" "port")
        PWT_BRANCH=$(get_metadata "$PWT_WORKTREE" "branch")
    else
        PWT_PORT=""
        PWT_BRANCH=$(git -C "$MAIN_APP" branch --show-current 2>/dev/null || echo "master")
    fi

    # Pass arguments to the command via environment
    export PWT_ARGS="$*"

    run_pwtfile "$cmd"
}

# Run Pwtfile commands with scope-aware behavior:
# - setup/teardown: run BOTH project AND global (additive)
# - server: run ONLY project (local only)
# - custom commands: run project if exists, else global (fallback)
run_pwtfile() {
    local phase="$1"

    # Export canonical PWT_* variables (always available)
    export PWT_PORT="${PWT_PORT:-}"
    export PWT_WORKTREE="${PWT_WORKTREE:-}"
    export PWT_WORKTREE_PATH="${PWT_WORKTREE_PATH:-}"
    export PWT_BRANCH="${PWT_BRANCH:-}"
    export PWT_TICKET="${PWT_TICKET:-}"
    export PWT_PROJECT="${PWT_PROJECT:-$CURRENT_PROJECT}"
    export PWT_ARGS="${PWT_ARGS:-}"
    export MAIN_APP="${MAIN_APP:-}"

    # Back-compat aliases (short names)
    export PORT="$PWT_PORT"
    export WORKTREE="$PWT_WORKTREE"
    export WORKTREE_PATH="$PWT_WORKTREE_PATH"
    export BRANCH="$PWT_BRANCH"
    export TICKET="$PWT_TICKET"
    export PROJECT="$PWT_PROJECT"

    # Find project Pwtfile
    local project_pwtfile=""
    local config_pwtfile=$(get_project_config "$CURRENT_PROJECT" "pwtfile")

    if [ -n "$config_pwtfile" ]; then
        config_pwtfile="${config_pwtfile/#\~/$HOME}"
        [[ "$config_pwtfile" != /* ]] && config_pwtfile="$MAIN_APP/$config_pwtfile" || true
        [ -f "$config_pwtfile" ] && project_pwtfile="$config_pwtfile" || true
    fi

    if [ -z "$project_pwtfile" ]; then
        if [ -f "$MAIN_APP/Pwtfile" ]; then
            project_pwtfile="$MAIN_APP/Pwtfile"
        elif [ -f "$MAIN_APP/Pwtfile.rb" ]; then
            project_pwtfile="$MAIN_APP/Pwtfile.rb"
        elif [ -f "$MAIN_APP/Pwtfile.js" ]; then
            project_pwtfile="$MAIN_APP/Pwtfile.js"
        fi
    fi

    local global_pwtfile="$PWT_DIR/Pwtfile"

    case "$phase" in
        setup|teardown)
            # Additive: run BOTH project and global
            [ -n "$project_pwtfile" ] && run_single_pwtfile "$project_pwtfile" "$phase" "Pwtfile" || true
            [ -f "$global_pwtfile" ] && run_single_pwtfile "$global_pwtfile" "$phase" "Global Pwtfile" || true
            ;;
        server)
            # Local only: server is project-specific
            [ -n "$project_pwtfile" ] && run_single_pwtfile "$project_pwtfile" "$phase" "Pwtfile" || true
            ;;
        *)
            # Custom commands: project > global (fallback)
            if [ -n "$project_pwtfile" ] && has_command_in_file "$project_pwtfile" "$phase"; then
                run_single_pwtfile "$project_pwtfile" "$phase" "Pwtfile"
            elif [ -f "$global_pwtfile" ] && has_command_in_file "$global_pwtfile" "$phase"; then
                run_single_pwtfile "$global_pwtfile" "$phase" "Global Pwtfile"
            fi
            ;;
    esac
}

# Run project hook if it exists
# Usage: run_hook <hook_name>
# Environment variables passed to hooks:
#   PWT_PROJECT      - Project name
#   PWT_WORKTREE     - Worktree name (directory name)
#   PWT_WORKTREE_PATH - Full path to worktree
#   PWT_BRANCH       - Git branch name
#   PWT_PORT         - Allocated port
#   PWT_TICKET       - Ticket/worktree name
#   PWT_BASE         - Base branch
#   PWT_DESC         - Description
run_hook() {
    local hook_name="$1"
    local hook_file="$PWT_PROJECTS_DIR/$CURRENT_PROJECT/hooks/$hook_name"

    [ -x "$hook_file" ] || return 0

    echo -e "${BLUE}Running $hook_name hook...${NC}"

    # Export all PWT_* variables for the hook
    export PWT_PROJECT="${PWT_PROJECT:-$CURRENT_PROJECT}"
    export PWT_WORKTREE="${PWT_WORKTREE:-}"
    export PWT_WORKTREE_PATH="${PWT_WORKTREE_PATH:-}"
    export PWT_BRANCH="${PWT_BRANCH:-}"
    export PWT_PORT="${PWT_PORT:-}"
    export PWT_TICKET="${PWT_TICKET:-}"
    export PWT_BASE="${PWT_BASE:-}"
    export PWT_DESC="${PWT_DESC:-}"

    if "$hook_file"; then
        echo -e "  ${GREEN}✓${NC} $hook_name hook completed"
        return 0
    else
        echo -e "  ${YELLOW}⚠${NC} $hook_name hook failed (exit $?)"
        return 1
    fi
}

# Legacy wrapper
run_project_hook() {
    local project="$1"
    local hook="$2"
    shift 2
    CURRENT_PROJECT="$project" run_hook "$hook"
}

# Initialize project config directory
# Usage: init_project <project_name>
init_project() {
    local project="$1"
    local project_dir="$PROJECTS_DIR/$project"

    if [ ! -d "$project_dir" ]; then
        mkdir -p "$project_dir/hooks"
        cat > "$project_dir/config.json" << 'EOF'
{
  "name": "PROJECT_NAME",
  "main_app": "",
  "worktrees_dir": "",
  "branch_prefix": "",
  "post_create_commands": [],
  "pre_remove_commands": []
}
EOF
        sed_inplace "s/PROJECT_NAME/$project/" "$project_dir/config.json"
        echo -e "${GREEN}✓ Created project config: $project_dir${NC}"
    fi
}

# Extract worktree name from branch
# Removes path prefix (feature/, user/, etc) and sanitizes for directory use
extract_worktree_name() {
    local branch="$1"
    echo "$branch" | sed -E 's|.*/||; s|[^A-Za-z0-9._-]|-|g'
}

# Alias for backwards compatibility (was pair, now single port)
# Projects needing multiple ports should derive them in Pwtfile (e.g., VITE_PORT=$((PWT_PORT+1)))
is_port_pair_free() {
    is_port_free "$1"
}

# Find next available port
# Strategy: try to reuse ports from removed worktrees before incrementing
# Note: BASE_PORT is reserved for main app, worktrees start at BASE_PORT+1
#       (Pwtfile PORT_BASE defines first worktree port, see read_port_base)
next_available_port() {
    # Collect all ports "allocated" by existing worktrees
    local -a allocated_ports=()
    local project="${CURRENT_PROJECT:-unknown}"

    # BASE_PORT is reserved for main app (worktrees use BASE_PORT+1, +2, etc.)
    allocated_ports+=("$BASE_PORT")

    # Read ports from metadata for current project (primary source)
    if [ -f "$METADATA_FILE" ]; then
        while IFS= read -r port; do
            if [[ "$port" =~ ^[0-9]+$ ]]; then
                allocated_ports+=("$port")
            fi
        done < <(jq -r --arg project "$project" '.[$project] // {} | .[].port // empty' "$METADATA_FILE" 2>/dev/null)
    fi

    # Also scan directory names (fallback for legacy worktrees without metadata)
    if [ -d "$WORKTREES_DIR" ]; then
        for dir in "$WORKTREES_DIR"/*/; do
            if [ -d "$dir" ]; then
                local dirname=$(basename "$dir")
                # Only extract port if it looks like old format (ends with -XXXX)
                if [[ "$dirname" =~ -([0-9]{4})$ ]]; then
                    local port="${BASH_REMATCH[1]}"
                    allocated_ports+=("$port")
                fi
            fi
        done
    fi

    # Find next free port, starting from BASE_PORT+1
    # Try to reuse "holes" from removed worktrees
    local candidate=$((BASE_PORT + 1))
    local max_attempts=100  # Avoid infinite loop

    for ((i=0; i<max_attempts; i++)); do
        local is_allocated=false

        # Check if port is allocated by existing worktree
        for allocated in "${allocated_ports[@]}"; do
            if [ "$candidate" -eq "$allocated" ]; then
                is_allocated=true
                break
            fi
        done

        if [ "$is_allocated" = false ]; then
            # Check if port (and Vite +1) are actually free on the system
            if is_port_pair_free "$candidate"; then
                echo "$candidate"
                return 0
            fi
        fi

        candidate=$((candidate + 1))
    done

    # Fallback: return next after all allocated
    local max_port=$BASE_PORT
    for allocated in "${allocated_ports[@]}"; do
        if [ "$allocated" -gt "$max_port" ]; then
            max_port=$allocated
        fi
    done
    echo $((max_port + 1))
}

# Check if server is running in a worktree (generic - checks port, not pidfile)
check_server_status() {
    local dir="$1"
    local port="${2:-}"

    # If port provided, check if it's in use
    if [ -n "$port" ] && [[ "$port" =~ ^[0-9]+$ ]]; then
        local pids=$(get_pids_on_port "$port")
        if [ -n "$pids" ]; then
            echo -e "${GREEN}[running]${NC} port $port"
            return
        fi
    fi
    echo -e "${YELLOW}[stopped]${NC}"
}


# Command: create
# Usage: pwt create <branch> [base-ref] [description] [options]
# Options:
#   --dry-run, -n     Show what would be created without creating
#   -e, --editor      Open editor after creating
#   -a, --ai          Start AI tool after creating
#   --from <ref>      Create from specific ref (tag, commit, branch)
#   --from-current    Create from current branch
cmd_create() {
    local branch=""
    local base_ref=""
    local description=""
    local dry_run=false
    local open_editor=false
    local start_ai=false
    local from_current=false
    local use_clone=false

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --dry-run|-n)
                dry_run=true
                shift
                ;;
            -e|--editor)
                open_editor=true
                shift
                ;;
            -a|--ai)
                start_ai=true
                shift
                ;;
            --clone)
                use_clone=true
                shift
                ;;
            --from)
                base_ref="$2"
                shift 2
                ;;
            --from-current)
                from_current=true
                shift
                ;;
            --)
                # Everything after -- is the description
                shift
                description="$*"
                break
                ;;
            -h|--help)
                echo "Usage: pwt create <branch> [base] [-- description]"
                echo ""
                echo "Arguments:"
                echo "  branch          Branch name or ticket (e.g., ACME-1234)"
                echo "  base            Base branch (default: master)"
                echo "  -- description  Optional description after --"
                echo ""
                echo "Options:"
                echo "  --from <ref>      Create from specific ref (tag, commit, branch)"
                echo "  --from-current    Create from current branch"
                echo "  --clone           Use git clone instead of worktree"
                echo "  -e, --editor      Open in editor after creation"
                echo "  -a, --ai          Start AI assistant after creation"
                echo "  -n, --dry-run     Show what would be done"
                echo "  -h, --help        Show this help"
                return 0
                ;;
            -*)
                echo -e "${RED}Unknown option: $1${NC}"
                exit 1
                ;;
            *)
                # Positional arguments: branch, base_ref, description
                if [ -z "$branch" ]; then
                    branch="$1"
                elif [ -z "$base_ref" ]; then
                    base_ref="$1"
                else
                    # Accumulate all remaining positional args as description
                    if [ -z "$description" ]; then
                        description="$1"
                    else
                        description="$description $1"
                    fi
                fi
                shift
                ;;
        esac
    done

    # Handle --from-current: use current branch as base
    if [ "$from_current" = true ]; then
        cd "$MAIN_APP"
        base_ref=$(git branch --show-current 2>/dev/null)
        if [ -z "$base_ref" ]; then
            echo -e "${RED}Error: Could not detect current branch${NC}"
            exit 1
        fi
    fi

    if [ -z "$branch" ]; then
        pwt_error "Error: Branch/ticket not specified"
        echo "Usage: pwt create <branch> [base-ref] [description...] [options]"
        echo "       pwt create <branch> [options] -- description with spaces"
        echo ""
        echo "Options:"
        echo "  --dry-run, -n     Show what would be created without creating"
        echo "  -e, --editor      Open editor after creating"
        echo "  -a, --ai          Start AI tool after creating"
        echo "  --from <ref>      Create from specific ref (tag, commit, branch)"
        echo "  --from-current    Create from current branch"
        echo "  --                Everything after is the description"
        echo ""
        echo "Examples:"
        echo "  pwt create feature/my-feature"
        echo "  pwt create PROJ-123 master"
        echo "  pwt create PROJ-123 master \"add auth flow\""
        echo "  pwt create PROJ-123 master add auth flow        # works too"
        echo "  pwt create PROJ-123 --from v1.2.3 -- hotfix for bug"
        echo "  pwt create hotfix --from-current"
        echo "  pwt create PROJ-123 master -e -a"
        exit 1
    fi

    # Ensure worktrees_dir exists
    mkdir -p "$WORKTREES_DIR"

    pwt_debug "Creating worktree: branch=$branch, base=${base_ref:-default}, from_current=${from_current:-false}"
    pwt_debug "Options: dry_run=${dry_run:-false}, open_editor=${open_editor:-false}, start_ai=${start_ai:-false}"

    # Extract worktree name from branch (removes path prefix, sanitizes)
    local worktree_name=$(extract_worktree_name "$branch")
    local worktree_dir="$WORKTREES_DIR/$worktree_name"

    # Check if worktree already exists
    if [ -d "$worktree_dir" ]; then
        echo -e "${RED}Error: Worktree already exists: $worktree_name${NC}"
        echo ""
        echo "Options:"
        echo "  1. Remove existing: pwt remove $worktree_name"
        echo "  2. Use a different branch name"
        exit $EXIT_CONFLICT
    fi

    # Read PORT_BASE from Pwtfile (if defined)
    read_port_base

    # Acquire lock to prevent port allocation race condition
    # Lock is held until metadata is saved
    if ! acquire_metadata_lock; then
        echo -e "${RED}Error: Could not acquire lock for port allocation${NC}"
        exit 1
    fi
    # Ensure lock is released on exit
    trap 'release_metadata_lock' EXIT

    # Allocate port (stored in metadata only)
    local port=$(next_available_port)

    cd "$MAIN_APP"

    # Determine if need to create new branch or use existing
    local new_branch_name=""
    local git_worktree_args=()

    if [ -n "$base_ref" ]; then
        # Base ref provided: create new branch from it
        # Format: [prefix]ticket-name or [prefix]ticket-name-description-slug
        if [ -n "$description" ]; then
            # Convert description to slug: lowercase, spaces -> hyphens, remove special chars
            local slug=$(echo "$description" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | sed 's/[^a-z0-9-]//g' | sed 's/--*/-/g' | sed 's/^-//;s/-$//')
            new_branch_name="${BRANCH_PREFIX}${worktree_name}-${slug}"
        else
            new_branch_name="${BRANCH_PREFIX}${worktree_name}"
        fi

        # Fetch base ref if remote
        if [[ "$base_ref" == origin/* ]] || [[ "$base_ref" == "master" ]] || [[ "$base_ref" == "main" ]]; then
            local remote_ref="origin/${base_ref#origin/}"
            echo -e "${BLUE}Updating reference:${NC} $remote_ref"
            git fetch origin "${base_ref#origin/}" --quiet 2>/dev/null || true
            base_ref="$remote_ref"
        fi

        local mode_label="worktree"
        [ "$use_clone" = true ] && mode_label="clone"

        echo -e "${BLUE}Creating $mode_label:${NC} $worktree_name"
        echo -e "  New branch: $new_branch_name"
        echo -e "  Base:   $base_ref"
        echo -e "  Port:   $port"
        echo -e "  Dir:    $worktree_dir"
        echo ""

        git_worktree_args=(-b "$new_branch_name" "$worktree_dir" "$base_ref")
    else
        # No base ref: use existing branch
        local mode_label="worktree"
        [ "$use_clone" = true ] && mode_label="clone"

        echo -e "${BLUE}Creating $mode_label:${NC} $worktree_name"
        echo -e "  Branch: $branch"
        echo -e "  Port:   $port"
        echo -e "  Dir:    $worktree_dir"
        echo ""

        git_worktree_args=("$worktree_dir" "$branch")
    fi

    # Dry-run mode: show what would be created without creating
    if [ "$dry_run" = true ]; then
        local mode_str="worktree"
        [ "$use_clone" = true ] && mode_str="clone"
        echo -e "${YELLOW}[DRY-RUN] Would create $mode_str with above settings${NC}"
        echo ""
        echo "Run without --dry-run to create."
        exit 0
    fi

    # Check for submodules (warn but don't block) - only for worktree mode
    if [ "$use_clone" = false ]; then
        if ! detect_submodules "$MAIN_APP"; then
            release_metadata_lock
            exit 1
        fi
    fi

    # Create workspace (worktree or clone)
    local workspace_mode="worktree"
    if [ "$use_clone" = true ]; then
        workspace_mode="clone"
        echo "Cloning repository..."
        git clone --quiet "$MAIN_APP" "$worktree_dir"

        # Checkout the correct branch
        cd "$worktree_dir"
        local final_branch="${new_branch_name:-$branch}"

        if [ -n "$new_branch_name" ]; then
            # Create new branch from base
            local checkout_base="${base_ref:-HEAD}"
            # If base is remote ref, fetch it first
            if [[ "$checkout_base" == origin/* ]]; then
                git fetch origin "${checkout_base#origin/}" --quiet 2>/dev/null || true
            fi
            git checkout -b "$new_branch_name" "$checkout_base" --quiet 2>/dev/null || \
                git checkout -b "$new_branch_name" "origin/${checkout_base#origin/}" --quiet 2>/dev/null || \
                git checkout -b "$new_branch_name" --quiet
        else
            # Checkout existing branch
            git checkout "$branch" --quiet 2>/dev/null || \
                git checkout -b "$branch" "origin/$branch" --quiet 2>/dev/null || true
        fi
        cd - > /dev/null
        echo -e "  ${GREEN}✓ Clone created${NC}"
    else
        # Create worktree (original logic)
        git worktree add "${git_worktree_args[@]}"
    fi

    # Save metadata
    local final_branch="${new_branch_name:-$branch}"
    local final_base="${base_ref:-master}"
    local final_base_commit=$(git -C "$worktree_dir" merge-base HEAD "origin/${final_base#origin/}" 2>/dev/null || git -C "$worktree_dir" rev-parse HEAD 2>/dev/null)
    local final_base_short=$(git -C "$worktree_dir" rev-parse --short "$final_base_commit" 2>/dev/null || echo "?")
    local final_desc="${description:-}"

    save_metadata "$worktree_name" "$worktree_dir" "$final_branch" "$final_base" "$final_base_short" "$port" "$final_desc" "$workspace_mode"
    echo -e "  ${GREEN}✓ Metadata saved${NC}"

    # Release port allocation lock now that metadata is saved
    release_metadata_lock
    trap - EXIT  # Clear the exit trap

    # Set context for Pwtfile and hooks
    export PWT_WORKTREE="$worktree_name"
    export PWT_WORKTREE_PATH="$worktree_dir"
    export PWT_BRANCH="$final_branch"
    export PWT_PORT="$port"
    export PWT_TICKET="$worktree_name"  # User can customize via Pwtfile
    export PWT_BASE="$final_base"
    export PWT_DESC="$final_desc"
    export PWT_PROJECT="$CURRENT_PROJECT"
    export MAIN_APP="$MAIN_APP"

    # Run Pwtfile setup (if exists), then hook
    run_pwtfile "setup"
    run_hook "post-create"

    # Auto-set as current worktree (non-fatal)
    set_current_worktree "$worktree_name" 2>/dev/null || true

    local mode_label="Worktree"
    [ "$workspace_mode" = "clone" ] && mode_label="Clone" || true

    echo -e "\n${GREEN}✓ $mode_label created successfully!${NC}"
    clear_list_cache  # Invalidate cache so next list shows new worktree
    echo ""
    echo -e "${BLUE}Next steps:${NC}"
    echo ""
    echo -e "  Navigate:    ${DIM}pwt cd ${worktree_name}${NC}  or  ${DIM}cd $worktree_dir${NC}"
    echo -e "  Open editor: ${DIM}pwt editor ${worktree_name}${NC}"
    echo -e "  Start AI:    ${DIM}pwt ai ${worktree_name}${NC}"
    echo -e "  Run server:  ${DIM}pwt server ${worktree_name}${NC}  (port ${port})"
    echo ""
    echo -e "  ${DIM}Tip: Set as current with 'pwt use ${worktree_name}' for quick access${NC}"

    # Open editor if requested
    if [ "$open_editor" = true ]; then
        echo ""
        cmd_editor "$worktree_name"
    fi

    # Start AI tool if requested
    if [ "$start_ai" = true ]; then
        echo ""
        cmd_ai "$worktree_name"
    fi

    return 0
}

# Check port status for a worktree
# Arguments: port [worktree_dir]
# Returns: colored text with status
check_port_status() {
    local port="$1"
    local worktree_dir="${2:-}"

    if ! [[ "$port" =~ ^[0-9]+$ ]]; then
        echo -e "${YELLOW}[port ?]${NC}"
        return
    fi

    # Without lsof, we can't check port status
    if ! has_lsof; then
        echo -e "${YELLOW}[port $port]${NC}"
        return
    fi

    local pids=$(get_pids_on_port "$port")

    # If no port occupied, it's free
    if [ -z "$pids" ]; then
        echo -e "${GREEN}[port $port free]${NC}"
        return
    fi

    # Port is in use - get process info
    local first_pid=$(echo "$pids" | head -1)
    local proc=$(ps -p "$first_pid" -o comm= 2>/dev/null || echo "?")
    local proc_path=$(ps -p "$first_pid" -o command= 2>/dev/null || echo "")

    # Filter out known system processes (not dev servers)
    # These commonly bind to ports but aren't related to development
    local is_system_process=false
    case "$proc" in
        ControlCenter|controlcenter|rapportd|AirPlayXPCHelper|sharingd)
            is_system_process=true
            ;;
    esac
    # Also check if it's a system path
    if [[ "$proc_path" == /System/* ]] || [[ "$proc_path" == /usr/libexec/* ]]; then
        is_system_process=true
    fi

    if [ "$is_system_process" = true ]; then
        # System process on this port - treat as if port is available for dev
        echo -e "${YELLOW}[port $port: system]${NC}"
    else
        echo -e "${GREEN}[port $port: $proc]${NC}"
    fi
}

# Prefetch remote refs once (for list performance)
# Call this before looping through worktrees
prefetch_remote_refs() {
    if [ "$LIST_QUICK_MODE" = true ]; then
        return 0  # Skip in quick mode
    fi
    if [ "$PREFETCH_DONE" = true ]; then
        return 0  # Already fetched
    fi
    if [ ! -d "$MAIN_APP" ]; then
        return 0  # No main app
    fi

    cd "$MAIN_APP"
    # Fetch only default branch (faster than --prune which fetches all)
    local target="${DEFAULT_BRANCH:-master}"
    git fetch origin "$target" --quiet 2>/dev/null || true
    PREFETCH_DONE=true
}

# Check if branch is merged into master
# IMPORTANT: Also checks for uncommitted changes to avoid data loss
check_merge_status() {
    local dir="$1"
    local target="${2:-master}"
    local wt_commit=$(git -C "$dir" rev-parse HEAD 2>/dev/null)

    if [ -z "$wt_commit" ]; then
        echo -e "${RED}[corrupted]${NC}"
        return
    fi

    # Check for uncommitted changes (staged, modified, or untracked)
    local has_changes=false
    local git_status=$(git -C "$dir" status --porcelain 2>/dev/null)
    if [ -n "$git_status" ]; then
        has_changes=true
    fi

    # If there are uncommitted changes, ALWAYS show as open (unsafe to remove)
    if [ "$has_changes" = true ]; then
        echo -e "${YELLOW}[has changes]${NC}"
        return
    fi

    # Note: Assumes prefetch_remote_refs() was called before the loop
    # (performance: fetch once instead of per-worktree)
    cd "$MAIN_APP"

    if git merge-base --is-ancestor "$wt_commit" "origin/$target" 2>/dev/null; then
        # Check if branch ever diverged from target
        # If merge-base equals HEAD, branch never had unique commits
        local merge_base=$(git -C "$dir" merge-base HEAD "origin/$target" 2>/dev/null)
        if [ "$merge_base" = "$wt_commit" ]; then
            # Branch never diverged - no work done yet
            echo -e "${BLUE}[clean]${NC}"
        else
            # Branch had commits that are now in target
            echo -e "${GREEN}[merged]${NC}"
        fi
    else
        echo -e "${YELLOW}[open]${NC}"
    fi
}

# Command: list (porcelain output)
# Internal function for JSON output (uses jq for proper escaping)
cmd_list_porcelain() {
    local show_dirty_only="${1:-false}"
    local worktrees_json="[]"

    if [ -d "$WORKTREES_DIR" ] && [ "$(ls -A "$WORKTREES_DIR" 2>/dev/null)" ]; then
        for dir in "$WORKTREES_DIR"/*/; do
            [ -d "$dir" ] || continue

            local name=$(basename "$dir")
            local port=$(get_metadata "$name" "port")
            local branch=$(git -C "$dir" branch --show-current 2>/dev/null || echo "detached")
            local commit=$(git -C "$dir" rev-parse --short HEAD 2>/dev/null || echo "?")

            # Check for uncommitted changes
            local is_dirty=false
            local staged=$(git -C "$dir" diff --cached --numstat 2>/dev/null | wc -l | tr -d ' ')
            local unstaged=$(git -C "$dir" diff --numstat 2>/dev/null | wc -l | tr -d ' ')
            local untracked=$(git -C "$dir" ls-files --others --exclude-standard 2>/dev/null | wc -l | tr -d ' ')
            if [ "$staged" -gt 0 ] || [ "$unstaged" -gt 0 ] || [ "$untracked" -gt 0 ]; then
                is_dirty=true
            fi

            # Skip if --dirty and not dirty
            if [ "$show_dirty_only" = true ] && [ "$is_dirty" = false ]; then
                continue
            fi

            local meta_base=$(get_metadata "$name" "base")
            local meta_desc=$(get_metadata "$name" "description")

            # Build worktree JSON object with proper escaping via jq
            local wt_json
            wt_json=$(jq -n \
                --arg name "$name" \
                --arg path "$dir" \
                --arg branch "$branch" \
                --arg commit "$commit" \
                --arg port "${port:-}" \
                --argjson dirty "$is_dirty" \
                --arg base "${meta_base:-}" \
                --arg description "${meta_desc:-}" \
                '{name: $name, path: $path, branch: $branch, commit: $commit, port: $port, dirty: $dirty, base: $base, description: $description}')

            # Append to array
            worktrees_json=$(echo "$worktrees_json" | jq --argjson wt "$wt_json" '. + [$wt]')
        done
    fi

    # Output final JSON with proper escaping
    jq -n \
        --arg project "$CURRENT_PROJECT" \
        --arg main_app "$MAIN_APP" \
        --arg worktrees_dir "$WORKTREES_DIR" \
        --argjson worktrees "$worktrees_json" \
        '{project: $project, main_app: $main_app, worktrees_dir: $worktrees_dir, worktrees: $worktrees}'
}

# Command: list
# Usage: pwt list [--dirty] [--porcelain] [--names]
cmd_list() {
    local show_dirty_only=false
    local porcelain=false
    local verbose=false
    local statusline=false
    local names_only=false

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            -h|--help)
                echo "Usage: pwt list [options]"
                echo ""
                echo "List all worktrees for the current project."
                echo ""
                echo "Options:"
                echo "  -d, --dirty      Only show dirty worktrees"
                echo "  -v, --verbose    Show detailed info (original format)"
                echo "  -q, --quick      Skip network operations (faster)"
                echo "  -r, --refresh    Force refresh cache"
                echo "  --porcelain      Output JSON (for scripts)"
                echo "  --names          Output only worktree names (for completions)"
                echo "  statusline       Compact single-line for prompts"
                echo ""
                echo "Examples:"
                echo "  pwt list              # Default tabular view"
                echo "  pwt list -d           # Only dirty worktrees"
                echo "  pwt list --porcelain  # JSON output"
                echo "  pwt list --names      # Just names (for shell completion)"
                return 0
                ;;
            -d|--dirty)
                show_dirty_only=true
                shift
                ;;
            --porcelain)
                porcelain=true
                shift
                ;;
            --verbose|-v)
                verbose=true
                shift
                ;;
            -q|--quick)
                LIST_QUICK_MODE=true
                shift
                ;;
            -r|--refresh)
                LIST_REFRESH_MODE=true
                shift
                ;;
            --names)
                names_only=true
                shift
                ;;
            statusline)
                statusline=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    # Names-only mode: output worktree names for shell completions
    if [ "$names_only" = true ]; then
        cmd_list_names
        return
    fi

    # Statusline mode: compact single-line for prompts
    if [ "$statusline" = true ]; then
        cmd_list_statusline
        return
    fi

    # Porcelain mode: output JSON
    if [ "$porcelain" = true ]; then
        cmd_list_porcelain "$show_dirty_only"
        return
    fi

    # Verbose mode: detailed output (original format)
    if [ "$verbose" = true ]; then
        cmd_list_verbose "$show_dirty_only"
        return
    fi

    # Default: compact tabular format with caching
    # Cache logic: first run slow (builds cache), subsequent runs fast (uses cache)
    # Cache always stores FULL list (no -d filter); -d filter applied on read

    local cache_file
    cache_file=$(get_list_cache_file)

    # Helper to read cache (with optional dirty filter)
    read_cache() {
        if [ "$show_dirty_only" = true ]; then
            read_list_cache_filtered
        else
            cat "$cache_file"
        fi
    }

    # Helper to generate cache (always full list, no -d filter)
    generate_cache() {
        init_cache_dir
        cmd_list_compact "" > "$cache_file"
    }

    # --refresh: clear cache and regenerate
    if [ "$LIST_REFRESH_MODE" = true ]; then
        clear_list_cache
        generate_cache
        read_cache
        return
    fi

    # --quick: always use cache if exists (even if stale)
    if [ "$LIST_QUICK_MODE" = true ]; then
        if [ -f "$cache_file" ]; then
            read_cache
            return
        fi
        # No cache, generate (but still skip network via LIST_QUICK_MODE)
        generate_cache
        read_cache
        return
    fi

    # Default: use cache if valid, else regenerate
    if is_list_cache_valid; then
        read_cache
    else
        generate_cache
        read_cache
    fi
}

# Print a table row with fixed column widths
# Usage: print_table_row <marker> <name> <branch> <hash> <base> <stat> <main_div> <remote_div> <age> <meta>
print_table_row() {
    local marker="$1"
    local name="$2"
    local branch="$3"
    local hash="$4"
    local base="$5"
    local stat="$6"
    local main_div="$7"
    local remote_div="$8"
    local age="$9"
    local meta="${10}"

    # Build row with proper visual padding for Unicode columns
    # Format: marker(2) name(20) branch(40) hash(8) base(8) stat(4) main(10) remote(10) age(4) meta
    printf "  %-2s " "$marker"
    pad_visual "${name:0:20}" 20
    printf " "
    pad_visual "${branch:0:40}" 40
    printf " "
    printf "%-8s " "${hash:0:8}"
    pad_visual "${base:0:8}" 8
    printf " "
    printf "%-4s " "${stat:-·}"
    pad_visual "${main_div:-·}" 10
    printf " "
    pad_visual "${remote_div:-·}" 10
    printf " "
    printf "%-4s " "$age"
    printf "%s\n" "$meta"
}

# Compact tabular list format (default)
cmd_list_compact() {
    local show_dirty_only="${1:-false}"

    # If project not cloned, show helpful message and exit
    if [ ! -d "$MAIN_APP" ]; then
        echo -e "${BLUE}${CURRENT_PROJECT}${NC}: ${YELLOW}not cloned${NC}"
        [ -n "$PROJECT_REMOTE" ] && echo -e "  Run: ${GREEN}pwt clone${NC}"
        return 0
    fi

    echo -e "${BLUE}${CURRENT_PROJECT}${NC}"
    echo ""

    # Print header
    print_table_row "" "Worktree" "Branch" "Hash" "Base" "Stat" "main↕" "Remote" "Age" "Meta"
    print_table_row "--" "--------------------" "----------------------------------------" "--------" "--------" "----" "----------" "----------" "----" "--------------------"

    # Main app row
    local main_branch=$(git -C "$MAIN_APP" branch --show-current 2>/dev/null || echo "?")
    local main_hash=$(get_short_hash "$MAIN_APP")
    local main_status=$(get_status_symbols "$MAIN_APP")
    local main_age_ts=$(git -C "$MAIN_APP" log -1 --format=%ct 2>/dev/null || echo "0")
    local main_age=$(format_relative_time "$main_age_ts")
    local main_remote=$(get_remote_divergence "$MAIN_APP")

    # Check if main is current
    local main_marker=" "
    if [ "$PWD" = "$MAIN_APP" ]; then
        main_marker="@"
    elif is_previous_worktree "$MAIN_APP"; then
        main_marker="*"
    fi

    print_table_row "$main_marker" "@" "$main_branch" "$main_hash" "·" "${main_status:-·}" "·" "${main_remote:-·}" "$main_age" "description=main application"

    # Prefetch remote refs once (performance: avoids N fetches in loop)
    prefetch_remote_refs

    # Worktrees
    local has_merged=false
    if [ -d "$WORKTREES_DIR" ] && [ "$(ls -A "$WORKTREES_DIR" 2>/dev/null)" ]; then
        for dir in "$WORKTREES_DIR"/*/; do
            [ -d "$dir" ] || continue
            local name=$(basename "$dir")

            # Git info
            local branch=$(git -C "$dir" branch --show-current 2>/dev/null || echo "detached")
            local hash=$(get_short_hash "$dir")
            local base=$(get_base_branch "$name" "$dir")

            # Status symbols
            local status=$(get_status_symbols "$dir")
            local is_dirty=false
            [ -n "$status" ] && is_dirty=true

            # Skip if --dirty and not dirty
            if [ "$show_dirty_only" = true ] && [ "$is_dirty" = false ]; then
                continue
            fi

            # Divergence from main
            local main_div=$(get_divergence "$dir" "origin/${DEFAULT_BRANCH:-master}")

            # Remote divergence
            local remote_div=$(get_remote_divergence "$dir")

            # Age
            local age_ts=$(git -C "$dir" log -1 --format=%ct 2>/dev/null || echo "0")
            local age=$(format_relative_time "$age_ts")

            # Markers: @ = current, * = previous
            local marker=" "
            if [ "$PWD" = "${dir%/}" ]; then
                marker="@"
            elif is_previous_worktree "${dir%/}"; then
                marker="*"
            fi

            # Check merge status for tips
            local merge_status=$(check_merge_status "$dir" "${DEFAULT_BRANCH:-master}" 2>/dev/null)
            if [[ "$merge_status" == *"merged"* ]] || [[ "$merge_status" == *"clean"* ]]; then
                has_merged=true
            fi

            # Build meta string from metadata (includes port, description, custom fields)
            local meta=$(get_extra_metadata "$name")

            # If no description in metadata, generate fallback
            if [[ "$meta" != *"description="* ]]; then
                local desc=""
                # Extract from branch name
                if [[ "$branch" =~ ^[^/]+/[A-Z]+-[0-9]+-(.*) ]]; then
                    desc=$(echo "${BASH_REMATCH[1]}" | tr '-' ' ')
                elif [[ ! "$branch" =~ ^[^/]+/[A-Z]+-[0-9]+$ ]]; then
                    if [[ "$branch" =~ ^[^/]+/(.+) ]]; then
                        desc=$(echo "${BASH_REMATCH[1]}" | tr '-' ' ')
                    fi
                fi
                # Fallback to commit message
                if [ -z "$desc" ]; then
                    desc=$(git -C "$dir" log --oneline --no-merges -1 --format=%s 2>/dev/null | head -c 40)
                fi
                [ -n "$desc" ] && meta="$meta description=$desc"
            fi

            [ -z "$meta" ] && meta="·"

            print_table_row "$marker" "$name" "$branch" "$hash" "$base" "${status:-·}" "${main_div:-·}" "${remote_div:-·}" "$age" "$meta"
        done
    fi

    echo ""

    # Tips
    if [ "$has_merged" = true ]; then
        echo -e "${YELLOW}Tip:${NC} Run ${GREEN}pwt auto-remove${NC} to clean up merged worktrees"
    fi

    # Legend
    echo -e "${BLUE}Legend:${NC} @ current  * previous  + staged  ! modified  ? untracked"
}

# Names-only output for shell completions
# Usage: pwt list --names
# Output: one worktree name per line with trailing / (directory style)
cmd_list_names() {
    # Always output @ for main app (with / to look like directory)
    echo "@/"

    # Output worktree names with trailing /
    if [ -d "$WORKTREES_DIR" ] && [ "$(ls -A "$WORKTREES_DIR" 2>/dev/null)" ]; then
        for dir in "$WORKTREES_DIR"/*/; do
            [ -d "$dir" ] || continue
            local name=$(basename "$dir")
            echo "$name/"
        done
    fi
}

# Statusline for shell prompts
# Usage: pwt list statusline
# Output: [TICKET-123 +! ↑3 ⇡2] or empty if in main
cmd_list_statusline() {
    # Only show if in a worktree
    local worktree=""
    local dir=""

    if [ -n "${PWT_WORKTREE:-}" ]; then
        worktree="$PWT_WORKTREE"
        dir="$WORKTREES_DIR/$worktree"
    else
        # Try to detect from PWD
        if [[ "$PWD" == *"-worktrees/"* ]]; then
            worktree=$(basename "$PWD")
            dir="$PWD"
        else
            # In main app or not in worktree - output nothing
            return 0
        fi
    fi

    [ ! -d "$dir" ] && return 0

    local status=$(get_status_symbols "$dir")
    local main_div=$(get_divergence "$dir" "origin/${DEFAULT_BRANCH:-master}")
    local remote_div=$(get_remote_divergence "$dir")

    # Build statusline
    local parts=()
    parts+=("$worktree")
    [ -n "$status" ] && parts+=("$status")
    [ -n "$main_div" ] && parts+=("$main_div")
    [ -n "$remote_div" ] && parts+=("$remote_div")

    echo "[${parts[*]}]"
}

# Verbose list format (original detailed format)
cmd_list_verbose() {
    local show_dirty_only="${1:-false}"

    echo -e "${BLUE}Worktrees (${CURRENT_PROJECT}):${NC}\n"

    # Show config info
    echo -e "  ${BLUE}Config:${NC}"

    # Project path
    if [ -d "$MAIN_APP" ]; then
        echo -e "    Path:      $MAIN_APP"
    else
        echo -e "    Path:      ${YELLOW}$MAIN_APP (not cloned)${NC}"
        [ -n "$PROJECT_REMOTE" ] && echo -e "    Remote:    $PROJECT_REMOTE"
    fi

    # Worktrees directory
    echo -e "    Worktrees: $WORKTREES_DIR"

    # Pwtfiles (show all that would be used)
    local pwtfiles=()
    local config_pwtfile=$(get_project_config "$CURRENT_PROJECT" "pwtfile")
    if [ -n "$config_pwtfile" ]; then
        config_pwtfile="${config_pwtfile/#\~/$HOME}"
        [[ "$config_pwtfile" != /* ]] && config_pwtfile="$MAIN_APP/$config_pwtfile"
        if [ -f "$config_pwtfile" ]; then
            pwtfiles+=("$config_pwtfile (config)")
        else
            pwtfiles+=("${config_pwtfile} ${YELLOW}(config, missing)${NC}")
        fi
    fi
    if [ -f "$MAIN_APP/Pwtfile" ]; then
        pwtfiles+=("$MAIN_APP/Pwtfile (local)")
    fi
    if [ -f "$PWT_DIR/Pwtfile" ]; then
        pwtfiles+=("$PWT_DIR/Pwtfile (global)")
    fi

    if [ ${#pwtfiles[@]} -gt 0 ]; then
        echo -e "    Pwtfile:   ${pwtfiles[0]}"
        for ((i=1; i<${#pwtfiles[@]}; i++)); do
            echo -e "               ${pwtfiles[$i]}"
        done
    else
        echo -e "    Pwtfile:   ${YELLOW}(none)${NC}"
    fi
    echo ""

    # If project not cloned, show helpful message and exit
    if [ ! -d "$MAIN_APP" ]; then
        echo -e "  ${YELLOW}Project not cloned.${NC}"
        if [ -n "$PROJECT_REMOTE" ]; then
            echo -e "  Run: ${GREEN}pwt clone${NC} to clone from remote"
        fi
        echo ""
        return 0
    fi

    # Main app - also used as default target for merge status
    local main_branch=$(git -C "$MAIN_APP" branch --show-current 2>/dev/null || echo "?")
    local default_target="${main_branch:-master}"
    local main_commit=$(git -C "$MAIN_APP" rev-parse --short HEAD 2>/dev/null || echo "?")
    echo -e "  ${YELLOW}${CURRENT_PROJECT}${NC} (main)"
    echo -e "    Branch: $main_branch @ $main_commit"
    echo -n "    Server: "
    check_server_status "$MAIN_APP"
    echo -n "    Port:   "
    check_port_status 5000 "$MAIN_APP"
    echo ""

    # Worktrees
    local has_port_issues=false
    local has_merged=false
    if [ -d "$WORKTREES_DIR" ] && [ "$(ls -A "$WORKTREES_DIR" 2>/dev/null)" ]; then
        for dir in "$WORKTREES_DIR"/*/; do
            if [ -d "$dir" ]; then
                local name=$(basename "$dir")

                # Get port from metadata first, fallback to extracting from name
                local port=$(get_metadata "$name" "port")
                if [ -z "$port" ]; then
                    # Legacy: extract from directory name if ends with -XXXX
                    if [[ "$name" =~ -([0-9]{4})$ ]]; then
                        port="${BASH_REMATCH[1]}"
                    fi
                fi

                # Git info
                local branch=$(git -C "$dir" branch --show-current 2>/dev/null || echo "detached")
                local commit=$(git -C "$dir" rev-parse --short HEAD 2>/dev/null || echo "?")
                local upstream=$(git -C "$dir" rev-parse --abbrev-ref "${branch}@{upstream}" 2>/dev/null || echo "")

                # Get metadata (if exists)
                local meta_base=$(get_metadata "$name" "base")
                local meta_base_commit=$(get_metadata "$name" "base_commit")
                local meta_desc=$(get_metadata "$name" "description")

                # Find base branch info
                local base_name=""
                local base_short=""
                local base_ahead=""

                if [ -n "$meta_base" ]; then
                    # Use metadata for base
                    base_name="$meta_base"
                    base_short="$meta_base_commit"
                    # Calculate ahead/behind from current base
                    local base_ref="origin/${meta_base#origin/}"
                    local base_commit=$(git -C "$dir" merge-base HEAD "$base_ref" 2>/dev/null)
                    if [ -n "$base_commit" ]; then
                        local commits_ahead=$(git -C "$dir" rev-list --count "${base_commit}..HEAD" 2>/dev/null || echo "0")
                        local commits_behind=$(git -C "$dir" rev-list --count "HEAD..$base_ref" 2>/dev/null || echo "0")
                        if [ "$commits_ahead" -gt 0 ] || [ "$commits_behind" -gt 0 ]; then
                            base_ahead=" (↑${commits_ahead} ↓${commits_behind})"
                        fi
                    fi
                else
                    # Fallback: calculate merge-base with default branch
                    base_name="${DEFAULT_BRANCH:-master}"
                    local base_commit=$(git -C "$dir" merge-base HEAD "origin/${DEFAULT_BRANCH:-master}" 2>/dev/null)
                    if [ -n "$base_commit" ]; then
                        base_short=$(git -C "$dir" rev-parse --short "$base_commit" 2>/dev/null)
                        local commits_ahead=$(git -C "$dir" rev-list --count "${base_commit}..HEAD" 2>/dev/null || echo "0")
                        local commits_behind=$(git -C "$dir" rev-list --count "HEAD..origin/${DEFAULT_BRANCH:-master}" 2>/dev/null || echo "0")
                        if [ "$commits_ahead" -gt 0 ] || [ "$commits_behind" -gt 0 ]; then
                            base_ahead=" (↑${commits_ahead} ↓${commits_behind})"
                        fi
                    fi
                fi

                # Get description from metadata or extract from branch name
                local desc=""
                if [ -n "$meta_desc" ]; then
                    desc="$meta_desc"
                elif [ -n "$branch" ] && [ "$branch" != "detached" ]; then
                    desc=$(echo "$branch" | sed -E 's|^[a-z]+/||')
                    desc=$(echo "$desc" | tr '-' ' ')
                fi

                # Check for uncommitted changes
                local changes=""
                local is_dirty=false
                local staged=$(git -C "$dir" diff --cached --numstat 2>/dev/null | wc -l | tr -d ' ')
                local unstaged=$(git -C "$dir" diff --numstat 2>/dev/null | wc -l | tr -d ' ')
                local untracked=$(git -C "$dir" ls-files --others --exclude-standard 2>/dev/null | wc -l | tr -d ' ')
                if [ "$staged" -gt 0 ] || [ "$unstaged" -gt 0 ] || [ "$untracked" -gt 0 ]; then
                    is_dirty=true
                    local parts=()
                    [ "$staged" -gt 0 ] && parts+=("${staged} staged")
                    [ "$unstaged" -gt 0 ] && parts+=("${unstaged} modified")
                    [ "$untracked" -gt 0 ] && parts+=("${untracked} untracked")
                    changes=$(IFS=', '; echo "${parts[*]}")
                fi

                # Skip if --dirty and not dirty
                if [ "$show_dirty_only" = true ] && [ "$is_dirty" = false ]; then
                    continue
                fi

                # Title with description
                if [ -n "$desc" ]; then
                    echo -e "  ${YELLOW}$name${NC} - ${desc}"
                else
                    echo -e "  ${YELLOW}$name${NC}"
                fi

                # Branch and commit
                echo -e "    Branch: $branch @ $commit"

                # Base (where it was created from)
                if [ -n "$base_short" ]; then
                    echo -e "    Base:   $base_name @ $base_short$base_ahead"
                fi

                # Upstream/target only if different from "origin/<branch>" (i.e., meaningful)
                if [ -n "$upstream" ] && [ "$upstream" != "origin/$branch" ] && [ "$upstream" != "origin/${DEFAULT_BRANCH:-master}" ]; then
                    echo -e "    Target: $upstream"
                fi

                # Uncommitted changes
                if [ -n "$changes" ]; then
                    echo -e "    Changes: ${YELLOW}$changes${NC}"
                fi

                # Server status
                echo -n "    Server: "
                check_server_status "$dir"

                # Port status
                echo -n "    Port:   "
                local port_status=$(check_port_status "$port" "$dir")
                echo -e "$port_status"
                if [[ "$port_status" == *"conflict"* ]]; then
                    has_port_issues=true
                fi

                # Merge status
                echo -n "    Status: "
                local merge_status=$(check_merge_status "$dir" "$default_target")
                echo -e "$merge_status"
                if [[ "$merge_status" == *"merged"* ]] || [[ "$merge_status" == *"clean"* ]]; then
                    has_merged=true
                fi
                echo ""
            fi
        done
    else
        echo -e "  ${YELLOW}(no worktrees created)${NC}"
        echo ""
    fi

    # Tips
    if [ "$has_port_issues" = true ]; then
        echo -e "${YELLOW}Tip:${NC} Use ${GREEN}pwt fix-port <worktree>${NC} to resolve occupied ports"
    fi
    if [ "$has_merged" = true ]; then
        echo -e "${YELLOW}Tip:${NC} Use ${GREEN}pwt auto-remove${NC} to clean up merged worktrees"
    fi
    if [ "$has_port_issues" = false ] && [ "$has_merged" = false ]; then
        echo ""
    fi
}

# Command: tree
# Visual tree view of worktrees - mental map of active work
# Usage: pwt tree [--all] [--dirty] [--ports] [--short]
cmd_tree() {
    local show_all=false
    local show_dirty_only=false
    local show_ports=false
    local short_mode=false

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --all|-a)
                show_all=true
                shift
                ;;
            --dirty|-d)
                show_dirty_only=true
                shift
                ;;
            --ports|-p)
                show_ports=true
                shift
                ;;
            --short|-s)
                short_mode=true
                shift
                ;;
            -h|--help)
                echo "Usage: pwt tree [--all] [--dirty] [--ports] [--short]"
                echo ""
                echo "Visual tree view of worktrees - mental map of active work."
                echo ""
                echo "Options:"
                echo "  --all, -a     Show all projects (global view)"
                echo "  --dirty, -d   Show only dirty worktrees"
                echo "  --ports, -p   Show port mappings"
                echo "  --short, -s   One line per worktree"
                echo ""
                echo "Examples:"
                echo "  pwt tree              # current project"
                echo "  pwt tree --all        # all projects"
                echo "  pwt tree --dirty      # only dirty worktrees"
                echo "  pwt tree --ports      # show ports"
                return 0
                ;;
            *)
                echo -e "${RED}Unknown option: $1${NC}" >&2
                return 1
                ;;
        esac
    done

    # Helper to render a project tree
    _render_project_tree() {
        local project="$1"
        local project_dir="$PROJECTS_DIR/$project"
        local config_file="$project_dir/config.json"
        local main_app=""
        local worktrees_dir=""

        # Try to get paths from config file first, fall back to global vars
        if [ -f "$config_file" ]; then
            main_app=$(jq -r '.path // empty' "$config_file")
            worktrees_dir=$(jq -r '.worktrees_dir // empty' "$config_file")
        fi

        # Fall back to global variables (for auto-detected projects)
        [ -z "$main_app" ] && main_app="$MAIN_APP"
        [ -z "$worktrees_dir" ] && worktrees_dir="$WORKTREES_DIR"

        [ -d "$main_app" ] || return

        # Project header
        echo -e "${YELLOW}${project}/${NC}"

        # Main app
        local main_branch=$(git -C "$main_app" branch --show-current 2>/dev/null || echo "?")
        local main_status=""
        if [ -n "$(git -C "$main_app" status --porcelain 2>/dev/null)" ]; then
            main_status=" ${RED}*${NC}"
        fi
        if [ "$short_mode" = true ]; then
            echo -e "├─ ${GREEN}@${NC} main ($main_branch)$main_status"
        else
            echo -e "├─ ${GREEN}@${NC} (main)"
            echo -e "│  └─ $main_branch$main_status"
        fi

        # Worktrees
        if [ -d "$worktrees_dir" ] && [ "$(ls -A "$worktrees_dir" 2>/dev/null)" ]; then
            local wt_dirs=("$worktrees_dir"/*/)
            local wt_count=${#wt_dirs[@]}
            local i=0

            for dir in "${wt_dirs[@]}"; do
                [ -d "$dir" ] || continue
                i=$((i + 1))

                local name=$(basename "$dir")
                local branch=$(git -C "$dir" branch --show-current 2>/dev/null || echo "detached")
                local desc=$(get_metadata "$name" "description" 2>/dev/null)
                local port=$(get_metadata "$name" "port" 2>/dev/null)

                # Status
                local status_text=""
                local is_dirty=false
                if [ -n "$(git -C "$dir" status --porcelain 2>/dev/null)" ]; then
                    local dirty_count=$(git -C "$dir" status --porcelain 2>/dev/null | wc -l | tr -d ' ')
                    status_text=" ${RED}*${dirty_count}${NC}"
                    is_dirty=true
                fi

                # Skip if --dirty and not dirty
                if [ "$show_dirty_only" = true ] && [ "$is_dirty" = false ]; then
                    continue
                fi

                # Current marker
                local current_marker=""
                local current_name=$(get_current_from_symlink 2>/dev/null)
                if [ "$name" = "$current_name" ]; then
                    current_marker=" ${BLUE}[current]${NC}"
                fi

                # Tree connector
                local connector="├─"
                if [ $i -eq $wt_count ]; then
                    connector="└─"
                fi

                # Port info
                local port_text=""
                if [ "$show_ports" = true ] && [ -n "$port" ]; then
                    port_text=" :$port"
                fi

                if [ "$short_mode" = true ]; then
                    echo -e "$connector $branch$port_text$status_text$current_marker"
                else
                    echo -e "$connector ${GREEN}$name${NC}$current_marker"
                    [ -n "$desc" ] && echo -e "│  ├─ \"$desc\""
                    echo -e "│  ├─ $branch$port_text"
                    echo -e "│  └─ status:$status_text${status_text:- ${GREEN}clean${NC}}"
                fi
            done
        else
            echo -e "└─ ${DIM}(no worktrees)${NC}"
        fi

        echo ""
    }

    init_metadata

    if [ "$show_all" = true ]; then
        # Global view - all projects
        echo -e "${DIM}~/.pwt/projects/${NC}"
        echo ""
        for project_dir in "$PROJECTS_DIR"/*/; do
            [ -d "$project_dir" ] || continue
            local project=$(basename "$project_dir")
            _render_project_tree "$project"
        done
    else
        # Current project only
        require_project
        _render_project_tree "$CURRENT_PROJECT"
    fi
}

# Command: repair
# Runs post-create hook on worktrees (project-specific repairs via Pwtfile)
cmd_repair() {
    local name="$1"

    if [ -n "$name" ]; then
        # Repair specific worktree
        local worktree_dir="$WORKTREES_DIR/$name"
        if [ ! -d "$worktree_dir" ]; then
            echo -e "${RED}Error: Worktree not found: $name${NC}"
            exit $EXIT_NOT_FOUND
        fi
        echo -e "${BLUE}Repairing: $name${NC}"
        export PWT_WORKTREE="$name"
        export PWT_WORKTREE_PATH="$worktree_dir"
        cd "$worktree_dir"
        run_pwtfile "repair"
        run_hook "repair"
    else
        # Repair all worktrees
        echo -e "${BLUE}Repairing all worktrees...${NC}\n"

        if [ -d "$WORKTREES_DIR" ] && [ "$(ls -A "$WORKTREES_DIR" 2>/dev/null)" ]; then
            for dir in "$WORKTREES_DIR"/*/; do
                [ -d "$dir" ] || continue
                local wt_name=$(basename "$dir")
                echo -e "  ${YELLOW}$wt_name${NC}"
                export PWT_WORKTREE="$wt_name"
                export PWT_WORKTREE_PATH="$dir"
                cd "$dir"
                run_pwtfile "repair"
                run_hook "repair"
            done
        fi

        echo ""
        echo -e "${GREEN}Done!${NC}"
    fi
}

# Command: auto-remove (cleanup merged worktrees)
# Usage: pwt auto-remove [target] [--execute] [--dry-run]
# SAFETY: Dry-run by default. Must pass --execute to actually remove.
cmd_auto_remove() {
    local target_branch=""
    local dry_run=true  # SAFE DEFAULT: dry-run unless --execute
    local force_execute=false

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --execute|--yes|-y)
                force_execute=true
                dry_run=false
                shift
                ;;
            --dry-run|-n)
                dry_run=true
                shift
                ;;
            -h|--help)
                echo "Usage: pwt auto-remove [target] [options]"
                echo ""
                echo "Safely remove worktrees that have been merged into target branch."
                echo ""
                echo "Arguments:"
                echo "  target          Target branch to check merges against (default: current)"
                echo ""
                echo "Options:"
                echo "  --execute, -y   Actually remove (default is dry-run)"
                echo "  --dry-run, -n   Preview what would be removed (default)"
                echo "  -h, --help      Show this help"
                echo ""
                echo "Safety:"
                echo "  - Dry-run by default (shows what would be removed)"
                echo "  - Dirty worktrees backed up to ~/.pwt/trash/"
                echo "  - Requires --execute for non-interactive use"
                return 0
                ;;
            -*)
                echo -e "${RED}Unknown option: $1${NC}"
                exit 1
                ;;
            *)
                target_branch="$1"
                shift
                ;;
        esac
    done

    # SAFETY: Require interactive terminal or --execute flag
    if [ "$force_execute" = false ] && [ ! -t 0 ]; then
        echo -e "${RED}⛔ SAFETY: auto-remove requires --execute flag when run non-interactively${NC}"
        echo "This prevents accidental data loss from automated scripts."
        echo ""
        echo "Usage: pwt auto-remove [target] --execute"
        exit 1
    fi

    # If no branch specified, use current branch from main app
    if [ -z "$target_branch" ]; then
        cd "$MAIN_APP"
        target_branch=$(git branch --show-current 2>/dev/null)
        if [ -z "$target_branch" ]; then
            echo -e "${RED}Error: Could not detect current branch${NC}"
            echo "Usage: pwt auto-remove [target]"
            exit 1
        fi
        echo -e "${BLUE}Target branch (detected):${NC} $target_branch"
    fi

    echo -e "${BLUE}Checking worktrees merged into:${NC} $target_branch\n"

    # Fetch to ensure updated branches
    cd "$MAIN_APP"
    git fetch origin "$target_branch" --quiet 2>/dev/null || {
        echo -e "${RED}Error: Branch '$target_branch' not found on remote${NC}"
        exit 1
    }

    # Use origin/$target_branch for comparison (freshly fetched)
    local remote_target="origin/$target_branch"

    # List worktrees to remove
    local to_remove=()
    local pending=()

    if [ ! -d "$WORKTREES_DIR" ] || [ -z "$(ls -A "$WORKTREES_DIR" 2>/dev/null)" ]; then
        echo -e "${YELLOW}No worktrees found${NC}"
        exit 0
    fi

    for dir in "$WORKTREES_DIR"/*/; do
        [ -d "$dir" ] || continue

        local name=$(basename "$dir")

        # Get worktree HEAD commit
        local wt_commit=$(git -C "$dir" rev-parse HEAD 2>/dev/null)

        # Skip worktrees without valid commit (corrupted)
        if [ -z "$wt_commit" ]; then
            echo -e "  ${YELLOW}⚠️  CORRUPTED:${NC} $name (no commit)"
            to_remove+=("$name")
            continue
        fi

        local wt_branch=$(git -C "$dir" branch --show-current 2>/dev/null)
        local branch_display="${wt_branch:-detached}"

        # Check if worktree has uncommitted changes
        # SAFETY: Assume dirty if check fails (fail-safe)
        local is_dirty=true
        local git_status
        if git_status=$(git -C "$dir" status --porcelain 2>&1); then
            if [ -z "$git_status" ]; then
                is_dirty=false
            fi
        else
            echo -e "  ${RED}⚠️  CHECK FAILED:${NC} $name - cannot verify clean state, assuming dirty"
        fi

        # Check if worktree commit is contained in remote target branch (post-fetch)
        # Uses merge-base --is-ancestor which works even if remote branch was deleted
        if git merge-base --is-ancestor "$wt_commit" "$remote_target" 2>/dev/null; then
            if [ "$is_dirty" = true ]; then
                # Merged but has uncommitted changes - protect it
                echo -e "  ${YELLOW}⚠️  DIRTY:${NC} $name ($branch_display) - merged but has uncommitted changes"
                pending+=("$name")
            else
                echo -e "  ${GREEN}✅ MERGED:${NC} $name ($branch_display)"
                to_remove+=("$name")
            fi
        else
            echo -e "  ${YELLOW}⏳ PENDING:${NC} $name ($branch_display)"
            pending+=("$name")
        fi
    done

    echo ""

    # If nothing to remove, exit
    if [ ${#to_remove[@]} -eq 0 ]; then
        echo -e "${GREEN}No worktrees to remove${NC}"
        echo -e "Kept: ${#pending[@]}"
        exit 0
    fi

    # Dry-run mode: just show what would be removed
    if [ "$dry_run" = true ]; then
        echo -e "${YELLOW}[DRY-RUN] Would remove ${#to_remove[@]} worktree(s):${NC}"
        for name in "${to_remove[@]}"; do
            echo "  - $name"
        done
        echo ""
        echo -e "Would keep: ${#pending[@]}"
        exit 0
    fi

    # Remove merged worktrees
    echo -e "${BLUE}Removing ${#to_remove[@]} worktree(s)...${NC}\n"

    local removed=0
    for name in "${to_remove[@]}"; do
        echo -e "${YELLOW}Removing: $name${NC}"
        if cmd_remove "$name" 2>&1; then
            removed=$((removed + 1))
        else
            # SAFETY: Only manually remove if directory is truly empty or has no git data
            local wt_dir="$WORKTREES_DIR/$name"
            if [ -d "$wt_dir" ]; then
                # Check if it has any files (besides .git)
                local file_count=$(find "$wt_dir" -maxdepth 1 -type f 2>/dev/null | wc -l | tr -d ' ')
                local dir_count=$(find "$wt_dir" -maxdepth 1 -type d ! -name ".git" ! -name "." 2>/dev/null | wc -l | tr -d ' ')

                if [ "$file_count" -gt 0 ] || [ "$dir_count" -gt 0 ]; then
                    echo -e "  ${RED}⛔ SAFETY: Cannot manually remove - directory has files${NC}"
                    echo -e "  Use 'pwt remove $name -y' to force removal"
                    continue
                fi

                # Empty or git-only directory - safe to remove
                rm -rf "$wt_dir" 2>/dev/null && {
                    echo -e "  ${GREEN}✓ Removed empty/corrupted worktree${NC}"
                    removed=$((removed + 1))
                }
            fi
        fi
        echo ""
    done

    echo -e "${GREEN}Done!${NC}"
    echo -e "  Removed: $removed"
    echo -e "  Kept:    ${#pending[@]}"
}

# Command: remove
cmd_remove() {
    local name=""
    local with_branch=false
    local force_branch=false
    local kill_port=false
    local kill_sidekiq=false
    local auto_yes=false

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --with-branch)
                with_branch=true
                shift
                ;;
            --force-branch)
                with_branch=true
                force_branch=true
                shift
                ;;
            --kill-port)
                kill_port=true
                shift
                ;;
            --kill-sidekiq)
                kill_sidekiq=true
                shift
                ;;
            --kill-all)
                kill_port=true
                kill_sidekiq=true
                shift
                ;;
            -y|--yes)
                auto_yes=true
                shift
                ;;
            -h|--help)
                echo "Usage: pwt remove [worktree] [options]"
                echo ""
                echo "Arguments:"
                echo "  worktree        Worktree name (default: current)"
                echo ""
                echo "Options:"
                echo "  --with-branch     Also delete the branch (if merged)"
                echo "  --force-branch    Force delete the branch (even if not merged)"
                echo "  --kill-port       Kill processes using the port"
                echo "  --kill-sidekiq    Kill Sidekiq processes"
                echo "  --kill-all        Kill both port and Sidekiq processes"
                echo "  -y, --yes         Skip confirmation prompts"
                echo "  -h, --help        Show this help"
                echo ""
                echo "Safety: Dirty worktrees are backed up to ~/.pwt/trash/"
                return 0
                ;;
            -*)
                echo -e "${RED}Unknown option: $1${NC}"
                exit 1
                ;;
            *)
                name="$1"
                shift
                ;;
        esac
    done

    # If no name, try to use current worktree
    if [ -z "$name" ]; then
        if [ -n "${PWT_WORKTREE:-}" ]; then
            name="$PWT_WORKTREE"
        elif [[ "$PWD" == *"-worktrees/"* ]]; then
            name=$(basename "$PWD")
        else
            echo -e "${RED}Error: Not in a worktree. Specify target.${NC}"
            echo "Usage: pwt remove [worktree] [--with-branch] [--force-branch]"
            exit 1
        fi
        echo -e "${BLUE}Removing current worktree: $name${NC}"
    fi

    local worktree_dir="$WORKTREES_DIR/$name"

    if [ ! -d "$worktree_dir" ]; then
        echo -e "${RED}Error: Worktree not found: $name${NC}"
        exit 1
    fi

    # Get port from metadata, fallback to extracting from name
    local port=$(get_metadata "$name" "port")
    if [ -z "$port" ]; then
        # Legacy: extract from directory name if ends with -XXXX
        if [[ "$name" =~ -([0-9]{4})$ ]]; then
            port="${BASH_REMATCH[1]}"
        fi
    fi

    # Detect processes on port (generic - no framework-specific checks)
    local port_pids=""
    local port_info=""
    if [ -n "$port" ] && [[ "$port" =~ ^[0-9]+$ ]] && has_lsof; then
        local pids_on_port=$(get_pids_on_port "$port")
        for pid in $pids_on_port; do
            local proc_name=$(ps -p "$pid" -o comm= 2>/dev/null || echo "unknown")
            local proc_cmd=$(ps -p "$pid" -o args= 2>/dev/null || echo "unknown")
            port_pids="${port_pids}${port_pids:+ }$pid"
            port_info="${port_info}  PID $pid ($proc_name): $proc_cmd\n"
        done
    fi

    # Handle blocking processes
    if [ -n "$port_pids" ]; then
        if [ "$kill_port" = true ] || [ "$kill_sidekiq" = true ]; then
            echo -e "${YELLOW}Processes on port $port:${NC}"
            echo -e "$port_info"
            if [ "$auto_yes" = true ] || confirm_action "Kill these processes?"; then
                echo "$port_pids" | xargs kill -9 2>/dev/null || true
                sleep 1
                echo -e "  ${GREEN}✓ Port $port freed${NC}"
            else
                echo -e "${RED}Aborted.${NC}"
                exit 1
            fi
        else
            echo -e "${RED}Error: Processes detected on port $port:${NC}"
            echo -e "$port_info"
            echo ""
            echo "Options:"
            echo "  pwt remove $name --kill-port    # Kill port processes"
            echo "  pwt remove $name --kill-port -y # Kill without confirmation"
            exit 1
        fi
    fi

    echo -e "${YELLOW}Removing worktree: $name${NC}"

    # SAFETY: Check for uncommitted changes before removing
    local has_changes=false
    local changes_detail=""

    if [ -d "$worktree_dir" ]; then
        # Check using BOTH methods for maximum safety
        local porcelain_status=$(git -C "$worktree_dir" status --porcelain 2>/dev/null)
        local untracked_count=$(git -C "$worktree_dir" ls-files --others --exclude-standard 2>/dev/null | wc -l | tr -d ' ')
        local staged_count=$(git -C "$worktree_dir" diff --cached --name-only 2>/dev/null | wc -l | tr -d ' ')
        local modified_count=$(git -C "$worktree_dir" diff --name-only 2>/dev/null | wc -l | tr -d ' ')

        if [ -n "$porcelain_status" ] || [ "$untracked_count" -gt 0 ] || [ "$staged_count" -gt 0 ] || [ "$modified_count" -gt 0 ]; then
            has_changes=true
            changes_detail="staged=$staged_count, modified=$modified_count, untracked=$untracked_count"
        fi
    fi

    if [ "$has_changes" = true ]; then
        echo -e "${RED}⚠️  WARNING: Worktree has uncommitted changes!${NC}"
        echo -e "    ${changes_detail}"
        echo ""
        git -C "$worktree_dir" status --short 2>/dev/null | head -10
        echo ""

        if [ "$auto_yes" = true ]; then
            echo -e "${YELLOW}Proceeding due to -y flag (changes will be LOST)${NC}"
        elif [ -t 0 ]; then
            # Interactive terminal - ask for confirmation
            if ! confirm_action "Are you SURE you want to remove this worktree? Changes will be PERMANENTLY LOST!"; then
                echo -e "${GREEN}Aborted. Worktree preserved.${NC}"
                exit 1
            fi
        else
            # Non-interactive - refuse to proceed
            echo -e "${RED}⛔ SAFETY: Cannot remove dirty worktree non-interactively${NC}"
            echo "Use 'pwt remove $name -y' to force removal"
            exit 1
        fi
    fi

    # Get metadata for hooks/Pwtfile
    local branch=$(get_metadata "$name" "branch")
    local base=$(get_metadata "$name" "base")
    local desc=$(get_metadata "$name" "description")
    # Set context for Pwtfile and hooks
    export PWT_WORKTREE="$name"
    export PWT_WORKTREE_PATH="$worktree_dir"
    export PWT_BRANCH="$branch"
    export PWT_PORT="$port"
    export PWT_TICKET="$name"  # User can customize via Pwtfile
    export PWT_BASE="$base"
    export PWT_DESC="$desc"
    export PWT_PROJECT="$CURRENT_PROJECT"
    export MAIN_APP="$MAIN_APP"

    # Run Pwtfile teardown (if exists), then hook
    # (Pwtfile handles project-specific cleanup like databases)
    run_pwtfile "teardown"
    run_hook "pre-remove"

    # Clear current symlink if removing the current worktree
    local current_wt=$(get_current_from_symlink 2>/dev/null)
    if [ "$name" = "$current_wt" ]; then
        clear_current_symlink
        echo -e "  ${CYAN}Cleared current symlink${NC}"
    fi

    # Get workspace mode (clone or worktree)
    local workspace_mode=$(get_metadata "$name" "mode")
    workspace_mode="${workspace_mode:-worktree}"  # Default to worktree for backwards compatibility

    # SAFETY: Backup uncommitted changes before removing
    if [ "$has_changes" = true ] && [ -d "$worktree_dir" ]; then
        local backup_dir="$HOME/.pwt/trash"
        local timestamp=$(date +%Y%m%d_%H%M%S)
        local backup_name="${name}_${timestamp}"

        mkdir -p "$backup_dir"

        # Save metadata for restore (branch, base, port, etc.)
        local meta_branch=$(get_metadata "$name" "branch" 2>/dev/null || git -C "$worktree_dir" branch --show-current 2>/dev/null || echo "")
        local meta_base=$(get_metadata "$name" "base" 2>/dev/null || echo "")
        local meta_port=$(get_metadata "$name" "port" 2>/dev/null || echo "")
        local meta_desc=$(get_metadata "$name" "description" 2>/dev/null || echo "")
        local meta_project="$CURRENT_PROJECT"

        cat > "$backup_dir/${backup_name}.json" << EOF
{
  "worktree": "$name",
  "branch": "$meta_branch",
  "base": "$meta_base",
  "port": "$meta_port",
  "description": "$meta_desc",
  "project": "$meta_project",
  "timestamp": "$timestamp",
  "date": "$(date -r $(date +%s) '+%Y-%m-%d %H:%M:%S' 2>/dev/null || date '+%Y-%m-%d %H:%M:%S')"
}
EOF
        echo -e "  ${CYAN}✓ Metadata saved to ~/.pwt/trash/${backup_name}.json${NC}"

        # Try to stash tracked changes
        if git -C "$worktree_dir" stash push -m "pwt-backup-$timestamp" 2>/dev/null; then
            local stash_ref=$(git -C "$worktree_dir" stash list | head -1 | cut -d: -f1)
            if [ -n "$stash_ref" ]; then
                # Export stash to backup dir
                git -C "$worktree_dir" stash show -p "$stash_ref" > "$backup_dir/${backup_name}.patch" 2>/dev/null
                echo -e "  ${CYAN}✓ Tracked changes backed up to ~/.pwt/trash/${backup_name}.patch${NC}"
            fi
        fi

        # Backup untracked files
        local untracked_files=$(git -C "$worktree_dir" ls-files --others --exclude-standard 2>/dev/null)
        if [ -n "$untracked_files" ]; then
            local untracked_backup="$backup_dir/${backup_name}_untracked"
            mkdir -p "$untracked_backup"
            cd "$worktree_dir"
            echo "$untracked_files" | while read -r file; do
                if [ -f "$file" ]; then
                    local dir=$(dirname "$file")
                    mkdir -p "$untracked_backup/$dir"
                    cp "$file" "$untracked_backup/$file" 2>/dev/null
                fi
            done
            echo -e "  ${CYAN}✓ Untracked files backed up to ~/.pwt/trash/${backup_name}_untracked/${NC}"
        fi
    fi

    if [ "$workspace_mode" = "clone" ]; then
        rm -rf "$worktree_dir"
        echo -e "${GREEN}✓ Clone removed${NC}"
    else
        cd "$MAIN_APP"
        git worktree remove "$worktree_dir" --force
        echo -e "${GREEN}✓ Worktree removed${NC}"
    fi

    # Remove metadata
    remove_metadata "$name"
    clear_list_cache  # Invalidate cache so next list won't show removed worktree

    # Delete branch if requested
    if [ "$with_branch" = true ] && [ -n "$branch" ]; then
        # Validate branch exists (locally or remotely)
        local branch_exists=false
        if git rev-parse --verify "$branch" >/dev/null 2>&1; then
            branch_exists=true
        elif git rev-parse --verify "origin/$branch" >/dev/null 2>&1; then
            branch_exists=true
        fi

        if [ "$branch_exists" = false ]; then
            echo -e "${YELLOW}Branch '$branch' not found (local or remote)${NC}"
            return 0
        fi

        # Check if branch is merged (unless forcing)
        if [ "$force_branch" = false ]; then
            local target_branch="${DEFAULT_BRANCH:-master}"
            if ! git branch --merged "$target_branch" 2>/dev/null | grep -q "^[[:space:]]*${branch}$"; then
                echo -e "${YELLOW}Branch '$branch' is not merged into $target_branch. Use --force-branch to delete anyway.${NC}"
                return 0
            fi
        fi

        # Delete local branch
        if git rev-parse --verify "$branch" >/dev/null 2>&1; then
            if git branch -D "$branch" 2>/dev/null; then
                echo -e "${GREEN}✓ Local branch deleted: $branch${NC}"
            fi
        fi

        # Delete remote branch
        if git rev-parse --verify "origin/$branch" >/dev/null 2>&1; then
            if git push origin --delete "$branch" 2>/dev/null; then
                echo -e "${GREEN}✓ Remote branch deleted: origin/$branch${NC}"
            fi
        fi
    fi
}

# Command: server
# Start the server using Pwtfile's server() function
# Usage: cmd_server [worktree]
cmd_server() {
    # Handle --help before any processing
    if [ "${1:-}" = "-h" ] || [ "${1:-}" = "--help" ]; then
        echo "Usage: pwt server [worktree]"
        echo ""
        echo "Start development server for a worktree."
        echo ""
        echo "Arguments:"
        echo "  worktree        Worktree name (default: current worktree or symlink)"
        echo ""
        echo "Options:"
        echo "  -h, --help      Show this help"
        echo ""
        echo "Detection order:"
        echo "  1. Argument provided: pwt server ACME-1234-50XX"
        echo "  2. Inside worktree directory"
        echo "  3. Current symlink set via 'pwt use'"
        echo ""
        echo "Server runs on port from worktree metadata (usually 50XX)."
        return 0
    fi

    local arg="${1:-}"
    local current_dir=$(pwd)
    local worktree_name=""
    local worktree_path=""
    local via_symlink=false
    local via_argument=false

    # 0. Check if worktree name provided as argument
    if [ -n "$arg" ]; then
        worktree_path="$WORKTREES_DIR/$arg"
        # Try partial match if not found
        if [ ! -d "$worktree_path" ]; then
            local match=$(cmd_cd "$arg" 2>/dev/null)
            if [ -n "$match" ] && [ -d "$match" ]; then
                worktree_path="$match"
            fi
        fi
        if [ ! -d "$worktree_path" ]; then
            echo -e "${RED}Error: Worktree not found: $arg${NC}"
            exit 1
        fi
        worktree_name=$(basename "$worktree_path")
        via_argument=true
    # 1. Check if inside a worktree directly
    elif [[ "$current_dir" == "$WORKTREES_DIR"/* ]]; then
        worktree_name=$(basename "$current_dir")
        worktree_path="$current_dir"
    # 2. Check if current symlink is set
    elif worktree_name=$(get_current_from_symlink 2>/dev/null); then
        # @ = main (can't run server from main)
        if [ "$worktree_name" = "@" ]; then
            echo -e "${RED}Error: current points to main (@)${NC}"
            echo "Use: pwt use <worktree>  # switch to a worktree first"
            exit 1
        fi
        worktree_path="$WORKTREES_DIR/$worktree_name"
        via_symlink=true
    else
        echo -e "${RED}Error: Not inside a worktree and no current set${NC}"
        echo ""
        echo "Options:"
        echo "  pwt server <worktree>  # specify worktree"
        echo "  cd into a worktree directory"
        echo "  pwt use <worktree>  # set current first"
        exit 1
    fi

    local port=$(get_metadata "$worktree_name" "port")

    if [ -z "$port" ]; then
        echo -e "${YELLOW}Warning: Port not found in metadata${NC}"
        port="3000"
    fi

    # Warning if running via symlink
    if [ "$via_symlink" = true ]; then
        echo -e "${YELLOW}⚠️  Running server via symlink path${NC}"
        echo -e "${DIM}   → resolved to: $worktree_path${NC}"
        echo -e "${DIM}   Tip: Run from worktree path for better LSP/watcher support${NC}"
        echo ""
    fi

    # Set context for Pwtfile
    export PWT_WORKTREE="$worktree_name"
    export PWT_WORKTREE_PATH="$worktree_path"
    export PWT_PORT="$port"
    export PWT_PROJECT="$CURRENT_PROJECT"
    export MAIN_APP="$MAIN_APP"

    echo -e "${BLUE}Starting server on port $port...${NC}"

    # Actually cd to worktree path (for Pwtfile commands that use pwd)
    cd "$worktree_path" || exit 1

    # Run Pwtfile server phase
    run_pwtfile "server"
}

# Command: current
# Show current worktree info
# Works from ANYWHERE (uses symlink, not just pwd)
# Default output: SYMLINK path on stdout (pipe-friendly), context on stderr
# Use --resolved to get actual worktree path
# Usage: pwt current [--name|--port|--branch|--path|--resolved|--json]
cmd_current() {
    local format="default"
    local show_resolved=false

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --name) format="name"; shift ;;
            --port) format="port"; shift ;;
            --branch) format="branch"; shift ;;
            --path) format="path"; shift ;;
            --resolved) show_resolved=true; shift ;;
            --json) format="json"; shift ;;
            *) shift ;;
        esac
    done

    # Detect current worktree (priority: symlink > pwd)
    local current_dir=$(pwd)
    local name=""
    local is_main=false
    local from_symlink=false

    # 1. Try symlink first (works from anywhere)
    if name=$(get_current_from_symlink 2>/dev/null); then
        from_symlink=true
        # @ means symlink points to main
        [ "$name" = "@" ] && is_main=true
    # 2. Fall back to pwd detection
    elif [[ "$current_dir" == "$WORKTREES_DIR"/* ]]; then
        name=$(basename "$current_dir")
    elif [[ "$current_dir" == "$MAIN_APP"* ]]; then
        is_main=true
        name="@"
    # 3. If project was explicitly specified, default to main
    elif [ "$PROJECT_EXPLICIT" = true ] && [ -n "$MAIN_APP" ]; then
        is_main=true
        name="@"
    else
        # No symlink and not in a worktree
        if [ "$format" = "json" ]; then
            echo '{"in_worktree":false}'
        else
            echo -e "${YELLOW}Not in a worktree (and no current set)${NC}" >&2
            echo "Run 'pwt use <worktree>' to set current" >&2
        fi
        return 1
    fi

    # Get info
    local port=""
    local branch=""
    local resolved_path=""
    local symlink_path=$(get_current_symlink_path)
    local marker=""
    local desc=""

    if [ "$is_main" = true ]; then
        resolved_path="$MAIN_APP"
        branch=$(git -C "$MAIN_APP" branch --show-current 2>/dev/null || echo "main")
    else
        resolved_path="$WORKTREES_DIR/$name"
        port=$(get_metadata "$name" "port")
        marker=$(get_metadata "$name" "marker")
        desc=$(get_metadata "$name" "description")
        branch=$(git -C "$resolved_path" branch --show-current 2>/dev/null || echo "?")
    fi

    # Determine which path to output (symlink by default, resolved with --resolved)
    local output_path="$symlink_path"
    [ "$show_resolved" = true ] && output_path="$resolved_path"

    # Output based on format
    case "$format" in
        name)
            echo "$name"
            ;;
        port)
            echo "${port:-}"
            ;;
        branch)
            echo "$branch"
            ;;
        path)
            # --path respects --resolved flag
            echo "$output_path"
            ;;
        json)
            local json="{"
            json+="\"in_worktree\":true,"
            json+="\"name\":\"$name\","
            json+="\"branch\":\"$branch\","
            json+="\"symlink_path\":\"$symlink_path\","
            json+="\"resolved_path\":\"$resolved_path\""
            [ -n "$port" ] && json+=",\"port\":$port"
            [ -n "$marker" ] && json+=",\"marker\":\"$marker\""
            [ -n "$desc" ] && json+=",\"description\":\"$desc\""
            [ "$from_symlink" = true ] && json+=",\"from_symlink\":true"
            json+="}"
            echo "$json"
            ;;
        default)
            # stdout=symlink path (stable), stderr=context (Unix-style)
            # Use --resolved to get actual worktree path
            echo "$output_path"
            if [ "$is_main" = true ]; then
                echo -e "current@${BLUE}@${NC} (main) on ${GREEN}$branch${NC}" >&2
            else
                local status=$(get_status_symbols "$resolved_path")
                local port_str=""
                [ -n "$port" ] && port_str=":${port}"
                local status_str=""
                [ -n "$status" ] && status_str=" [${status}]"
                echo -e "current@${BLUE}$name${NC} $port_str$status_str on ${GREEN}$branch${NC}" >&2
            fi
            ;;
    esac
}

# Save last-used worktree for a project
save_last_used() {
    local name="$1"
    local project="${CURRENT_PROJECT:-unknown}"
    local last_file="$PWT_DIR/projects/$project/last"
    mkdir -p "$(dirname "$last_file")"
    echo "$name" > "$last_file"
}

# Get last-used worktree for a project
get_last_used() {
    local project="${CURRENT_PROJECT:-unknown}"
    local last_file="$PWT_DIR/projects/$project/last"
    if [ -f "$last_file" ]; then
        cat "$last_file"
    fi
}

# Save previous worktree for "pwt -" navigation (like cd -)
save_previous() {
    local name="$1"
    local project="${CURRENT_PROJECT:-unknown}"
    local prev_file="$PWT_DIR/projects/$project/previous"
    mkdir -p "$(dirname "$prev_file")"
    echo "$name" > "$prev_file"
}

# Get previous worktree for "pwt -" navigation
get_previous() {
    local project="${CURRENT_PROJECT:-unknown}"
    local prev_file="$PWT_DIR/projects/$project/previous"
    if [ -f "$prev_file" ]; then
        cat "$prev_file"
    fi
}

# ============================================
# Current Symlink Functions (Capistrano-style)
# ============================================

# Get symlink path for current project
get_current_symlink_path() {
    local project="${CURRENT_PROJECT:-unknown}"
    echo "$PROJECTS_DIR/$project/current"
}

# Read current worktree from symlink
# Returns "@" if pointing to MAIN_APP, otherwise worktree name
get_current_from_symlink() {
    local symlink_path=$(get_current_symlink_path)
    [ -L "$symlink_path" ] || return 1
    local target=$(readlink "$symlink_path" 2>/dev/null) || return 1
    [ -d "$target" ] || return 1

    # Check if pointing to main app
    if [ "$target" = "$MAIN_APP" ]; then
        echo "@"
    else
        basename "$target"
    fi
}

# Update symlink atomically
set_current_worktree() {
    local name="$1"
    local symlink_path=$(get_current_symlink_path)
    local target_path="$WORKTREES_DIR/$name"

    [ -d "$target_path" ] || { echo "Worktree not found: $name" >&2; return 1; }

    mkdir -p "$(dirname "$symlink_path")"
    ln -sfn "$target_path" "$symlink_path"
    save_last_used "$name"
}

# Clear current symlink
clear_current_symlink() {
    local symlink_path=$(get_current_symlink_path)
    rm -f "$symlink_path"
}

# ============================================
# Command: ps1
# ============================================
# Fast prompt helper - NO git, NO directory scanning
# Designed for shell prompts, status bars, tmux
# Usage: pwt ps1
#   Output: pwt@WORKTREE-NAME (or empty if no current)
#   Adds ! suffix if pwd differs from current (mismatch warning)
cmd_ps1() {
    # Fast path: read symlink directly
    local symlink_path="$PROJECTS_DIR/${CURRENT_PROJECT:-unknown}/current"

    # No symlink = no output
    [ -L "$symlink_path" ] || return 0

    local target=$(readlink "$symlink_path" 2>/dev/null) || return 0
    [ -d "$target" ] || return 0

    local name=$(basename "$target")

    # Check for mismatch: pwd is in a different worktree than current
    local mismatch=""
    local current_dir=$(pwd)
    if [ -d "$WORKTREES_DIR" ] && [[ "$current_dir" == "$WORKTREES_DIR"/* ]]; then
        local pwd_name=$(basename "$current_dir")
        if [ "$pwd_name" != "$name" ]; then
            mismatch="!"
        fi
    fi

    echo "pwt@${name}${mismatch}"
}

# ============================================
# Command: use
# ============================================
# Switch the current symlink to a different worktree
# Usage: pwt use <worktree>
#   Atomically swaps the symlink, does NOT:
#   - Open editor
#   - Kill processes
#   - Change shell directory
cmd_use() {
    local target="${1:-}"

    if [ -z "$target" ]; then
        echo -e "${RED}Usage: pwt use <worktree>${NC}" >&2
        echo "Switches the current symlink to point to the specified worktree" >&2
        exit 1
    fi

    # @ = main worktree (special case)
    if [ "$target" = "@" ]; then
        # Point symlink to main app (always have a current)
        local symlink_path=$(get_current_symlink_path)
        mkdir -p "$(dirname "$symlink_path")"
        ln -sfn "$MAIN_APP" "$symlink_path"
        save_last_used "@"
        local branch=$(git -C "$MAIN_APP" branch --show-current 2>/dev/null || echo "?")
        echo -e "current → ${BLUE}@ (main)${NC} (branch ${GREEN}$branch${NC})"
        return 0
    fi

    # Check if it's a worktree name (exact match)
    local worktree_path="$WORKTREES_DIR/$target"
    local resolved_name="$target"

    if [ ! -d "$worktree_path" ]; then
        # Try partial match by directory name
        local matches=()
        if [ -d "$WORKTREES_DIR" ]; then
            for dir in "$WORKTREES_DIR"/*/; do
                local name=$(basename "$dir")
                if [[ "$name" == *"$target"* ]]; then
                    matches+=("$name")
                fi
            done
        fi

        # If no directory match, try matching by branch name
        if [ ${#matches[@]} -eq 0 ] && [ -d "$WORKTREES_DIR" ]; then
            local normalized_target="${target//\//-}"  # feature/foo → feature-foo
            for dir in "$WORKTREES_DIR"/*/; do
                local name=$(basename "$dir")
                local branch=$(git -C "$dir" branch --show-current 2>/dev/null)
                if [[ -n "$branch" ]] && [[ "$branch" == *"$target"* || "$branch" == *"$normalized_target"* ]]; then
                    matches+=("$name")
                fi
            done
        fi

        if [ ${#matches[@]} -eq 1 ]; then
            resolved_name="${matches[0]}"
            worktree_path="$WORKTREES_DIR/$resolved_name"
        elif [ ${#matches[@]} -gt 1 ]; then
            echo -e "${RED}Multiple matches for '$target':${NC}" >&2
            for m in "${matches[@]}"; do
                echo "  $m" >&2
            done
            exit 1
        else
            # No worktree match - check if target matches main app's branch
            local main_branch=$(git -C "$MAIN_APP" branch --show-current 2>/dev/null)
            if [[ -n "$main_branch" && "$main_branch" == *"$target"* ]]; then
                # Target matches main app branch - use @
                local symlink_path=$(get_current_symlink_path)
                mkdir -p "$(dirname "$symlink_path")"
                ln -sfn "$MAIN_APP" "$symlink_path"
                save_last_used "@"
                echo -e "current → ${BLUE}@ (main)${NC} (branch ${GREEN}$main_branch${NC})"
                return 0
            fi
            echo -e "${RED}Worktree not found: $target${NC}" >&2
            exit 1
        fi
    fi

    # Swap symlink
    set_current_worktree "$resolved_name" || exit 1

    # Output context
    local port=$(get_metadata "$resolved_name" "port")
    local branch=$(git -C "$worktree_path" branch --show-current 2>/dev/null || echo "?")
    echo -e "current → ${BLUE}$resolved_name${NC} (branch ${GREEN}$branch${NC})"
    [ -n "$port" ] && echo -e "         port ${CYAN}:$port${NC}"
    return 0
}

# Command: info
cmd_info() {
    local name="$1"

    # Handle --help
    if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
        echo "Usage: pwt info [worktree]"
        echo ""
        echo "Show detailed information about a worktree."
        echo ""
        echo "Arguments:"
        echo "  worktree  Name of the worktree (optional if inside one)"
        echo ""
        echo "Information shown:"
        echo "  - Branch and tracking information"
        echo "  - Assigned port number"
        echo "  - Server status"
        echo "  - Creation metadata"
        echo "  - Git status (dirty files)"
        return 0
    fi

    # If no name specified, try to detect from current directory
    if [ -z "$name" ]; then
        local current_dir=$(pwd)
        if [[ "$current_dir" == "$WORKTREES_DIR"/* ]]; then
            name=$(basename "$current_dir")
        else
            echo -e "${RED}Error: Worktree not specified${NC}"
            echo "Usage: pwt info <worktree>"
            echo "Or run from inside a worktree"
            exit 1
        fi
    fi

    local worktree_dir="$WORKTREES_DIR/$name"

    if [ ! -d "$worktree_dir" ]; then
        echo -e "${RED}Error: Worktree not found: $name${NC}"
        exit 1
    fi

    # Extract information
    local port=$(get_metadata "$name" "port")
    if [ -z "$port" ]; then
        # Legacy: extract from directory name if ends with -XXXX
        if [[ "$name" =~ -([0-9]{4})$ ]]; then
            port="${BASH_REMATCH[1]}"
        else
            port="-"
        fi
    fi
    local ticket="$name"
    local branch=$(git -C "$worktree_dir" branch --show-current 2>/dev/null || echo "detached")
    local upstream=$(git -C "$worktree_dir" rev-parse --abbrev-ref "${branch}@{upstream}" 2>/dev/null || echo "-")
    local commit=$(git -C "$worktree_dir" rev-parse --short HEAD 2>/dev/null || echo "-")
    local commit_msg=$(git -C "$worktree_dir" log -1 --format='%s' 2>/dev/null | head -c 50)

    # Server status (check port, not pidfile)
    local server_status="${YELLOW}stopped${NC}"
    if [ -n "$port" ] && [[ "$port" =~ ^[0-9]+$ ]]; then
        local pids=$(get_pids_on_port "$port")
        if [ -n "$pids" ]; then
            local first_pid=$(echo "$pids" | head -1)
            server_status="${GREEN}running${NC} (PID $first_pid)"
        fi
    fi

    # Commits ahead/behind
    local ahead_behind=""
    if [ "$upstream" != "-" ]; then
        local ahead=$(git -C "$worktree_dir" rev-list --count "${upstream}..${branch}" 2>/dev/null || echo "0")
        local behind=$(git -C "$worktree_dir" rev-list --count "${branch}..${upstream}" 2>/dev/null || echo "0")
        if [ "$ahead" -gt 0 ] || [ "$behind" -gt 0 ]; then
            ahead_behind=" (↑${ahead} ↓${behind})"
        fi
    fi

    # Output
    echo ""
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${YELLOW}$name${NC}"
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
    echo -e "  ${BLUE}Ticket:${NC}    $ticket"
    echo -e "  ${BLUE}Branch:${NC}    $branch"
    echo -e "  ${BLUE}Based on:${NC}  $upstream$ahead_behind"
    echo -e "  ${BLUE}Commit:${NC}    $commit - $commit_msg"
    echo ""
    echo -e "  ${BLUE}Port:${NC}      $port"
    echo -e "  ${BLUE}Server:${NC}    $server_status"
    echo -e "  ${BLUE}Directory:${NC} $worktree_dir"
    echo ""

    # Show modified files if any
    local modified=$(git -C "$worktree_dir" status --porcelain 2>/dev/null | wc -l | tr -d ' ')
    if [ "$modified" -gt 0 ]; then
        echo -e "  ${YELLOW}Modified files:${NC} $modified"
        git -C "$worktree_dir" status --porcelain 2>/dev/null | head -5 | sed 's/^/    /'
        if [ "$modified" -gt 5 ]; then
            echo "    ... and $((modified - 5)) more"
        fi
        echo ""
    fi
}

# Command: fix-port
# Reallocate a worktree to a new free port
cmd_fix_port() {
    local name="$1"

    # If no name specified, try to detect from current directory
    if [ -z "$name" ]; then
        local current_dir=$(pwd)
        if [[ "$current_dir" == "$WORKTREES_DIR"/* ]]; then
            name=$(basename "$current_dir")
        else
            echo -e "${RED}Error: Worktree name not specified${NC}"
            echo "Usage: pwt fix-port <worktree>"
            echo "Or run from inside a worktree"
            exit 1
        fi
    fi

    local worktree_dir="$WORKTREES_DIR/$name"

    if [ ! -d "$worktree_dir" ]; then
        echo -e "${RED}Error: Worktree not found: $name${NC}"
        exit 1
    fi

    # Get current port from metadata, fallback to directory name
    local old_port=$(get_metadata "$name" "port")
    if [ -z "$old_port" ]; then
        # Legacy: extract from directory name if ends with -XXXX
        if [[ "$name" =~ -([0-9]{4})$ ]]; then
            old_port="${BASH_REMATCH[1]}"
        fi
    fi

    if [ -z "$old_port" ] || ! [[ "$old_port" =~ ^[0-9]+$ ]]; then
        echo -e "${RED}Error: Could not find port for worktree: $name${NC}"
        echo "Check metadata with: pwt meta show $name"
        exit 1
    fi

    # Check if current port is actually occupied
    if is_port_pair_free "$old_port"; then
        echo -e "${GREEN}Port $old_port is already free!${NC}"
        echo "No changes needed."
        exit 0
    fi

    # Analyze what's occupying the port
    local pids=$(get_pids_on_port "$old_port")
    local procs_info=""

    if has_lsof && [ -n "$pids" ]; then
        for pid in $pids; do
            local proc=$(ps -p "$pid" -o comm= 2>/dev/null || echo "?")
            procs_info="${procs_info}  PID $pid: $proc\n"
        done
    fi

    echo -e "${YELLOW}Port $old_port is occupied:${NC}"
    if [ -n "$procs_info" ]; then
        echo -e "$procs_info"
    else
        echo "  (could not identify processes)"
    fi
    echo ""

    echo -e "${BLUE}Options:${NC}"
    echo "  1) Kill processes and keep port $old_port"
    echo "  2) Reallocate to new port"
    echo "  3) Cancel"
    echo ""
    read -p "Choose (1/2/3): " -n 1 -r choice
    echo ""

    case "$choice" in
        1)
            if [ -n "$pids" ]; then
                echo ""
                echo -e "${YELLOW}Killing processes...${NC}"
                for pid in $pids; do
                    kill -9 "$pid" 2>/dev/null && echo "  ✓ PID $pid killed"
                done
                sleep 1

                # Check if freed
                if is_port_free "$old_port"; then
                    echo ""
                    echo -e "${GREEN}✓ Port $old_port freed!${NC}"
                    echo ""
                    echo "Now you can start the server:"
                    echo -e "  ${BLUE}pwt server${NC}"
                    exit 0
                else
                    echo -e "${RED}Port still occupied. Reallocating...${NC}"
                fi
            else
                echo "No processes found to kill."
            fi
            ;;
        2)
            echo ""
            echo "Reallocating to new port..."
            ;;
        *)
            echo "Cancelled."
            exit 0
            ;;
    esac

    # Find new port
    local new_port=$(next_available_port)

    echo -e "${BLUE}Reallocating to port $new_port...${NC}"
    echo "  Port: $old_port → $new_port"
    echo ""

    # Update metadata (use JSON for numeric port)
    update_metadata_json "$name" "port" "$new_port"
    echo -e "  ${GREEN}✓${NC} Metadata updated"

    # Set context for hook (project can update configs via hook)
    export PWT_OLD_PORT="$old_port"
    export PWT_PORT="$new_port"
    export PWT_WORKTREE="$name"
    export PWT_WORKTREE_PATH="$worktree_dir"
    export PWT_PROJECT="$CURRENT_PROJECT"
    export MAIN_APP="$MAIN_APP"

    # Run project hook (for config updates like .env, databases, etc.)
    run_hook "post-fix-port"

    echo ""
    echo -e "${GREEN}✓ Port reallocated successfully!${NC}"
    echo ""
    echo "To start server:"
    echo -e "  ${BLUE}pwt server${NC}  # Starts on port $new_port"
}

# Command: meta
# View or edit worktree metadata
cmd_meta() {
    local action="$1"
    local name="$2"
    local field="$3"
    local value="$4"

    init_metadata

    local project="${CURRENT_PROJECT:-unknown}"

    case "$action" in
        ""|list)
            # List all metadata for current project (key=value format)
            echo -e "${BLUE}Worktree Metadata ($project):${NC}"
            echo ""
            jq -r --arg project "$project" '
              .[$project] // {} | to_entries[] |
              "\(.key):",
              "  path=\(.value.path // "")",
              "  branch=\(.value.branch // "")",
              "  base=\(.value.base // "")@\(.value.base_commit // "")",
              "  port=\(.value.port // "")",
              "  description=\(.value.description // "")",
              "  created=\(.value.created_at // "")",
              ""
            ' "$METADATA_FILE"
            ;;
        show)
            if [ -z "$name" ]; then
                echo -e "${RED}Error: Worktree name required${NC}"
                echo "Usage: pwt meta show <worktree>"
                exit 1
            fi
            local meta=$(jq --arg project "$project" --arg name "$name" '.[$project][$name]' "$METADATA_FILE")
            if [ "$meta" = "null" ]; then
                echo -e "${YELLOW}No metadata found for: $name${NC}"
            else
                echo -e "${BLUE}Metadata for $name:${NC}"
                echo "$meta" | jq '.'
            fi
            ;;
        set)
            if [ -z "$name" ] || [ -z "$field" ] || [ -z "$value" ]; then
                echo -e "${RED}Error: Missing arguments${NC}"
                echo "Usage: pwt meta set <worktree> <field> <value>"
                echo ""
                echo "Fields: base, description, branch"
                exit 1
            fi
            update_metadata "$name" "$field" "$value"
            echo -e "${GREEN}✓ Updated $name.$field = $value${NC}"
            clear_list_cache  # Invalidate cache so next list shows updated metadata
            ;;
        -h|--help|help)
            echo "Usage: pwt meta [command] [args]"
            echo ""
            echo "Manage worktree metadata."
            echo ""
            echo "Commands:"
            echo "  list                           List all worktree metadata (default)"
            echo "  show <worktree>                Show metadata for a worktree"
            echo "  set <worktree> <field> <value> Update a metadata field"
            echo "  import                         Import metadata for existing worktrees"
            echo ""
            echo "Fields: branch, base, description, port"
            echo ""
            echo "Options:"
            echo "  -h, --help, help    Show this help"
            return 0
            ;;
        import)
            # Import metadata for existing worktrees
            echo -e "${BLUE}Importing metadata for existing worktrees...${NC}"
            if [ -d "$WORKTREES_DIR" ] && [ "$(ls -A "$WORKTREES_DIR" 2>/dev/null)" ]; then
                for dir in "$WORKTREES_DIR"/*/; do
                    [ -d "$dir" ] || continue
                    local wt_name=$(basename "$dir")
                    local existing=$(get_metadata "$wt_name" "path")
                    if [ -z "$existing" ]; then
                        local wt_branch=$(git -C "$dir" branch --show-current 2>/dev/null || echo "?")
                        # Try to extract port from directory name (legacy format)
                        local wt_port=""
                        if [[ "$wt_name" =~ -([0-9]{4})$ ]]; then
                            wt_port="${BASH_REMATCH[1]}"
                        else
                            # Allocate new port for new format directories
                            wt_port=$(next_available_port)
                        fi
                        local wt_base_commit=$(git -C "$dir" merge-base HEAD "origin/${DEFAULT_BRANCH:-master}" 2>/dev/null)
                        local wt_base_short=$(git -C "$dir" rev-parse --short "$wt_base_commit" 2>/dev/null || echo "?")
                        local wt_desc=$(echo "$wt_branch" | sed -E 's|^[a-z]+/||' | tr '-' ' ')

                        save_metadata "$wt_name" "$dir" "$wt_branch" "${DEFAULT_BRANCH:-master}" "$wt_base_short" "$wt_port" "$wt_desc"
                        echo -e "  ${GREEN}✓${NC} Imported: $wt_name (port $wt_port)"
                    else
                        echo -e "  ${YELLOW}○${NC} Exists: $wt_name"
                    fi
                done
            fi
            echo -e "${GREEN}Done!${NC}"
            ;;
        *)
            echo -e "${RED}Unknown action: $action${NC}"
            echo "Usage: pwt meta [list|show|set|import]"
            echo ""
            echo "Commands:"
            echo "  list              - List all worktree metadata"
            echo "  show <name>       - Show metadata for a worktree"
            echo "  set <name> <field> <value> - Update a metadata field"
            echo "  import            - Import metadata for existing worktrees"
            exit 1
            ;;
    esac
}

# Command: alias
# Get/set/clear project alias (auto-detects current project)
# Usage: pwt alias [<alias>|--clear]
cmd_alias() {
    local new_alias="${1:-}"
    local config_file="$PROJECTS_DIR/$CURRENT_PROJECT/config.json"

    if [ ! -f "$config_file" ]; then
        echo -e "${RED}Project config not found: $CURRENT_PROJECT${NC}"
        exit 1
    fi

    if [ -z "$new_alias" ]; then
        # Show current project and alias
        local current=$(jq -r '.alias // empty' "$config_file")
        if [ -n "$current" ]; then
            echo -e "${GREEN}$CURRENT_PROJECT${NC} → ${CYAN}$current${NC}"
        else
            echo -e "${GREEN}$CURRENT_PROJECT${NC} (no alias)"
        fi
    elif [ "$new_alias" = "--clear" ]; then
        # Clear alias
        local tmp_file
        tmp_file="$(mktemp "${config_file}.tmp.XXXXXX")"
        jq 'del(.alias)' "$config_file" > "$tmp_file" && mv "$tmp_file" "$config_file"
        echo -e "${GREEN}✓ Cleared alias for $CURRENT_PROJECT${NC}"
    else
        # Set alias - validate first
        local reserved_commands="list create remove cd server test meta port project help version config init show set path alias"
        for cmd in $reserved_commands; do
            if [ "$new_alias" = "$cmd" ]; then
                echo -e "${RED}Error: '$new_alias' is a reserved command name${NC}"
                exit 1
            fi
        done
        # Check if alias conflicts with existing project name
        if [ -f "$PROJECTS_DIR/$new_alias/config.json" ]; then
            echo -e "${RED}Error: '$new_alias' is already a project name${NC}"
            exit 1
        fi
        # Check if alias already used by another project
        for cfg in "$PROJECTS_DIR"/*/config.json; do
            [ -f "$cfg" ] || continue
            local proj_dir=$(dirname "$cfg")
            local proj_name=$(basename "$proj_dir")
            [ "$proj_name" = "$CURRENT_PROJECT" ] && continue
            local other_alias=$(jq -r '.alias // empty' "$cfg")
            if [ "$other_alias" = "$new_alias" ]; then
                echo -e "${RED}Error: Alias '$new_alias' already used by project '$proj_name'${NC}"
                exit 1
            fi
        done
        # Set alias
        local tmp_file
        tmp_file="$(mktemp "${config_file}.tmp.XXXXXX")"
        jq --arg alias "$new_alias" '.alias = $alias' "$config_file" > "$tmp_file" && mv "$tmp_file" "$config_file"
        echo -e "${GREEN}✓ $CURRENT_PROJECT${NC} → ${CYAN}$new_alias${NC}"
    fi
}

# Command: cd (internal)
# Output path for worktree navigation
# Usage: pwt _cd [worktree|@|-]
#   @ or empty = main worktree
#   - = previous worktree (like cd -)
#   worktree = specific worktree
cmd_cd() {
    # Handle --help
    if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
        echo "Usage: pwt cd [worktree|@|-]"
        echo ""
        echo "Navigate to a worktree (outputs path for shell integration)."
        echo ""
        echo "Arguments:"
        echo "  worktree  Name of the worktree"
        echo "  @         Main app directory"
        echo "  -         Previous worktree (like cd -)"
        echo "  (none)    Last used worktree, or main"
        echo ""
        echo "Tip: Run 'eval \"\$(pwt shell-init)\"' for real cd integration."
        return 0
    fi

    local target="${1:-}"

    # Strip trailing slash (from shell completion)
    target="${target%/}"

    # No target: try last-used, fallback to main
    if [ -z "$target" ]; then
        local last=$(get_last_used)
        if [ -n "$last" ] && [ -d "$WORKTREES_DIR/$last" ]; then
            target="$last"
        else
            target="@"
        fi
    fi

    # - = previous worktree (like cd -)
    if [ "$target" = "-" ]; then
        local prev=$(get_previous)
        if [ -z "$prev" ]; then
            echo "No previous worktree" >&2
            return 1
        fi
        target="$prev"
        # Show where we're going (like cd - does)
        if [ "$target" = "@" ]; then
            echo -e "${DIM}~${NC}" >&2
        else
            echo -e "${DIM}$target${NC}" >&2
        fi
    fi

    # Helper to save navigation history
    _save_navigation() {
        local new_target="$1"
        local current=$(get_last_used)
        # Save current as previous (for pwt -)
        if [ -n "$current" ] && [ "$current" != "$new_target" ]; then
            save_previous "$current"
        fi
        save_last_used "$new_target"
    }

    # @ = main worktree
    if [ "$target" = "@" ]; then
        _save_navigation "@"
        echo "$MAIN_APP"
        return 0
    fi

    # current = symlink path (stable path for editors)
    if [ "$target" = "current" ]; then
        local symlink_path=$(get_current_symlink_path)
        if [ -L "$symlink_path" ]; then
            echo "$symlink_path"
            return 0
        else
            echo "No current worktree set. Run 'pwt use <worktree>' first." >&2
            return 1
        fi
    fi

    # Check if it's a worktree name
    local worktree_path="$WORKTREES_DIR/$target"
    if [ -d "$worktree_path" ]; then
        _save_navigation "$target"
        echo "$worktree_path"
        return 0
    fi

    # Try partial match
    local matches=()
    if [ -d "$WORKTREES_DIR" ]; then
        for dir in "$WORKTREES_DIR"/*/; do
            local name=$(basename "$dir")
            if [[ "$name" == *"$target"* ]]; then
                matches+=("$dir")
            fi
        done
    fi

    if [ ${#matches[@]} -eq 1 ]; then
        local matched_name=$(basename "${matches[0]%/}")
        _save_navigation "$matched_name"
        echo "${matches[0]%/}"
        return 0
    elif [ ${#matches[@]} -gt 1 ]; then
        echo "Multiple matches for '$target':" >&2
        for m in "${matches[@]}"; do
            echo "  $(basename "${m%/}")" >&2
        done
        return 1
    fi

    echo "Worktree not found: $target" >&2
    return 1
}

# Resolve worktree path without side effects (no navigation history)
# Usage: resolve_worktree_path <target>
#   @ = main worktree
#   - = previous worktree
#   name = exact or fuzzy match
# Returns: path on stdout, or empty string on failure
resolve_worktree_path() {
    local target="$1"

    # @ = main worktree
    if [ "$target" = "@" ]; then
        echo "$MAIN_APP"
        return 0
    fi

    # - = previous worktree
    if [ "$target" = "-" ]; then
        local prev=$(get_previous)
        if [ -z "$prev" ]; then
            return 1
        fi
        if [ "$prev" = "@" ]; then
            echo "$MAIN_APP"
        else
            echo "$WORKTREES_DIR/$prev"
        fi
        return 0
    fi

    # Exact match
    if [ -d "$WORKTREES_DIR/$target" ]; then
        echo "$WORKTREES_DIR/$target"
        return 0
    fi

    # Fuzzy match (contains)
    local matches=()
    if [ -d "$WORKTREES_DIR" ]; then
        for dir in "$WORKTREES_DIR"/*/; do
            [ -d "$dir" ] || continue
            local name=$(basename "$dir")
            if [[ "$name" == *"$target"* ]]; then
                matches+=("${dir%/}")
            fi
        done
    fi

    if [ ${#matches[@]} -eq 1 ]; then
        echo "${matches[0]}"
        return 0
    fi

    return 1
}

# Command: run
# Run a command in a worktree without changing directory
# Usage: pwt run [worktree] <command...>
#   @ = main worktree
#   If worktree is omitted, uses current worktree or main
cmd_run() {
    # Handle --help
    if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
        echo "Usage: pwt run [worktree] <command...>"
        echo ""
        echo "Run a command in a worktree without changing directory."
        echo ""
        echo "Arguments:"
        echo "  worktree   Target worktree (@ for main, optional)"
        echo "  command    Command to run in the worktree"
        echo ""
        echo "If worktree is omitted, runs in current worktree or main."
        echo ""
        echo "Examples:"
        echo "  pwt run TICKET-123 npm test    # in specific worktree"
        echo "  pwt run @ git status           # in main app"
        echo "  pwt run npm test               # in current/main"
        return 0
    fi

    if [ $# -eq 0 ]; then
        echo -e "${RED}Usage: pwt run [worktree] <command...>${NC}"
        exit 1
    fi

    local target=""
    local worktree_path=""

    # Try to resolve first arg as worktree
    local maybe_wt="$1"
    local maybe_path=""

    if [ "$maybe_wt" = "@" ]; then
        target="@"
        worktree_path="$MAIN_APP"
        shift
    else
        maybe_path=$(resolve_worktree_path "$maybe_wt" 2>/dev/null) || true
        if [ -n "$maybe_path" ] && [ -d "$maybe_path" ]; then
            # First arg is a valid worktree
            target="$maybe_wt"
            worktree_path="$maybe_path"
            shift
        else
            # First arg is not a worktree, use current/main
            target="current"
            # Try to get current worktree from symlink
            local current_link="${PWT_DIR}/projects/${CURRENT_PROJECT}/current"
            if [ -L "$current_link" ] && [ -d "$current_link" ]; then
                worktree_path=$(readlink "$current_link")
            else
                worktree_path="$MAIN_APP"
            fi
        fi
    fi

    if [ $# -eq 0 ]; then
        echo -e "${RED}No command specified${NC}"
        exit 1
    fi

    if [ -z "$worktree_path" ] || [ ! -d "$worktree_path" ]; then
        echo -e "${RED}Worktree not found: $target${NC}"
        exit 1
    fi

    echo -e "${BLUE}Running in $worktree_path:${NC} $*"
    (cd "$worktree_path" && "$@")
}

# Command: shell
# Start an interactive subshell in a worktree with PWT context
# Usage: pwt shell <worktree>
#   @ = main worktree
#   - = previous worktree
cmd_shell() {
    local target="${1:-}"

    if [ -z "$target" ]; then
        echo "Usage: pwt shell <worktree>"
        echo "       pwt shell @              # main app"
        echo "       pwt shell ACME-17744  # specific worktree"
        echo "       pwt shell 17744          # fuzzy match"
        return 1
    fi

    # Resolve worktree path (use || true to prevent set -e from exiting on not found)
    local wt_path
    wt_path=$(resolve_worktree_path "$target") || true

    if [ -z "$wt_path" ] || [ ! -d "$wt_path" ]; then
        echo -e "${RED}Worktree not found: $target${NC}"
        return 1
    fi

    # Set up context
    export PWT_WORKTREE="$target"
    export PWT_WORKTREE_PATH="$wt_path"
    export PWT_PROJECT="$CURRENT_PROJECT"

    # Extract port if worktree
    if [ "$target" != "@" ] && [[ "$wt_path" == *"$WORKTREES_DIR"* ]]; then
        local wt_name=$(basename "$wt_path")
        export PWT_PORT=$(echo "$wt_name" | grep -oE '[0-9]+$' || true)
        export PWT_BRANCH=$(get_metadata "$wt_name" "branch" 2>/dev/null || git -C "$wt_path" branch --show-current 2>/dev/null || echo "")
    else
        export PWT_PORT=""
        export PWT_BRANCH=$(git -C "$wt_path" branch --show-current 2>/dev/null || echo "master")
    fi

    # Custom prompt
    local wt_display="$target"
    [ "$target" = "@" ] && wt_display="main"

    export PWT_SHELL_PS1="[pwt:${CURRENT_PROJECT}@${wt_display}]\$ "

    # Mark as pwt subshell (user can detect in .zshrc)
    export PWT_SHELL=1

    # Print banner
    local banner_text="pwt subshell: ${CURRENT_PROJECT} @ ${wt_display}"
    local exit_hint="Ctrl+D or 'exit' to return"
    local banner_len=${#banner_text}
    local exit_len=${#exit_hint}
    local content_width=$((banner_len > exit_len ? banner_len : exit_len))
    local box_width=$((content_width + 4))
    local border=$(printf '─%.0s' $(seq 1 $((box_width - 2))))

    echo ""
    echo -e "${BLUE}┌${border}┐${NC}"
    printf "${BLUE}│${NC}  %-${content_width}s  ${BLUE}│${NC}\n" "$banner_text"
    printf "${BLUE}│${NC}  ${DIM}%-${content_width}s${NC}  ${BLUE}│${NC}\n" "$exit_hint"
    echo -e "${BLUE}└${border}┘${NC}"
    echo ""

    # Start subshell
    (cd "$wt_path" && PWT_SHELL=1 exec "${SHELL:-/bin/bash}")

    echo -e "${GREEN}Exited pwt shell${NC}"
}

# Command: restore
# Recover backed up changes from ~/.pwt/trash/
# Backups are created automatically when removing dirty worktrees
# Usage:
#   pwt restore                       # List available backups
#   pwt restore <backup>              # Auto-create worktree and restore
#   pwt restore <backup> <worktree>   # Apply to existing worktree
cmd_restore() {
    local TRASH_DIR="$HOME/.pwt/trash"
    local first_arg="${1:-}"

    # Handle help and list first (don't need trash directory for help)
    case "$first_arg" in
        help|--help|-h)
            echo "Usage: pwt [project] restore [backup] [worktree]"
            echo ""
            echo "  pwt restore                   List available backups"
            echo "  pwt restore list              List available backups"
            echo "  pwt restore <backup>          Recreate worktree and apply backup"
            echo "  pwt restore <backup> <wt>     Apply backup to existing worktree"
            echo ""
            echo "Backups are created automatically when removing dirty worktrees."
            echo "Location: ~/.pwt/trash/"
            return 0
            ;;
        list|--list|-l)
            # Explicit list command - fall through to listing logic
            first_arg=""
            ;;
    esac

    # Ensure trash directory exists
    if [ ! -d "$TRASH_DIR" ]; then
        echo -e "${YELLOW}No backups found.${NC}"
        echo "Backups are created when removing worktrees with uncommitted changes."
        return 0
    fi

    # No argument = list backups
    if [ -z "$first_arg" ]; then
        _restore_list
        return $?
    fi

    # Argument provided = treat as backup name (exact or fuzzy match)
    local backup_name=""

    # Try exact match first
    if [ -f "$TRASH_DIR/${first_arg}.json" ] || [ -f "$TRASH_DIR/${first_arg}.patch" ]; then
        backup_name="$first_arg"
    else
        # Try fuzzy match by worktree name prefix (most recent)
        local matching=$(find "$TRASH_DIR" -maxdepth 1 -name "${first_arg}*.json" -print0 2>/dev/null | \
            xargs -0 ls -t 2>/dev/null | head -1)

        if [ -n "$matching" ]; then
            backup_name=$(basename "$matching" .json)
            echo -e "${DIM}Found: $backup_name${NC}"
        fi
    fi

    if [ -z "$backup_name" ]; then
        echo -e "${RED}Backup not found: $first_arg${NC}"
        echo "Use 'pwt restore' to see available backups."
        return 1
    fi

    local target_worktree="${2:-}"
    _restore_backup "$backup_name" "$target_worktree"
}

# Helper: list available backups
_restore_list() {
    local TRASH_DIR="$HOME/.pwt/trash"

    echo -e "${BLUE}Available backups:${NC}"
    echo ""

    local found=false
    local json_files=()

    # Collect JSON metadata files (newest first)
    while IFS= read -r -d '' file; do
        json_files+=("$file")
        found=true
    done < <(find "$TRASH_DIR" -maxdepth 1 -name "*.json" -print0 2>/dev/null | sort -z -r)

    if [ "$found" = false ]; then
        # Fall back to patch files without JSON (legacy)
        local patches=()
        while IFS= read -r -d '' file; do
            patches+=("$file")
            found=true
        done < <(find "$TRASH_DIR" -maxdepth 1 -name "*.patch" -print0 2>/dev/null | sort -z -r)

        if [ "$found" = false ]; then
            echo -e "${YELLOW}No backups found.${NC}"
            return 0
        fi

        for patch in "${patches[@]}"; do
            local basename=$(basename "$patch" .patch)
            local wt_name=$(echo "$basename" | sed -E 's/_[0-9]{8}_[0-9]{6}$//')
            echo -e "  ${GREEN}$basename${NC} ${DIM}(legacy)${NC}"
            echo -e "     Worktree: ${CYAN}$wt_name${NC}"
            echo ""
        done
    else
        for json_file in "${json_files[@]}"; do
            local basename=$(basename "$json_file" .json)
            local wt_name=$(jq -r '.worktree // empty' "$json_file" 2>/dev/null)
            local branch=$(jq -r '.branch // empty' "$json_file" 2>/dev/null)
            local date=$(jq -r '.date // empty' "$json_file" 2>/dev/null)

            # Check what backup files exist
            local has_patch=false
            local has_untracked=false
            [ -f "$TRASH_DIR/${basename}.patch" ] && has_patch=true
            [ -d "$TRASH_DIR/${basename}_untracked" ] && has_untracked=true

            local contents=""
            [ "$has_patch" = true ] && contents="patch"
            [ "$has_untracked" = true ] && contents="${contents:+$contents+}untracked"

            echo -e "  ${GREEN}$wt_name${NC}  ${DIM}$date${NC}  ${YELLOW}[$contents]${NC}"
            [ -n "$branch" ] && echo -e "     Branch: ${CYAN}$branch${NC}"
            echo ""
        done
    fi

    echo -e "${DIM}Usage: pwt restore <worktree-name> [target-worktree]${NC}"
}

# Helper: restore a backup to a worktree
# Usage: _restore_backup <backup_name> [target_worktree]
#   If target_worktree is empty, auto-creates from backup metadata
_restore_backup() {
    local backup_name="$1"
    local target_worktree="$2"
    local TRASH_DIR="$HOME/.pwt/trash"

    local json_file="$TRASH_DIR/${backup_name}.json"
    local patch_file="$TRASH_DIR/${backup_name}.patch"
    local untracked_dir="$TRASH_DIR/${backup_name}_untracked"

    # Check backup exists
    if [ ! -f "$json_file" ] && [ ! -f "$patch_file" ] && [ ! -d "$untracked_dir" ]; then
        echo -e "${RED}Backup not found: $backup_name${NC}"
        return 1
    fi

    local target_dir=""

    # If target worktree specified, resolve it
    if [ -n "$target_worktree" ]; then
        target_dir=$(resolve_worktree_path "$target_worktree") || true
        if [ -z "$target_dir" ] || [ ! -d "$target_dir" ]; then
            echo -e "${RED}Worktree not found: $target_worktree${NC}"
            return 1
        fi
        echo -e "${BLUE}Restoring to existing worktree: $target_worktree${NC}"
    else
        # Auto-create worktree from metadata
        if [ ! -f "$json_file" ]; then
            echo -e "${RED}Cannot auto-create worktree: no metadata (legacy backup)${NC}"
            echo "Specify target worktree: pwt restore $backup_name <worktree>"
            return 1
        fi

        local branch=$(jq -r '.branch // empty' "$json_file" 2>/dev/null)
        local base=$(jq -r '.base // empty' "$json_file" 2>/dev/null)
        local desc=$(jq -r '.description // empty' "$json_file" 2>/dev/null)

        if [ -z "$branch" ]; then
            echo -e "${RED}Cannot auto-create worktree: no branch in metadata${NC}"
            echo "Specify target worktree: pwt restore $backup_name <worktree>"
            return 1
        fi

        echo -e "${BLUE}Creating worktree from backup metadata...${NC}"
        echo -e "  Branch: ${YELLOW}$branch${NC}"
        echo -e "  Base:   ${base:-master}"
        echo ""

        # Create the worktree using cmd_create
        # Pass description if available
        if [ -n "$desc" ]; then
            cmd_create "$branch" "${base:-master}" "$desc"
        else
            cmd_create "$branch" "${base:-master}"
        fi

        local create_status=$?
        if [ $create_status -ne 0 ]; then
            echo -e "${RED}Failed to create worktree${NC}"
            return 1
        fi

        # Find the newly created worktree
        target_dir=$(resolve_worktree_path "$branch") || true
        if [ -z "$target_dir" ] || [ ! -d "$target_dir" ]; then
            echo -e "${RED}Could not find created worktree${NC}"
            return 1
        fi

        echo ""
    fi

    local restored_something=false

    # Apply patch if exists
    if [ -f "$patch_file" ]; then
        echo -e "${BLUE}Applying patch...${NC}"

        if git -C "$target_dir" apply --check "$patch_file" 2>/dev/null; then
            if git -C "$target_dir" apply "$patch_file"; then
                echo -e "${GREEN}✓ Patch applied successfully${NC}"
                restored_something=true
            else
                echo -e "${RED}Failed to apply patch${NC}"
                echo -e "${YELLOW}Manual: git apply $patch_file${NC}"
            fi
        else
            echo -e "${YELLOW}⚠️  Patch cannot be applied cleanly${NC}"
            echo "Options:"
            echo "  git apply --3way $patch_file"
            echo "  git apply --reject $patch_file"
        fi
    fi

    # Copy untracked files if exist
    if [ -d "$untracked_dir" ]; then
        echo -e "${BLUE}Restoring untracked files...${NC}"

        find "$untracked_dir" -type f | while read -r file; do
            local rel_path="${file#$untracked_dir/}"
            local dest_file="$target_dir/$rel_path"
            local dest_dir=$(dirname "$dest_file")

            mkdir -p "$dest_dir"

            if [ -f "$dest_file" ]; then
                echo -e "  ${YELLOW}⚠️  Skip (exists): $rel_path${NC}"
            else
                cp "$file" "$dest_file"
                echo -e "  ${GREEN}✓ $rel_path${NC}"
            fi
        done

        restored_something=true
    fi

    if [ "$restored_something" = true ]; then
        echo ""
        echo -e "${GREEN}✓ Restore complete!${NC}"
        echo -e "${DIM}Worktree: $target_dir${NC}"
    fi
}

# Command: editor
# Open worktree in configured editor
# Usage: pwt editor [worktree]
#   If no worktree specified, uses current directory or main app
cmd_editor() {
    local target="${1:-}"
    local worktree_path

    # Get editor from config or default to cursor
    local editor_cmd
    editor_cmd=$(get_project_config "$CURRENT_PROJECT" "editor" 2>/dev/null)
    [ -z "$editor_cmd" ] && editor_cmd="${EDITOR:-cursor}"

    if [ -z "$target" ] || [ "$target" = "@" ]; then
        worktree_path="$MAIN_APP"
    else
        worktree_path=$(cmd_cd "$target" 2>/dev/null)
        if [ -z "$worktree_path" ] || [ ! -d "$worktree_path" ]; then
            echo -e "${RED}Worktree not found: $target${NC}"
            exit 1
        fi
    fi

    echo -e "${BLUE}Opening in $editor_cmd:${NC} $worktree_path"
    "$editor_cmd" "$worktree_path"
}

# Command: ai
# Start AI coding tool in worktree
# Usage: pwt ai [worktree] [-- args...]
cmd_ai() {
    local target="${1:-}"
    local worktree_path
    local ai_args=()

    # Shift past target if provided and not --
    if [ -n "$target" ] && [ "$target" != "--" ]; then
        shift
    else
        target=""
    fi

    # Collect args after --
    if [ "${1:-}" = "--" ]; then
        shift
        ai_args=("$@")
    fi

    # Get AI tool from config or default to claude
    local ai_cmd
    ai_cmd=$(get_project_config "$CURRENT_PROJECT" "ai" 2>/dev/null)
    [ -z "$ai_cmd" ] && ai_cmd="claude"

    if [ -z "$target" ] || [ "$target" = "@" ]; then
        worktree_path="$MAIN_APP"
    else
        worktree_path=$(cmd_cd "$target" 2>/dev/null)
        if [ -z "$worktree_path" ] || [ ! -d "$worktree_path" ]; then
            echo -e "${RED}Worktree not found: $target${NC}"
            exit 1
        fi
    fi

    echo -e "${BLUE}Starting $ai_cmd in:${NC} $worktree_path"
    (cd "$worktree_path" && "$ai_cmd" "${ai_args[@]}")
}

# Command: open
# Open worktree in Finder/file manager
# Usage: pwt open [worktree]
cmd_open() {
    local target="${1:-}"
    local worktree_path

    if [ -z "$target" ] || [ "$target" = "@" ]; then
        worktree_path="$MAIN_APP"
    else
        worktree_path=$(cmd_cd "$target" 2>/dev/null)
        if [ -z "$worktree_path" ] || [ ! -d "$worktree_path" ]; then
            echo -e "${RED}Worktree not found: $target${NC}"
            exit 1
        fi
    fi

    echo -e "${BLUE}Opening in Finder:${NC} $worktree_path"
    open "$worktree_path"
}

# Command: diff
# Show diff between worktrees or worktree vs main
# Usage: pwt diff <worktree1> [worktree2]
cmd_diff() {
    # Handle --help
    if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
        echo "Usage: pwt diff <worktree1> [worktree2]"
        echo ""
        echo "Show file differences between worktrees."
        echo ""
        echo "Arguments:"
        echo "  worktree1  First worktree to compare"
        echo "  worktree2  Second worktree (default: @ for main app)"
        echo ""
        echo "Examples:"
        echo "  pwt diff TICKET-123         # Compare TICKET-123 vs main"
        echo "  pwt diff TICKET-123 @       # Same as above"
        echo "  pwt diff TICKET-123 TICKET-456  # Compare two worktrees"
        return 0
    fi

    local wt1="$1"
    local wt2="${2:-@}"

    if [ -z "$wt1" ]; then
        echo -e "${RED}Usage: pwt diff <worktree1> [worktree2]${NC}"
        echo "  worktree2 defaults to @ (main app)"
        exit 1
    fi

    local path1 path2

    # Resolve worktree1
    if [ "$wt1" = "@" ]; then
        path1="$MAIN_APP"
    else
        path1=$(cmd_cd "$wt1" 2>/dev/null)
        if [ -z "$path1" ] || [ ! -d "$path1" ]; then
            echo -e "${RED}Worktree not found: $wt1${NC}"
            exit 1
        fi
    fi

    # Resolve worktree2
    if [ "$wt2" = "@" ]; then
        path2="$MAIN_APP"
    else
        path2=$(cmd_cd "$wt2" 2>/dev/null)
        if [ -z "$path2" ] || [ ! -d "$path2" ]; then
            echo -e "${RED}Worktree not found: $wt2${NC}"
            exit 1
        fi
    fi

    echo -e "${BLUE}Comparing:${NC}"
    echo "  $wt1: $path1"
    echo "  $wt2: $path2"
    echo ""

    # Get branch and commit info
    local branch1=$(git -C "$path1" branch --show-current 2>/dev/null || echo "detached")
    local branch2=$(git -C "$path2" branch --show-current 2>/dev/null || echo "detached")
    local commit1=$(git -C "$path1" rev-parse HEAD 2>/dev/null)
    local commit2=$(git -C "$path2" rev-parse HEAD 2>/dev/null)

    if [ -z "$commit1" ] || [ -z "$commit2" ]; then
        echo -e "${RED}Error: Could not get commit hashes${NC}"
        exit 1
    fi

    echo -e "${BLUE}Branches:${NC} $branch1 vs $branch2"
    echo -e "${BLUE}Commits:${NC} ${commit1:0:8} vs ${commit2:0:8}"
    echo ""

    # Show git diff using commit hashes (works across worktrees via main repo)
    git -C "$MAIN_APP" diff "$commit2".."$commit1" --stat
}

# Command: copy
# Copy files between worktrees
# Usage: pwt copy <src> <dest> <patterns...>
#   src/dest can be @ for main app
cmd_copy() {
    local src="$1"
    local dest="$2"
    shift 2

    if [ -z "$src" ] || [ -z "$dest" ] || [ $# -eq 0 ]; then
        echo -e "${RED}Usage: pwt copy <src> <dest> <patterns...>${NC}"
        echo "  src/dest can be @ for main app"
        echo ""
        echo "Examples:"
        echo "  pwt copy @ TICKET-123 \".env*\"          # main → worktree"
        echo "  pwt copy TICKET-123 @ \".env*\"          # worktree → main"
        echo "  pwt copy TICKET-123 TICKET-456 \"*.json\" # between worktrees"
        exit 1
    fi

    local src_path dest_path

    # Resolve source
    if [ "$src" = "@" ]; then
        src_path="$MAIN_APP"
    else
        src_path=$(cmd_cd "$src" 2>/dev/null)
        if [ -z "$src_path" ] || [ ! -d "$src_path" ]; then
            echo -e "${RED}Worktree not found: $src${NC}"
            exit 1
        fi
    fi

    # Resolve destination
    if [ "$dest" = "@" ]; then
        dest_path="$MAIN_APP"
    else
        dest_path=$(cmd_cd "$dest" 2>/dev/null)
        if [ -z "$dest_path" ] || [ ! -d "$dest_path" ]; then
            echo -e "${RED}Worktree not found: $dest${NC}"
            exit 1
        fi
    fi

    echo -e "${BLUE}Copying from $src to $dest:${NC}"

    local count=0
    for pattern in "$@"; do
        # Use find with -name (pattern is a filename glob, not a path)
        while IFS= read -r -d '' file; do
            local rel_path="${file#$src_path/}"
            local dest_file="$dest_path/$rel_path"

            # Create parent directory if needed
            mkdir -p "$(dirname "$dest_file")"

            cp "$file" "$dest_file"
            echo "  ✓ $rel_path"
            count=$((count + 1))
        done < <(find "$src_path" -name "$pattern" -type f -print0 2>/dev/null)
    done

    if [ $count -eq 0 ]; then
        echo "  No files matched"
    else
        echo -e "${GREEN}Copied $count file(s)${NC}"
    fi
}

# Command: doctor
# Check system health and configuration
# Usage: pwt doctor
cmd_doctor() {
    # Handle --help
    if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
        echo "Usage: pwt doctor"
        echo ""
        echo "Check system health and pwt configuration."
        echo ""
        echo "Checks performed:"
        echo "  - Required tools (git, jq)"
        echo "  - Optional tools (lsof, fzf)"
        echo "  - PWT directory structure"
        echo "  - Project configurations"
        echo "  - Worktree integrity"
        return 0
    fi

    echo -e "${BLUE}pwt doctor${NC}"
    echo ""

    local errors=0

    # Check git
    if command -v git &>/dev/null; then
        local git_version=$(git --version | cut -d' ' -f3)
        echo -e "${GREEN}✓${NC} Git: $git_version"
    else
        echo -e "${RED}✗${NC} Git: not installed"
        errors=$((errors + 1))
    fi

    # Check jq
    if command -v jq &>/dev/null; then
        local jq_version=$(jq --version 2>/dev/null || echo "?")
        echo -e "${GREEN}✓${NC} jq: $jq_version"
    else
        echo -e "${RED}✗${NC} jq: not installed (required)"
        errors=$((errors + 1))
    fi

    # Check lsof
    if has_lsof; then
        echo -e "${GREEN}✓${NC} lsof: installed"
    else
        echo -e "${YELLOW}⚠${NC} lsof: not installed (port detection will be limited)"
        echo "    macOS:  (should be pre-installed)"
        echo "    Ubuntu: sudo apt install lsof"
    fi

    # Check fzf
    if command -v fzf &>/dev/null; then
        local fzf_version=$(fzf --version 2>/dev/null | head -1 || echo "?")
        echo -e "${GREEN}✓${NC} fzf: $fzf_version"
    else
        echo -e "${YELLOW}⚠${NC} fzf: not installed (needed for pwt select)"
    fi

    echo ""

    # Check project configuration
    if [ -n "$CURRENT_PROJECT" ]; then
        echo -e "${GREEN}✓${NC} Project: $CURRENT_PROJECT"

        if [ -n "$MAIN_APP" ] && [ -d "$MAIN_APP" ]; then
            echo -e "${GREEN}✓${NC} Main app: $MAIN_APP"
        else
            echo -e "${RED}✗${NC} Main app: not found"
            errors=$((errors + 1))
        fi

        if [ -n "$WORKTREES_DIR" ]; then
            if [ -d "$WORKTREES_DIR" ]; then
                local wt_count=$(ls -d "$WORKTREES_DIR"/*/ 2>/dev/null | wc -l | tr -d ' ')
                echo -e "${GREEN}✓${NC} Worktrees dir: $WORKTREES_DIR ($wt_count worktrees)"
            else
                echo -e "${YELLOW}⚠${NC} Worktrees dir: $WORKTREES_DIR (not created yet)"
            fi
        fi

        # Check Pwtfile
        if [ -n "${PWTFILE:-}" ] && [ -f "$PWTFILE" ]; then
            echo -e "${GREEN}✓${NC} Pwtfile: $PWTFILE"
        elif [ -f "$MAIN_APP/Pwtfile" ]; then
            echo -e "${GREEN}✓${NC} Pwtfile: $MAIN_APP/Pwtfile"
        else
            echo -e "${YELLOW}⚠${NC} Pwtfile: not found (optional)"
        fi

        # Check editor config
        local editor_cfg=$(get_project_config "$CURRENT_PROJECT" "editor" 2>/dev/null)
        if [ -n "$editor_cfg" ]; then
            if command -v "$editor_cfg" &>/dev/null; then
                echo -e "${GREEN}✓${NC} Editor: $editor_cfg"
            else
                echo -e "${YELLOW}⚠${NC} Editor: $editor_cfg (not found in PATH)"
            fi
        fi

        # Check AI config
        local ai_cfg=$(get_project_config "$CURRENT_PROJECT" "ai" 2>/dev/null)
        if [ -n "$ai_cfg" ]; then
            if command -v "$ai_cfg" &>/dev/null; then
                echo -e "${GREEN}✓${NC} AI: $ai_cfg"
            else
                echo -e "${YELLOW}⚠${NC} AI: $ai_cfg (not found in PATH)"
            fi
        fi
    else
        echo -e "${YELLOW}⚠${NC} Project: not detected (run from project directory)"
    fi

    echo ""
    if [ $errors -gt 0 ]; then
        echo -e "${RED}$errors error(s) found${NC}"
        exit 1
    else
        echo -e "${GREEN}All checks passed!${NC}"
    fi
}

# Command: select
# Interactive worktree selector using fzf
# Usage: pwt select [--preview] [--dirty]
cmd_select() {
    local show_preview=true
    local show_dirty_only=false

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --preview|-p)
                show_preview=true
                shift
                ;;
            --no-preview)
                show_preview=false
                shift
                ;;
            --dirty)
                show_dirty_only=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    # Check if fzf is installed
    if ! command -v fzf &>/dev/null; then
        echo -e "${RED}Error: fzf is required for pwt select${NC}"
        echo "Install with: brew install fzf"
        exit 1
    fi

    # Build enriched list of worktrees
    # Format: name|branch|port|status|marker|description
    local items=()

    # Add main app
    if [ -d "$MAIN_APP" ]; then
        local main_branch=$(git -C "$MAIN_APP" branch --show-current 2>/dev/null || echo "main")
        local main_status=$(get_status_symbols "$MAIN_APP")
        if [ "$show_dirty_only" = false ] || [ -n "$main_status" ]; then
            items+=("@|$main_branch|·|${main_status:-·}|·|main app")
        fi
    fi

    # Add worktrees with metadata
    if [ -d "$WORKTREES_DIR" ] && [ "$(ls -A "$WORKTREES_DIR" 2>/dev/null)" ]; then
        for dir in "$WORKTREES_DIR"/*/; do
            [ -d "$dir" ] || continue
            local name=$(basename "$dir")
            local branch=$(git -C "$dir" branch --show-current 2>/dev/null || echo "?")
            local port=$(get_metadata "$name" "port")
            local marker=$(get_metadata "$name" "marker")
            local desc=$(get_metadata "$name" "description")
            local status=$(get_status_symbols "$dir")

            # Filter by dirty if requested
            if [ "$show_dirty_only" = true ] && [ -z "$status" ]; then
                continue
            fi

            # Truncate description to 30 chars
            [ -n "$desc" ] && desc="${desc:0:30}"

            items+=("$name|$branch|:${port:-·}|${status:-·}|${marker:-·}|${desc:-·}")
        done
    fi

    if [ ${#items[@]} -eq 0 ]; then
        if [ "$show_dirty_only" = true ]; then
            echo -e "${YELLOW}No dirty worktrees found${NC}"
        else
            echo -e "${YELLOW}No worktrees found${NC}"
        fi
        exit 0
    fi

    # Format with column for aligned display
    local formatted
    formatted=$(printf '%s\n' "${items[@]}" | column -t -s'|')

    # Build preview command
    local preview_cmd="name=\$(echo {} | awk '{print \$1}'); "
    preview_cmd+="if [ \"\$name\" = \"@\" ]; then "
    preview_cmd+="  echo '=== Main App ===' && git -C \"$MAIN_APP\" status -sb && echo '' && git -C \"$MAIN_APP\" diff --stat 2>/dev/null | head -15; "
    preview_cmd+="else "
    preview_cmd+="  pwt info \"\$name\" 2>/dev/null || (echo \"Worktree: \$name\" && git -C \"$WORKTREES_DIR/\$name\" status -sb && echo '' && git -C \"$WORKTREES_DIR/\$name\" diff --stat 2>/dev/null | head -15); "
    preview_cmd+="fi"

    # Run fzf with enhanced options
    local fzf_opts=(
        --height=60%
        --reverse
        --ansi
        --header=$'Worktree selector\n↵:cd  ^E:editor  ^A:ai  ^O:open  Esc:cancel'
        --bind="ctrl-e:execute-silent(pwt editor \$(echo {} | awk '{print \$1}'))+abort"
        --bind="ctrl-a:execute-silent(pwt ai \$(echo {} | awk '{print \$1}'))+abort"
        --bind="ctrl-o:execute-silent(pwt open \$(echo {} | awk '{print \$1}'))+abort"
    )

    if [ "$show_preview" = true ]; then
        fzf_opts+=(
            --preview="$preview_cmd"
            --preview-window=right:45%:wrap
        )
    fi

    local selected
    selected=$(echo "$formatted" | fzf "${fzf_opts[@]}")

    if [ -z "$selected" ]; then
        exit 0
    fi

    # Extract worktree name (first column)
    local target=$(echo "$selected" | awk '{print $1}')

    # Output for shell function to cd
    if [ "$target" = "@" ]; then
        echo "$MAIN_APP"
    else
        echo "$WORKTREES_DIR/$target"
    fi
}

# Internal command: _select
# Used by shell function to get selection and cd
cmd__select() {
    local result
    result=$(cmd_select "$@")
    echo "$result"
}

# Command: pick
# Interactive selector + auto-use (sets current symlink)
# Usage: pwt pick [--dirty]
#   Like select, but automatically runs 'pwt use' on selection
cmd_pick() {
    local show_dirty_only=false

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --dirty)
                show_dirty_only=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    # Check if fzf is installed
    if ! command -v fzf &>/dev/null; then
        echo -e "${RED}Error: fzf is required for pwt pick${NC}"
        echo "Install with: brew install fzf"
        exit 1
    fi

    # Build enriched list of worktrees (same as select)
    local items=()

    # Add main app
    if [ -d "$MAIN_APP" ]; then
        local main_branch=$(git -C "$MAIN_APP" branch --show-current 2>/dev/null || echo "main")
        local main_status=$(get_status_symbols "$MAIN_APP")
        if [ "$show_dirty_only" = false ] || [ -n "$main_status" ]; then
            items+=("@|$main_branch|·|${main_status:-·}|·|main app")
        fi
    fi

    # Add worktrees with metadata
    if [ -d "$WORKTREES_DIR" ] && [ "$(ls -A "$WORKTREES_DIR" 2>/dev/null)" ]; then
        for dir in "$WORKTREES_DIR"/*/; do
            [ -d "$dir" ] || continue
            local name=$(basename "$dir")
            local branch=$(git -C "$dir" branch --show-current 2>/dev/null || echo "?")
            local port=$(get_metadata "$name" "port")
            local marker=$(get_metadata "$name" "marker")
            local desc=$(get_metadata "$name" "description")
            local status=$(get_status_symbols "$dir")

            if [ "$show_dirty_only" = true ] && [ -z "$status" ]; then
                continue
            fi

            [ -n "$desc" ] && desc="${desc:0:30}"
            items+=("$name|$branch|:${port:-·}|${status:-·}|${marker:-·}|${desc:-·}")
        done
    fi

    if [ ${#items[@]} -eq 0 ]; then
        if [ "$show_dirty_only" = true ]; then
            echo -e "${YELLOW}No dirty worktrees found${NC}"
        else
            echo -e "${YELLOW}No worktrees found${NC}"
        fi
        exit 0
    fi

    local formatted
    formatted=$(printf '%s\n' "${items[@]}" | column -t -s'|')

    # Build preview command
    local preview_cmd="name=\$(echo {} | awk '{print \$1}'); "
    preview_cmd+="if [ \"\$name\" = \"@\" ]; then "
    preview_cmd+="  echo '=== Main App ===' && git -C \"$MAIN_APP\" status -sb; "
    preview_cmd+="else "
    preview_cmd+="  pwt info \"\$name\" 2>/dev/null || echo \"Worktree: \$name\"; "
    preview_cmd+="fi"

    # Run fzf
    local selected
    selected=$(echo "$formatted" | fzf \
        --height=60% \
        --reverse \
        --ansi \
        --header=$'Pick worktree to set as current\n↵:use  Esc:cancel' \
        --preview="$preview_cmd" \
        --preview-window=right:45%:wrap)

    if [ -z "$selected" ]; then
        exit 0
    fi

    # Extract worktree name and call use
    local target=$(echo "$selected" | awk '{print $1}')
    cmd_use "$target"
}

# Command: for-each
# Run command in all worktrees
# Usage: pwt for-each <command...>
# If command is a Pwtfile function, runs it via run_pwtfile
cmd_for_each() {
    # Handle --help
    if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
        echo "Usage: pwt for-each <command...>"
        echo ""
        echo "Run a command in all worktrees."
        echo ""
        echo "Arguments:"
        echo "  command    Command to run in each worktree"
        echo ""
        echo "Notes:"
        echo "  - If command is a Pwtfile function, runs it via Pwtfile"
        echo "  - Skips main app, only runs in worktrees"
        echo ""
        echo "Examples:"
        echo "  pwt for-each git status"
        echo "  pwt for-each npm test"
        echo "  pwt for-each migrate      # Runs Pwtfile migrate()"
        return 0
    fi

    if [ $# -eq 0 ]; then
        echo -e "${RED}Error: No command specified${NC}"
        echo "Usage: pwt for-each <command...>"
        exit 1
    fi

    local first_arg="$1"
    local is_pwtfile_cmd=false

    # Check if first arg is a Pwtfile command
    if has_pwtfile_command "$first_arg"; then
        is_pwtfile_cmd=true
    fi

    local cmd="$*"
    local count=0

    # Helper to run command in a worktree
    _run_in_worktree() {
        local wt_name="$1"
        local wt_path="$2"
        shift 2

        if [ "$is_pwtfile_cmd" = true ]; then
            # Run as Pwtfile command
            PWT_WORKTREE="$wt_name"
            PWT_WORKTREE_PATH="$wt_path"
            PWT_PORT=$(get_metadata "$wt_name" "port" 2>/dev/null || echo "")
            PWT_BRANCH=$(get_metadata "$wt_name" "branch" 2>/dev/null || echo "")
            export PWT_ARGS="${*:2}"  # All args after command name
            (
                cd "$wt_path" || exit 1
                run_pwtfile "$first_arg"
            )
        else
            # Run as shell command
            (
                cd "$wt_path" || exit 1
                export PWT_WORKTREE="$wt_name"
                export PWT_WORKTREE_PATH="$wt_path"
                eval "$cmd"
            )
        fi
    }

    # Run in main app
    echo -e "${BLUE}=== @ (main) ===${NC}"
    _run_in_worktree "@" "$MAIN_APP" "$@"
    echo ""

    # Run in worktrees
    if [ -d "$WORKTREES_DIR" ] && [ "$(ls -A "$WORKTREES_DIR" 2>/dev/null)" ]; then
        for dir in "$WORKTREES_DIR"/*/; do
            [ -d "$dir" ] || continue
            local name=$(basename "$dir")
            count=$((count + 1))

            echo -e "${BLUE}=== $name ===${NC}"
            _run_in_worktree "$name" "$dir" "$@"
            echo ""
        done
    fi

    echo -e "${GREEN}✓ Ran in $((count + 1)) worktrees${NC}"
}

# Command: steps
# List available steps from Pwtfile (functions prefixed with step_)
# Usage: pwt steps
cmd_steps() {
    detect_project
    local pwtfile=$(get_project_pwtfile)

    if [ -z "$pwtfile" ] || [ ! -f "$pwtfile" ]; then
        echo -e "${RED}No Pwtfile found${NC}"
        return 1
    fi

    # Extract step_* function names
    local steps
    steps=$(grep -oE "^step_[a-zA-Z0-9_]+" "$pwtfile" 2>/dev/null | sed 's/^step_//' | sort -u || true)

    if [ -z "$steps" ]; then
        echo -e "${YELLOW}No steps found in Pwtfile${NC}"
        echo "Steps are functions prefixed with 'step_', e.g.:"
        echo "  step_install_deps() { bundle install; }"
        return 0
    fi

    echo -e "${BLUE}Steps ($CURRENT_PROJECT):${NC}"
    echo "$steps" | while read -r step; do
        echo "  $step"
    done
    echo ""
    echo "Usage: pwt step <name>"
}

# Command: step
# Run a single step from Pwtfile
# Usage: pwt step <name> [args...]
cmd_step() {
    local step_name="${1:-}"

    if [ -z "$step_name" ]; then
        echo "Usage: pwt step <name>"
        echo "Run 'pwt steps' to list available steps"
        return 1
    fi

    detect_project
    local pwtfile=$(get_project_pwtfile)
    local func_name="step_${step_name}"

    if [ -z "$pwtfile" ] || [ ! -f "$pwtfile" ]; then
        echo -e "${RED}No Pwtfile found${NC}"
        return 1
    fi

    if ! has_command_in_file "$pwtfile" "$func_name"; then
        echo -e "${RED}Step not found: $step_name${NC}"
        echo "Run 'pwt steps' to list available steps"
        return 1
    fi

    # Set up context from current directory
    local current_dir=$(pwd -P)
    local resolved_worktrees_dir=""
    local resolved_main_app=""

    if [ -n "$WORKTREES_DIR" ] && [ -d "$WORKTREES_DIR" ]; then
        resolved_worktrees_dir=$(cd "$WORKTREES_DIR" 2>/dev/null && pwd -P)
    fi
    if [ -n "$MAIN_APP" ] && [ -d "$MAIN_APP" ]; then
        resolved_main_app=$(cd "$MAIN_APP" 2>/dev/null && pwd -P)
    fi

    if [ -n "$resolved_worktrees_dir" ] && [[ "$current_dir" == "$resolved_worktrees_dir"/* ]]; then
        PWT_WORKTREE=$(basename "$current_dir")
        PWT_WORKTREE_PATH="$current_dir"
        PWT_PORT=$(get_metadata "$PWT_WORKTREE" "port" 2>/dev/null || echo "")
        PWT_BRANCH=$(get_metadata "$PWT_WORKTREE" "branch" 2>/dev/null || echo "")
    elif [ -n "$resolved_main_app" ] && [[ "$current_dir" == "$resolved_main_app"* ]]; then
        PWT_WORKTREE="@"
        PWT_WORKTREE_PATH="$resolved_main_app"
        PWT_PORT=""
        PWT_BRANCH=$(git -C "$MAIN_APP" branch --show-current 2>/dev/null || echo "master")
    else
        PWT_WORKTREE="@"
        PWT_WORKTREE_PATH="${resolved_main_app:-$MAIN_APP}"
        PWT_PORT=""
        PWT_BRANCH=$(git -C "$MAIN_APP" branch --show-current 2>/dev/null || echo "master")
    fi

    shift  # Remove step name
    export PWT_ARGS="$*"

    run_single_pwtfile "$pwtfile" "$func_name" "Step"
}

# Command: shell-init
# Output shell function for cd integration
# Usage: eval "$(pwt shell-init)"
cmd_shell_init() {
    local pwt_path
    pwt_path=$(which pwt 2>/dev/null || echo "$0")

    cat << EOF
# pwt shell integration
# Add to ~/.zshrc: eval "\$(pwt shell-init)"
pwt() {
    if [[ "\$1" == "cd" ]] || [[ "\$2" == "cd" ]]; then
        # pwt cd or pwt <project> cd - change to worktree directory
        local input target
        if [[ "\$1" == "cd" ]]; then
            input="\$2"
        else
            # pwt <project> cd <target>
            local project="\$1"
            input="\$3"
        fi

        # Handle "-" for previous worktree (like cd -)
        if [[ "\$input" == "-" ]]; then
            if [[ -z "\$PWT_PREVIOUS_PATH" ]]; then
                echo "No previous worktree" >&2
                return 1
            fi
            target="\$PWT_PREVIOUS_PATH"
        else
            if [[ "\$1" == "cd" ]]; then
                target=\$("$pwt_path" _cd "\$input" 2>&1)
            else
                target=\$("$pwt_path" "\$project" _cd "\$input" 2>&1)
            fi
            if [[ \$? -ne 0 ]] || [[ ! -d "\$target" ]]; then
                echo "\$target"
                return 1
            fi
        fi

        # Save current path as previous (if different)
        if [[ "\$PWD" != "\$target" ]]; then
            export PWT_PREVIOUS_PATH="\$PWD"
        fi

        builtin cd "\$target"

        # Set PWT_WORKTREE for prompts and scripts
        if [[ "\$target" == *"-worktrees/"* ]]; then
            export PWT_WORKTREE=\$(basename "\$target")
        else
            unset PWT_WORKTREE
        fi
    elif [[ "\$1" == "select" ]] || [[ "\$2" == "select" ]]; then
        # pwt select or pwt <project> select - interactive selection with cd
        local target
        if [[ "\$1" == "select" ]]; then
            shift
            target=\$("$pwt_path" _select "\$@" 2>&1)
        else
            # pwt <project> select
            local project="\$1"
            shift 2
            target=\$("$pwt_path" "\$project" _select "\$@" 2>&1)
        fi
        if [[ \$? -ne 0 ]] || [[ -z "\$target" ]]; then
            [[ -n "\$target" ]] && echo "\$target"
            return 0
        fi
        if [[ ! -d "\$target" ]]; then
            echo "\$target"
            return 1
        fi

        # Save current path as previous (if different)
        if [[ "\$PWD" != "\$target" ]]; then
            export PWT_PREVIOUS_PATH="\$PWD"
        fi

        builtin cd "\$target"

        # Set PWT_WORKTREE for prompts and scripts
        if [[ "\$target" == *"-worktrees/"* ]]; then
            export PWT_WORKTREE=\$(basename "\$target")
        else
            unset PWT_WORKTREE
        fi
    elif [[ "\$1" == "use" ]] || [[ "\$2" == "use" ]]; then
        # pwt use or pwt <project> use - run command then follow symlink if inside current
        "$pwt_path" "\$@"
        local exit_code=\$?

        # If we're inside a 'current' symlink, cd to follow it
        if [[ "\$PWD" == *"/current" ]] || [[ "\$PWD" == *"/current/"* ]]; then
            # Re-enter the symlink to follow the new target
            local current_path="\${PWD%%/current*}/current"
            if [[ -L "\$current_path" ]]; then
                builtin cd "\$current_path"
                export PWT_WORKTREE=\$(basename "\$(readlink "\$current_path")")
            fi
        fi
        return \$exit_code
    else
        "$pwt_path" "\$@"
    fi
}
EOF
}

# Command: setup-shell
# Install shell integration into user's shell config
# Usage: pwt setup-shell
cmd_setup_shell() {
    local shell_name=$(basename "$SHELL")
    local rc_file=""
    local init_line='eval "$(pwt shell-init)"'
    local needs_source=false

    # Detect shell config file
    case "$shell_name" in
        zsh)
            rc_file="$HOME/.zshrc"
            ;;
        bash)
            # macOS uses .bash_profile, Linux uses .bashrc
            if [ -f "$HOME/.bash_profile" ]; then
                rc_file="$HOME/.bash_profile"
            else
                rc_file="$HOME/.bashrc"
            fi
            ;;
        fish)
            rc_file="$HOME/.config/fish/config.fish"
            init_line='pwt shell-init | source'
            ;;
        *)
            echo -e "${RED}Unsupported shell: $shell_name${NC}"
            echo "Add manually to your shell config:"
            echo "  $init_line"
            return 1
            ;;
    esac

    # Check/add shell-init integration
    if grep -q "pwt shell-init" "$rc_file" 2>/dev/null; then
        echo -e "${GREEN}✓ Shell integration already configured${NC}"
    else
        echo "" >> "$rc_file"
        echo "# pwt shell integration (added by pwt setup-shell)" >> "$rc_file"
        echo "$init_line" >> "$rc_file"
        echo -e "${GREEN}✓ Shell integration installed${NC}"
        needs_source=true
    fi

    # Check/add subshell prompt indicator (zsh/bash only)
    if [[ "$shell_name" == "zsh" || "$shell_name" == "bash" ]]; then
        if grep -q "PWT_SHELL" "$rc_file" 2>/dev/null; then
            echo -e "${GREEN}✓ Subshell prompt already configured${NC}"
        else
            echo "" >> "$rc_file"
            echo "# pwt subshell prompt indicator (added by pwt setup-shell)" >> "$rc_file"
            if [[ "$shell_name" == "zsh" ]]; then
                echo '[[ -n "$PWT_SHELL" ]] && PROMPT="%F{blue}(pwt)%f $PROMPT"' >> "$rc_file"
            else
                echo '[[ -n "$PWT_SHELL" ]] && PS1="(pwt) $PS1"' >> "$rc_file"
            fi
            echo -e "${GREEN}✓ Subshell prompt indicator installed${NC}"
            needs_source=true
        fi
    fi

    echo "  File: $rc_file"

    if [ "$needs_source" = true ]; then
        echo ""
        echo "To activate now, run:"
        echo -e "  ${BLUE}source $rc_file${NC}"
        echo ""
        echo "Or restart your terminal."
    fi
}

# Command: claude-setup
# Install Claude Code status line integration for pwt
cmd_claude_setup() {
    local action="${1:-install}"
    local claude_dir="$HOME/.claude"
    local script_file="$claude_dir/statusline-command.sh"
    local config_file="$PWT_DIR/claude-statusline.json"
    local default_format='[{worktree}] {project} ({branch}) [{server}] {arrow}'

    case "$action" in
        -h|--help|help)
            echo "Usage: pwt claude-setup [action]"
            echo ""
            echo "Manage Claude Code status line integration."
            echo ""
            echo "Actions:"
            echo "  install              Install/update status line script (default)"
            echo "  vars                 Show all available variables and colors"
            echo "  format [fmt]         Show or set global format"
            echo "  format --project [fmt]  Set format for current project only"
            echo "  preview              Preview status line with current settings"
            echo "  test                 Run color and template engine tests"
            echo "  toggle               Toggle status line on/off globally"
            echo "  toggle --session     Toggle for current session only"
            echo "  on | off             Enable/disable globally"
            echo "  on|off --session     Show command for session toggle"
            echo "  pwt-only [on|off]    Only show in pwt projects/worktrees"
            echo "  reset                Reset to default configuration"
            echo ""
            echo "Format Template:"
            echo "  Use {variable} placeholders with any text around them."
            echo "  Run 'pwt claude-setup vars' to see all variables."
            echo ""
            echo "Priority: Project format > Global format > Default"
            echo ""
            echo "Examples:"
            echo "  pwt claude-setup                              # Install"
            echo "  pwt claude-setup vars                         # List variables"
            echo "  pwt claude-setup format                       # Show formats"
            echo "  pwt claude-setup format '{project} ({branch}) {arrow}'"
            echo "  pwt claude-setup format --project '{project} {arrow}'  # This project only"
            echo "  pwt claude-setup preview                      # Test output"
            return 0
            ;;

        vars)
            echo "Available variables for status line format:"
            echo ""
            echo "  {worktree}   Worktree name (e.g., 'mobile-ux-fixes')"
            echo "  {project}    Project name (e.g., 'dropflow-app')"
            echo "  {branch}     Git branch name"
            echo "  {server}     Server URL if running (e.g., 'localhost:4001')"
            echo "  {port}       Just the port number (e.g., '4001')"
            echo "  {arrow}      Arrow symbol (default: ❯)"
            echo ""
            echo "Named Colors:"
            echo "  {magenta:...}   Magenta text"
            echo "  {cyan:...}      Cyan text"
            echo "  {yellow:...}    Yellow text"
            echo "  {green:...}     Green text"
            echo "  {blue:...}      Blue text"
            echo "  {red:...}       Red text"
            echo "  {dim:...}       Dimmed text"
            echo "  {bold:...}      Bold text"
            echo ""
            echo "Custom Colors (24-bit true color):"
            echo "  {rgb:R,G,B:...}    RGB values 0-255 (e.g., {rgb:255,100,0:text})"
            echo "  {#RRGGBB:...}      Hex color (e.g., {#FF6400:text})"
            echo ""
            echo "Conditionals (show only if value exists):"
            echo "  {?worktree:[...]}   Show [...] only if worktree exists"
            echo "  {?server:[...]}     Show [...] only if server is running"
            echo "  {?branch:(...)}     Show (...) only if branch exists"
            echo ""
            echo "Default format:"
            echo "  $default_format"
            echo ""
            echo "Custom Variables (from Pwtfile):"
            echo "  Static:   CLAUDE_ENV=\"staging\"     -> use as {env}"
            echo "  Dynamic:  claude_env() { ... }      -> use as {env}"
            echo ""
            echo "  Available in functions: \$PWT_WORKTREE, \$PWT_PROJECT, \$PWT_PORT, \$PWT_BRANCH"
            echo ""
            echo "Example formats:"
            echo "  '{project} {arrow}'                           # Minimal"
            echo "  '{?worktree:[{worktree}] }{project} {arrow}'  # Conditional worktree"
            echo "  '{project}/{worktree} ({branch}) {arrow}'     # Slash separator"
            echo "  '{cyan:{project}} {yellow:({branch})} {arrow}' # Explicit colors"
            echo "  '{project} [{env}] {arrow}'                   # Custom var from Pwtfile"
            return 0
            ;;

        format)
            local scope="${2:-}"
            local new_format="${3:-}"

            # Check if second arg is a format (not --project)
            if [ -n "$scope" ] && [[ "$scope" != "--project" ]]; then
                new_format="$scope"
                scope=""
            fi

            if [ "$scope" = "--project" ]; then
                # Project-specific format
                if [ -z "$CURRENT_PROJECT" ]; then
                    echo -e "${RED}Error: No project detected. Run from inside a project.${NC}"
                    return 1
                fi

                local proj_config="$PWT_PROJECTS_DIR/$CURRENT_PROJECT/config.json"
                mkdir -p "$(dirname "$proj_config")"
                [ ! -f "$proj_config" ] && echo '{}' > "$proj_config"

                if [ -n "$new_format" ]; then
                    local tmp=$(mktemp)
                    jq --arg fmt "$new_format" '.claude_format = $fmt' "$proj_config" > "$tmp" && mv "$tmp" "$proj_config"
                    echo -e "${GREEN}✓ Project format set for $CURRENT_PROJECT${NC}"
                    echo "  $new_format"
                else
                    local proj_format=$(jq -r '.claude_format // ""' "$proj_config" 2>/dev/null)
                    if [ -n "$proj_format" ]; then
                        echo "Project format ($CURRENT_PROJECT):"
                        echo "  $proj_format"
                    else
                        echo "No project-specific format for $CURRENT_PROJECT"
                        echo "Using global format: $default_format"
                    fi
                fi
                echo ""
                echo "Run 'pwt claude-setup install' to apply."
            elif [ -n "$new_format" ]; then
                # Set global format
                [ ! -f "$config_file" ] && echo '{}' > "$config_file"
                local tmp=$(mktemp)
                jq --arg fmt "$new_format" '.format = $fmt' "$config_file" > "$tmp" && mv "$tmp" "$config_file"
                echo -e "${GREEN}✓ Global format set${NC}"
                echo "  $new_format"
                echo ""
                echo "Run 'pwt claude-setup install' to apply."
            else
                # Show current format
                echo "Global format:"
                local current_format="$default_format"
                if [ -f "$config_file" ]; then
                    current_format=$(jq -r '.format // ""' "$config_file")
                    [ -z "$current_format" ] && current_format="$default_format"
                fi
                echo "  $current_format"

                # Show project format if inside a project
                if [ -n "$CURRENT_PROJECT" ]; then
                    local proj_config="$PWT_PROJECTS_DIR/$CURRENT_PROJECT/config.json"
                    if [ -f "$proj_config" ]; then
                        local proj_format=$(jq -r '.claude_format // ""' "$proj_config" 2>/dev/null)
                        if [ -n "$proj_format" ]; then
                            echo ""
                            echo "Project format ($CURRENT_PROJECT):"
                            echo "  $proj_format"
                        fi
                    fi
                fi
                echo ""
                echo "To change global:  pwt claude-setup format '<format>'"
                echo "To change project: pwt claude-setup format --project '<format>'"
                echo "See variables:     pwt claude-setup vars"
            fi
            return 0
            ;;

        preview)
            # Generate preview with current directory
            local current_format="$default_format"
            if [ -f "$config_file" ]; then
                current_format=$(jq -r '.format // ""' "$config_file")
                [ -z "$current_format" ] && current_format="$default_format"
            fi

            local cwd=$(pwd)
            local worktree_name="" project_name=""

            if [[ "$cwd" =~ ([^/]+)-worktrees/([^/]+) ]]; then
                project_name="${BASH_REMATCH[1]}"
                worktree_name="${BASH_REMATCH[2]}"
            elif [[ "$cwd" =~ \.pwt/([^/]+) ]]; then
                worktree_name="${BASH_REMATCH[1]}"
            fi
            [ -z "$project_name" ] && project_name=$(basename "$cwd")

            local branch=""
            if git rev-parse --git-dir >/dev/null 2>&1; then
                branch=$(git branch --show-current 2>/dev/null)
            fi

            local port="" server=""
            if [ -n "$worktree_name" ] && [ -f "$PWT_META_FILE" ]; then
                port=$(jq -r --arg wt "$worktree_name" '.[] | .[$wt]? | select(.) | .port // empty' "$PWT_META_FILE" 2>/dev/null | head -1)
                if [ -n "$port" ] && lsof -ti :$port -sTCP:LISTEN >/dev/null 2>&1; then
                    server="localhost:$port"
                fi
            fi

            echo "Preview with current directory:"
            echo "  worktree: ${worktree_name:-<none>}"
            echo "  project:  $project_name"
            echo "  branch:   ${branch:-<none>}"
            echo "  server:   ${server:-<not running>}"
            echo "  port:     ${port:-<none>}"
            echo ""
            echo "Format: $current_format"
            echo ""
            echo -n "Output: "
            # Simple preview (without full template engine)
            local output="$current_format"
            output="${output//\{worktree\}/$worktree_name}"
            output="${output//\{project\}/$project_name}"
            output="${output//\{branch\}/$branch}"
            output="${output//\{server\}/$server}"
            output="${output//\{port\}/$port}"
            output="${output//\{arrow\}/❯}"
            echo -e "$output"
            return 0
            ;;

        reset)
            rm -f "$config_file"
            echo -e "${GREEN}✓ Configuration reset to defaults${NC}"
            echo "Run 'pwt claude-setup install' to apply."
            return 0
            ;;

        test)
            local test_script="$PWT_DIR/tests/statusline-test.sh"
            if [ -f "$test_script" ]; then
                bash "$test_script"
            else
                echo -e "${RED}Test script not found at $test_script${NC}"
                echo "Tests may not be installed yet."
                return 1
            fi
            return 0
            ;;

        toggle)
            local scope="${2:-}"
            if [ "$scope" = "--session" ]; then
                # Session toggle - just show the command to run
                if [ "${PWT_STATUSLINE_OFF:-}" = "1" ]; then
                    echo -e "${GREEN}To enable for this session:${NC}"
                    echo "  unset PWT_STATUSLINE_OFF"
                else
                    echo -e "${YELLOW}To disable for this session:${NC}"
                    echo "  export PWT_STATUSLINE_OFF=1"
                fi
                echo ""
                echo "Add to your shell to persist: ~/.zshrc or ~/.bashrc"
            else
                # Global toggle
                [ ! -f "$config_file" ] && echo '{}' > "$config_file"
                local current=$(jq -r 'if has("enabled") then .enabled else true end' "$config_file")
                local new_state="true"
                [ "$current" = "true" ] && new_state="false"
                local tmp=$(mktemp)
                jq --argjson enabled "$new_state" '.enabled = $enabled' "$config_file" > "$tmp" && mv "$tmp" "$config_file"
                if [ "$new_state" = "true" ]; then
                    echo -e "${GREEN}✓ Status line enabled (all sessions)${NC}"
                else
                    echo -e "${YELLOW}✓ Status line disabled (all sessions)${NC}"
                fi
                echo "Run 'pwt claude-setup install' to apply."
            fi
            return 0
            ;;

        on)
            local scope="${2:-}"
            if [ "$scope" = "--session" ]; then
                echo -e "${GREEN}To enable for this session:${NC}"
                echo "  unset PWT_STATUSLINE_OFF"
            else
                [ ! -f "$config_file" ] && echo '{}' > "$config_file"
                local tmp=$(mktemp)
                jq '.enabled = true' "$config_file" > "$tmp" && mv "$tmp" "$config_file"
                echo -e "${GREEN}✓ Status line enabled (all sessions)${NC}"
                echo "Run 'pwt claude-setup install' to apply."
            fi
            return 0
            ;;

        off)
            local scope="${2:-}"
            if [ "$scope" = "--session" ]; then
                echo -e "${YELLOW}To disable for this session:${NC}"
                echo "  export PWT_STATUSLINE_OFF=1"
            else
                [ ! -f "$config_file" ] && echo '{}' > "$config_file"
                local tmp=$(mktemp)
                jq '.enabled = false' "$config_file" > "$tmp" && mv "$tmp" "$config_file"
                echo -e "${YELLOW}✓ Status line disabled (all sessions)${NC}"
                echo "Run 'pwt claude-setup install' to apply."
            fi
            return 0
            ;;

        pwt-only)
            local state="${2:-}"
            [ ! -f "$config_file" ] && echo '{}' > "$config_file"
            if [ -z "$state" ]; then
                # Show current state
                local current=$(jq -r '.pwt_only // false' "$config_file")
                if [ "$current" = "true" ]; then
                    echo "pwt-only: ${GREEN}on${NC} (status line only shows in pwt projects/worktrees)"
                else
                    echo "pwt-only: ${YELLOW}off${NC} (status line shows everywhere)"
                fi
            elif [ "$state" = "on" ]; then
                local tmp=$(mktemp)
                jq '.pwt_only = true' "$config_file" > "$tmp" && mv "$tmp" "$config_file"
                echo -e "${GREEN}✓ pwt-only enabled${NC}"
                echo "Status line will only show in pwt projects/worktrees."
                echo "Run 'pwt claude-setup install' to apply."
            elif [ "$state" = "off" ]; then
                local tmp=$(mktemp)
                jq '.pwt_only = false' "$config_file" > "$tmp" && mv "$tmp" "$config_file"
                echo -e "${YELLOW}✓ pwt-only disabled${NC}"
                echo "Status line will show in all directories."
                echo "Run 'pwt claude-setup install' to apply."
            else
                echo -e "${RED}Usage: pwt claude-setup pwt-only [on|off]${NC}"
                return 1
            fi
            return 0
            ;;

        install|"")
            ;;

        *)
            echo -e "${RED}Unknown action: $action${NC}"
            echo "Run 'pwt claude-setup help' for usage"
            return 1
            ;;
    esac

    # Create .claude directory if needed
    mkdir -p "$claude_dir"

    # Read config
    local format="$default_format"
    if [ -f "$config_file" ]; then
        local cfg_format=$(jq -r '.format // ""' "$config_file")
        [ -n "$cfg_format" ] && format="$cfg_format"
    fi

    # Write the status line script with template engine
    cat > "$script_file" << 'STATUSLINE_EOF'
#!/bin/bash
# Claude Code Status Line for pwt (Power Worktrees)
# Generated by: pwt claude-setup
# Docs: pwt claude-setup help

DEFAULT_FORMAT='__FORMAT_PLACEHOLDER__'
PWT_DIR="${PWT_DIR:-$HOME/.pwt}"

# Check if disabled via environment (session toggle)
[ "${PWT_STATUSLINE_OFF:-}" = "1" ] && exit 0

# Check if status line is enabled (global toggle)
config_file="$PWT_DIR/claude-statusline.json"
if [ -f "$config_file" ]; then
  enabled=$(jq -r 'if has("enabled") then .enabled else true end' "$config_file" 2>/dev/null)
  [ "$enabled" = "false" ] && exit 0
fi

input=$(cat)
cwd=$(echo "$input" | jq -r '.workspace.current_dir // empty')
[ -z "$cwd" ] && cwd=$(pwd)

# Detect worktree and project
worktree="" project="" is_pwt_context=false

# Fast path: check common patterns
if echo "$cwd" | grep -q '\-worktrees/'; then
  project=$(echo "$cwd" | perl -ne 'print $1 if /\/([^\/]+)-worktrees\//')
  worktree=$(echo "$cwd" | perl -ne 'print $1 if /-worktrees\/([^\/]+)/')
  is_pwt_context=true
elif echo "$cwd" | grep -q '\.pwt/'; then
  worktree=$(echo "$cwd" | perl -ne 'print $1 if /\.pwt\/([^\/]+)/')
  is_pwt_context=true
fi

# Fallback: check against configured projects
if [ "$is_pwt_context" = "false" ] && [ -d "$PWT_DIR/projects" ]; then
  for proj_config in "$PWT_DIR/projects"/*/config.json; do
    [ -f "$proj_config" ] || continue
    proj_name=$(basename "$(dirname "$proj_config")")
    proj_path=$(jq -r '.path // empty' "$proj_config" 2>/dev/null)
    proj_wt_dir=$(jq -r '.worktrees_dir // empty' "$proj_config" 2>/dev/null)

    # Check if cwd is inside worktrees_dir
    if [ -n "$proj_wt_dir" ] && [[ "$cwd" == "$proj_wt_dir"/* ]]; then
      project="$proj_name"
      worktree=$(echo "$cwd" | sed "s|^$proj_wt_dir/||" | cut -d/ -f1)
      is_pwt_context=true
      break
    fi

    # Infer main path from worktrees_dir if not configured (remove -worktrees suffix)
    if [ -z "$proj_path" ] && [ -n "$proj_wt_dir" ]; then
      proj_path="${proj_wt_dir%-worktrees}"
    fi

    # Check if cwd is the main project path (or inside it)
    if [ -n "$proj_path" ] && [[ "$cwd" == "$proj_path" || "$cwd" == "$proj_path"/* ]]; then
      project="$proj_name"
      worktree="@"
      is_pwt_context=true
      break
    fi
  done
fi

[ -z "$project" ] && project=$(basename "$cwd")

# Check pwt-only mode: if enabled, only show status in pwt projects/worktrees
if [ -f "$config_file" ]; then
  pwt_only=$(jq -r '.pwt_only // false' "$config_file" 2>/dev/null)
  [ "$pwt_only" = "true" ] && [ "$is_pwt_context" = "false" ] && exit 0
fi

# Check for format: global config first, then project-specific
FORMAT="$DEFAULT_FORMAT"
global_config="$PWT_DIR/claude-statusline.json"
if [ -f "$global_config" ]; then
  global_format=$(jq -r '.format // ""' "$global_config" 2>/dev/null)
  [ -n "$global_format" ] && FORMAT="$global_format"
fi
project_config="$PWT_DIR/projects/$project/config.json"
if [ -f "$project_config" ]; then
  proj_format=$(jq -r '.claude_format // ""' "$project_config" 2>/dev/null)
  [ -n "$proj_format" ] && FORMAT="$proj_format"
fi

# Git branch
branch=""
if git -C "$cwd" rev-parse --git-dir >/dev/null 2>&1; then
  branch=$(git -C "$cwd" branch --show-current 2>/dev/null)
fi

# Server port from pwt metadata
port="" server=""
PWT_META="${PWT_DIR:-$HOME/.pwt}/meta.json"
if [ -n "$worktree" ] && [ -f "$PWT_META" ]; then
  port=$(jq -r --arg wt "$worktree" '.[] | .[$wt]? | select(.) | .port // empty' "$PWT_META" 2>/dev/null | head -1)
  if [ -n "$port" ] && lsof -ti :$port -sTCP:LISTEN >/dev/null 2>&1; then
    server="localhost:$port"
  else
    port=""
  fi
fi

# Fallback: Rails pid file
if [ -z "$server" ] && [ -f "$cwd/tmp/pids/server.pid" ]; then
  pid=$(cat "$cwd/tmp/pids/server.pid" 2>/dev/null)
  if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
    port=$(lsof -Pan -p "$pid" -iTCP -sTCP:LISTEN 2>/dev/null | grep -oE ':\d+' | head -1 | tr -d ':')
    [ -n "$port" ] && server="localhost:$port"
  fi
fi

# Custom variables from Pwtfile
# Supports:
#   CLAUDE_VAR="static value"     -> {var}
#   claude_var() { echo "dynamic"; }  -> {var} (called each time)
#
# Find Pwtfile: prefer worktree's own Pwtfile, fallback to main app
main_app=""
pwtfile=""
if [ -f "$cwd/Pwtfile" ]; then
  # Worktree has its own Pwtfile
  pwtfile="$cwd/Pwtfile"
  main_app="$cwd"
elif echo "$cwd" | grep -q '\-worktrees/'; then
  # Fallback to main app Pwtfile
  main_app=$(echo "$cwd" | perl -ne 'print $1 if /(.+)-worktrees\//')
  [ -f "$main_app/Pwtfile" ] && pwtfile="$main_app/Pwtfile"
fi

# Will hold custom var replacements as "name=value" lines
custom_vars_data=""
if [ -n "$pwtfile" ] && [ -f "$pwtfile" ]; then
  # Source Pwtfile in subshell to get variables and functions
  custom_vars_data=$(
    cd "$main_app" 2>/dev/null || true
    # Export context vars that Pwtfile might need
    export PWT_WORKTREE="$worktree"
    export PWT_PROJECT="$project"
    export PWT_PORT="$port"
    export PWT_BRANCH="$branch"

    # Source the Pwtfile
    source "$pwtfile" 2>/dev/null

    # Output CLAUDE_* variables (static) - use set to see all vars
    set | grep '^CLAUDE_' | while IFS='=' read -r key value; do
      var_name=$(echo "${key#CLAUDE_}" | tr '[:upper:]' '[:lower:]')
      # Remove quotes
      value="${value#\'}"
      value="${value%\'}"
      echo "$var_name=$value"
    done

    # Call claude_* functions (dynamic)
    declare -F 2>/dev/null | awk '{print $3}' | grep '^claude_' | while read -r func; do
      var_name="${func#claude_}"
      value=$("$func" 2>/dev/null)
      [ -n "$value" ] && echo "$var_name=$value"
    done
  )
fi

# Template engine
output="$FORMAT"

# Process conditionals: {?var:content} -> show content only if var has value
while [[ "$output" =~ \{\?([a-z]+):([^}]*)\} ]]; do
  var_name="${BASH_REMATCH[1]}"
  content="${BASH_REMATCH[2]}"
  var_value="${!var_name}"

  if [ -n "$var_value" ]; then
    # Replace {var} inside content
    content="${content//\{$var_name\}/$var_value}"
    output="${output/\{?$var_name:$content\}/$content}"
  else
    output="${output/\{?$var_name:*\}/}"
  fi
done

# Replace simple variables first (before colors, so colors can wrap them)
output="${output//\{worktree\}/$worktree}"
output="${output//\{project\}/$project}"
output="${output//\{branch\}/$branch}"
output="${output//\{port\}/$port}"
output="${output//\{arrow\}/❯}"

# Replace custom variables from Pwtfile
if [ -n "$custom_vars_data" ]; then
  while IFS='=' read -r var_name var_value; do
    [ -n "$var_name" ] && output="${output//\{$var_name\}/$var_value}"
  done <<< "$custom_vars_data"
fi

# Server with clickable link
if [ -n "$server" ]; then
  url="http://$server"
  link_start=$'\e]8;;'"${url}"$'\e\\'
  link_end=$'\e]8;;\e\\'
  server_linked="${link_start}${server}${link_end}"
  output="${output//\{server\}/$server_linked}"
else
  output="${output//\{server\}/}"
fi

# Process colors: {color:content}, {rgb:R,G,B:content}, {#RRGGBB:content}
# Using perl for reliable regex
if command -v perl >/dev/null 2>&1; then
  output=$(echo "$output" | perl -pe '
    # Named colors
    s/\{magenta:([^}]*)\}/\033[35m$1\033[0m/g;
    s/\{cyan:([^}]*)\}/\033[36m$1\033[0m/g;
    s/\{yellow:([^}]*)\}/\033[33m$1\033[0m/g;
    s/\{green:([^}]*)\}/\033[32m$1\033[0m/g;
    s/\{blue:([^}]*)\}/\033[34m$1\033[0m/g;
    s/\{red:([^}]*)\}/\033[31m$1\033[0m/g;
    s/\{dim:([^}]*)\}/\033[2m$1\033[0m/g;
    s/\{bold:([^}]*)\}/\033[1m$1\033[0m/g;
    # RGB: {rgb:R,G,B:content}
    s/\{rgb:(\d+),(\d+),(\d+):([^}]*)\}/\033[38;2;$1;$2;$3m$4\033[0m/g;
    # Hex: {#RRGGBB:content}
    s/\{#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2}):([^}]*)\}/sprintf("\033[38;2;%d;%d;%dm%s\033[0m", hex($1), hex($2), hex($3), $4)/ge;
  ')
fi

# Clean up empty brackets/parens from missing values
output=$(echo "$output" | sed 's/\[\]//g; s/()//g; s/  */ /g; s/^ *//; s/ *$//')

echo -en "$output"
STATUSLINE_EOF

    # Insert the actual format into the script
    sed -i '' "s|__FORMAT_PLACEHOLDER__|$format|g" "$script_file"

    chmod +x "$script_file"

    echo -e "${GREEN}✓ Claude Code status line installed${NC}"
    echo ""
    echo "Format: $format"
    echo ""
    echo "Commands:"
    echo "  pwt claude-setup vars      # See all variables"
    echo "  pwt claude-setup format    # Change format"
    echo "  pwt claude-setup preview   # Test output"
    echo ""
    echo "Restart Claude Code or run /statusline to apply."
}

# Command: config
# Configure current project (zero-config override)
cmd_config() {
    local key="$1"
    local value="$2"

    # Ensure project is detected
    if [ -z "$CURRENT_PROJECT" ]; then
        pwt_error "Error: No project detected"
        echo "Run from inside a git repository."
        exit 1
    fi

    local config_dir="$PWT_PROJECTS_DIR/$CURRENT_PROJECT"
    local config_file="$config_dir/config.json"

    # Create config dir if needed
    mkdir -p "$config_dir/hooks"

    # Initialize config file if needed
    if [ ! -f "$config_file" ]; then
        echo "{}" > "$config_file"
    fi

    case "$key" in
        -h|--help|help)
            echo "Usage: pwt config [key] [value]"
            echo ""
            echo "View or set project configuration."
            echo ""
            echo "Commands:"
            echo "  show                 Show all settings (default)"
            echo "  <key>                Show value for key"
            echo "  <key> <value>        Set value for key"
            echo ""
            echo "Keys:"
            echo "  main_app       - Path to main project"
            echo "  worktrees_dir  - Path to worktrees directory"
            echo "  branch_prefix  - Prefix for branches (e.g., gl/)"
            echo "  base_port      - Base port for allocation (default: 5000)"
            echo ""
            echo "Options:"
            echo "  -h, --help, help    Show this help"
            echo ""
            echo "Config location: ~/.pwt/projects/<project>/config.json"
            return 0
            ;;
        ""|show)
            # Show current config
            echo -e "${BLUE}Project: $CURRENT_PROJECT${NC}"
            echo ""
            echo "Current settings:"
            echo "  main_app:      ${MAIN_APP:-"(auto-detected)"}"
            echo "  worktrees_dir: ${WORKTREES_DIR:-"(auto-detected)"}"
            echo "  branch_prefix: ${BRANCH_PREFIX:-"(none)"}"
            echo "  base_port:     ${BASE_PORT:-5000}"
            echo ""
            if [ -f "$config_file" ] && [ "$(cat "$config_file")" != "{}" ]; then
                echo "Saved overrides ($config_file):"
                jq '.' "$config_file"
            else
                echo "No saved overrides (using auto-detected values)."
            fi
            ;;
        main_app|worktrees_dir|branch_prefix|base_port)
            if [ -z "$value" ]; then
                # Show current value
                local current=$(jq -r ".$key // empty" "$config_file" 2>/dev/null)
                echo "${current:-"(not set)"}"
            else
                # Set value (create tmp in same dir for atomic mv)
                local tmp_file
                tmp_file="$(mktemp "${config_file}.tmp.XXXXXX")"
                jq --arg key "$key" --arg value "$value" '.[$key] = $value' "$config_file" > "$tmp_file" && mv "$tmp_file" "$config_file"
                echo -e "${GREEN}✓ Set $key = $value${NC}"
            fi
            ;;
        *)
            echo -e "${RED}Unknown config key: $key${NC}"
            echo ""
            echo "Available keys:"
            echo "  main_app       - Path to main project"
            echo "  worktrees_dir  - Path to worktrees directory"
            echo "  branch_prefix  - Prefix for branches (e.g., user/)"
            echo "  base_port      - Base port for allocation"
            exit 1
            ;;
    esac
}

# Command: project
# Manage project configurations
cmd_project() {
    local action="$1"
    local project="$2"
    local arg3="$3"
    local arg4="$4"

    init_metadata

    case "$action" in
        ""|list)
            # List all projects
            echo -e "${BLUE}Configured Projects:${NC}"
            echo ""
            if [ -d "$PROJECTS_DIR" ] && [ "$(ls -A "$PROJECTS_DIR" 2>/dev/null)" ]; then
                for dir in "$PROJECTS_DIR"/*/; do
                    [ -d "$dir" ] || continue
                    local proj_name=$(basename "$dir")
                    local config_file="$dir/config.json"
                    if [ -f "$config_file" ]; then
                        local main_app=$(jq -r '.main_app // "(not set)"' "$config_file")
                        local prefix=$(jq -r '.branch_prefix // "(not set)"' "$config_file")
                        # Get alias if set
                        local proj_alias=$(jq -r '.alias // empty' "$config_file")
                        if [ -n "$proj_alias" ]; then
                            echo -e "  ${GREEN}$proj_name${NC} (${CYAN}$proj_alias${NC})"
                        else
                            echo -e "  ${GREEN}$proj_name${NC}"
                        fi
                        echo "    main_app: $main_app"
                        echo "    branch_prefix: $prefix"
                        # Count hooks
                        local hook_count=$(ls "$dir/hooks" 2>/dev/null | wc -l | tr -d ' ')
                        if [ "$hook_count" -gt 0 ]; then
                            echo "    hooks: $hook_count"
                        fi
                        echo ""
                    fi
                done
            else
                echo "  No projects configured yet."
                echo ""
                echo "  Use: pwt project init <name>"
            fi
            ;;
        init)
            if [ -z "$project" ]; then
                echo -e "${RED}Error: Project name required${NC}"
                echo "Usage: pwt project init <name>"
                exit 1
            fi
            init_project "$project"
            echo ""
            echo "Edit the config at: $PROJECTS_DIR/$project/config.json"
            echo "Add hooks in: $PROJECTS_DIR/$project/hooks/"
            ;;
        show)
            if [ -z "$project" ]; then
                echo -e "${RED}Error: Project name required${NC}"
                echo "Usage: pwt project show <name>"
                exit 1
            fi
            local config_file="$PROJECTS_DIR/$project/config.json"
            if [ ! -f "$config_file" ]; then
                echo -e "${RED}Project not found: $project${NC}"
                exit 1
            fi
            echo -e "${BLUE}Project: $project${NC}"
            echo ""
            echo "Config:"
            jq '.' "$config_file"
            echo ""
            echo "Hooks:"
            ls -la "$PROJECTS_DIR/$project/hooks/" 2>/dev/null || echo "  (none)"
            ;;
        set)
            if [ -z "$project" ] || [ -z "$arg3" ] || [ -z "$arg4" ]; then
                echo -e "${RED}Error: Missing arguments${NC}"
                echo "Usage: pwt project set <name> <key> <value>"
                exit 1
            fi
            local config_file="$PROJECTS_DIR/$project/config.json"
            if [ ! -f "$config_file" ]; then
                echo -e "${RED}Project not found: $project${NC}"
                echo "Use: pwt project init $project"
                exit 1
            fi
            # Create tmp in same dir for atomic mv
            local tmp_file
            tmp_file="$(mktemp "${config_file}.tmp.XXXXXX")"
            jq --arg key "$arg3" --arg value "$arg4" '.[$key] = $value' "$config_file" > "$tmp_file" && mv "$tmp_file" "$config_file"
            echo -e "${GREEN}✓ Updated $project.$arg3 = $arg4${NC}"
            ;;
        path)
            if [ -z "$project" ]; then
                echo -e "${RED}Error: Project name required${NC}"
                exit 1
            fi
            echo "$PROJECTS_DIR/$project"
            ;;
        alias)
            # pwt project alias <project> [alias|--clear]
            local new_alias="$arg3"

            if [ -z "$project" ]; then
                echo -e "${RED}Error: Project name required${NC}"
                echo "Usage: pwt project alias <project> [<alias>|--clear]"
                exit 1
            fi

            local config_file="$PROJECTS_DIR/$project/config.json"
            if [ ! -f "$config_file" ]; then
                echo -e "${RED}Project not found: $project${NC}"
                exit 1
            fi

            if [ -z "$new_alias" ]; then
                # Show current alias
                local current=$(jq -r '.alias // empty' "$config_file")
                if [ -n "$current" ]; then
                    echo "$current"
                else
                    echo "(no alias set)"
                fi
            elif [ "$new_alias" = "--clear" ]; then
                # Clear alias
                local tmp_file
                tmp_file="$(mktemp "${config_file}.tmp.XXXXXX")"
                jq 'del(.alias)' "$config_file" > "$tmp_file" && mv "$tmp_file" "$config_file"
                echo -e "${GREEN}✓ Cleared alias for $project${NC}"
            else
                # Set alias - validate first
                local reserved_commands="list create remove cd server test meta port project help version config init show set path alias"
                for cmd in $reserved_commands; do
                    if [ "$new_alias" = "$cmd" ]; then
                        echo -e "${RED}Error: '$new_alias' is a reserved command name${NC}"
                        exit 1
                    fi
                done
                # Check if alias conflicts with existing project name
                if [ -f "$PROJECTS_DIR/$new_alias/config.json" ]; then
                    echo -e "${RED}Error: '$new_alias' is already a project name${NC}"
                    exit 1
                fi
                # Check if alias already used by another project
                for cfg in "$PROJECTS_DIR"/*/config.json; do
                    [ -f "$cfg" ] || continue
                    local proj_dir=$(dirname "$cfg")
                    local proj_name=$(basename "$proj_dir")
                    [ "$proj_name" = "$project" ] && continue
                    local other_alias=$(jq -r '.alias // empty' "$cfg")
                    if [ "$other_alias" = "$new_alias" ]; then
                        echo -e "${RED}Error: Alias '$new_alias' already used by project '$proj_name'${NC}"
                        exit 1
                    fi
                done
                # Set alias
                local tmp_file
                tmp_file="$(mktemp "${config_file}.tmp.XXXXXX")"
                jq --arg alias "$new_alias" '.alias = $alias' "$config_file" > "$tmp_file" && mv "$tmp_file" "$config_file"
                echo -e "${GREEN}✓ Set alias '$new_alias' for $project${NC}"
            fi
            ;;
        validate|check)
            # Validate current project setup
            local errors=0
            local warnings=0

            echo -e "${BLUE}Validating project: $CURRENT_PROJECT${NC}"
            echo ""

            # Check main_app exists
            if [ -d "$MAIN_APP" ]; then
                echo -e "  ${GREEN}✓${NC} main_app exists: $MAIN_APP"
            else
                echo -e "  ${RED}✗${NC} main_app not found: $MAIN_APP"
                ((errors++))
            fi

            # Check worktrees_dir exists
            if [ -d "$WORKTREES_DIR" ]; then
                echo -e "  ${GREEN}✓${NC} worktrees_dir exists: $WORKTREES_DIR"
            else
                echo -e "  ${YELLOW}!${NC} worktrees_dir not found: $WORKTREES_DIR"
                echo -e "    (will be created on first worktree)"
                ((warnings++))
            fi

            # Check Pwtfile exists
            local pwtfile="$MAIN_APP/Pwtfile"
            if [ -f "$pwtfile" ]; then
                echo -e "  ${GREEN}✓${NC} Pwtfile found"
            else
                echo -e "  ${YELLOW}!${NC} No Pwtfile (optional)"
                ((warnings++))
            fi

            # Check md-docs symlink in main app
            local md_docs_link="$MAIN_APP/md-docs"
            if [ -L "$md_docs_link" ]; then
                if [ -d "$md_docs_link" ]; then
                    echo -e "  ${GREEN}✓${NC} md-docs symlink valid"
                else
                    echo -e "  ${RED}✗${NC} md-docs symlink broken"
                    ((errors++))
                fi
            else
                echo -e "  ${YELLOW}!${NC} No md-docs symlink (optional)"
                ((warnings++))
            fi

            # Check .env exists in main app
            if [ -f "$MAIN_APP/.env" ]; then
                echo -e "  ${GREEN}✓${NC} .env file found"
            else
                echo -e "  ${YELLOW}!${NC} No .env file"
                ((warnings++))
            fi

            # Check git repo
            if git -C "$MAIN_APP" rev-parse --git-dir >/dev/null 2>&1; then
                echo -e "  ${GREEN}✓${NC} Git repository"
            else
                echo -e "  ${RED}✗${NC} Not a git repository"
                ((errors++))
            fi

            echo ""
            if [ $errors -eq 0 ] && [ $warnings -eq 0 ]; then
                echo -e "${GREEN}All checks passed!${NC}"
            elif [ $errors -eq 0 ]; then
                echo -e "${YELLOW}$warnings warning(s), no errors${NC}"
            else
                echo -e "${RED}$errors error(s), $warnings warning(s)${NC}"
                exit 1
            fi
            ;;
        -h|--help|help)
            echo "Usage: pwt project [command] [args]"
            echo ""
            echo "Manage project configurations."
            echo ""
            echo "Commands:"
            echo "  list                           List all configured projects (default)"
            echo "  init <name>                    Initialize a new project config"
            echo "  show <name>                    Show project config and hooks"
            echo "  set <name> <key> <value>       Update project config value"
            echo "  path <name>                    Print project config directory path"
            echo "  alias <name> [alias|--clear]   Get/set/clear project alias"
            echo "  validate                       Validate current project setup"
            echo ""
            echo "Options:"
            echo "  -h, --help, help    Show this help"
            echo ""
            echo "Config location: ~/.pwt/projects/<project>/config.json"
            echo "Hooks location: ~/.pwt/projects/<project>/hooks/"
            return 0
            ;;
        *)
            echo -e "${RED}Unknown action: $action${NC}"
            echo "Usage: pwt project [list|init|show|set|path|alias]"
            echo ""
            echo "Commands:"
            echo "  list                    - List all configured projects"
            echo "  init <name>             - Initialize a new project config"
            echo "  show <name>             - Show project config and hooks"
            echo "  set <name> <k> <v>      - Update project config value"
            echo "  path <name>             - Print project config directory path"
            echo "  alias <name> [a|--clear] - Get/set/clear project alias"
            exit 1
            ;;
    esac
}

# Command: port
# Get port for a worktree
cmd_port() {
    local name="$1"

    # If no name, try to detect from current directory
    if [ -z "$name" ]; then
        local current_dir=$(pwd)
        if [[ "$current_dir" == "$WORKTREES_DIR"/* ]]; then
            name=$(basename "$current_dir")
        else
            echo -e "${RED}Error: Not in a worktree directory${NC}" >&2
            exit 1
        fi
    fi

    init_metadata
    local port=$(get_metadata "$name" "port")

    if [ -z "$port" ]; then
        echo -e "${RED}Error: No port found for worktree: $name${NC}" >&2
        exit 1
    fi

    echo "$port"
}

# Command: plugin
# Manage pwt plugins
# Usage: pwt plugin [list|install|remove|path|help]
cmd_plugin() {
    local plugins_dir="$PWT_DIR/plugins"
    local action="${1:-list}"

    case "$action" in
        list|ls)
            echo -e "${BLUE}Installed plugins:${NC}"
            echo ""
            if [ -d "$plugins_dir" ] && [ "$(ls -A "$plugins_dir" 2>/dev/null)" ]; then
                for plugin in "$plugins_dir"/pwt-*; do
                    [ -x "$plugin" ] || continue
                    local name=$(basename "$plugin" | sed 's/^pwt-//')
                    local version=""
                    local desc=""

                    # Try to get version/description from plugin --version or first comment
                    if head -5 "$plugin" | grep -q "^# Description:"; then
                        desc=$(head -10 "$plugin" | grep "^# Description:" | sed 's/^# Description: *//')
                    fi
                    if head -5 "$plugin" | grep -q "^# Version:"; then
                        version=$(head -10 "$plugin" | grep "^# Version:" | sed 's/^# Version: *//')
                    fi

                    printf "  ${GREEN}%-15s${NC}" "$name"
                    [ -n "$version" ] && printf " v%s" "$version"
                    [ -n "$desc" ] && printf "  - %s" "$desc"
                    echo ""
                done
            else
                echo "  (no plugins installed)"
                echo ""
                echo "Install plugins:"
                echo "  pwt plugin install <path-or-url>"
                echo "  cp my-plugin ~/.pwt/plugins/pwt-mycommand"
            fi
            echo ""
            echo -e "${DIM}Plugin directory: $plugins_dir${NC}"
            ;;

        install)
            local source="${2:-}"
            if [ -z "$source" ]; then
                echo -e "${RED}Usage: pwt plugin install <path-or-url>${NC}"
                echo ""
                echo "Examples:"
                echo "  pwt plugin install ./my-plugin.sh"
                echo "  pwt plugin install ~/scripts/pwt-docker"
                echo "  pwt plugin install https://example.com/pwt-github"
                exit 1
            fi

            mkdir -p "$plugins_dir"

            local plugin_name=""
            local dest=""

            if [[ "$source" == http* ]]; then
                # Download from URL
                plugin_name=$(basename "$source")
                [[ "$plugin_name" != pwt-* ]] && plugin_name="pwt-$plugin_name"
                dest="$plugins_dir/$plugin_name"

                echo -e "${BLUE}Downloading plugin...${NC}"
                if command -v curl &>/dev/null; then
                    curl -fsSL "$source" -o "$dest"
                elif command -v wget &>/dev/null; then
                    wget -q "$source" -O "$dest"
                else
                    echo -e "${RED}Error: curl or wget required for URL install${NC}"
                    exit 1
                fi
            else
                # Copy local file
                if [ ! -f "$source" ]; then
                    echo -e "${RED}Error: File not found: $source${NC}"
                    exit 1
                fi

                plugin_name=$(basename "$source")
                [[ "$plugin_name" != pwt-* ]] && plugin_name="pwt-$plugin_name"
                dest="$plugins_dir/$plugin_name"

                cp "$source" "$dest"
            fi

            chmod +x "$dest"
            local cmd_name=$(echo "$plugin_name" | sed 's/^pwt-//')
            echo -e "${GREEN}✓${NC} Installed plugin: $cmd_name"
            echo "  Run: pwt $cmd_name"
            ;;

        remove|uninstall|rm)
            local name="${2:-}"
            if [ -z "$name" ]; then
                echo -e "${RED}Usage: pwt plugin remove <name>${NC}"
                exit 1
            fi

            # Normalize name
            [[ "$name" != pwt-* ]] && name="pwt-$name"
            local plugin="$plugins_dir/$name"

            if [ ! -f "$plugin" ]; then
                echo -e "${RED}Error: Plugin not found: ${name#pwt-}${NC}"
                exit 1
            fi

            rm "$plugin"
            echo -e "${GREEN}✓${NC} Removed plugin: ${name#pwt-}"
            ;;

        path)
            echo "$plugins_dir"
            ;;

        create)
            local name="${2:-}"
            if [ -z "$name" ]; then
                echo -e "${RED}Usage: pwt plugin create <name>${NC}"
                exit 1
            fi

            mkdir -p "$plugins_dir"
            [[ "$name" != pwt-* ]] && name="pwt-$name"
            local plugin="$plugins_dir/$name"
            local cmd_name="${name#pwt-}"

            if [ -f "$plugin" ]; then
                echo -e "${RED}Error: Plugin already exists: $cmd_name${NC}"
                exit 1
            fi

            cat > "$plugin" << 'TEMPLATE'
#!/bin/bash
# pwt plugin: PLUGIN_NAME
# Description: A custom pwt plugin
# Version: 1.0.0
#
# Available environment variables:
#   PWT_DIR            - pwt directory (~/.pwt)
#   PWT_PROJECT        - Current project name
#   PWT_MAIN_APP       - Main app directory
#   PWT_WORKTREES_DIR  - Worktrees directory
#   PWT_WORKTREE       - Current worktree name (if in one)
#   PWT_WORKTREE_PATH  - Current worktree path
#   PWT_PORT           - Current worktree port
#   PWT_BRANCH         - Current worktree branch
#   PWT_DEFAULT_BRANCH - Default branch (master/main)

set -euo pipefail

case "${1:-}" in
    -h|--help|help)
        echo "Usage: pwt PLUGIN_NAME [subcommand]"
        echo ""
        echo "A custom pwt plugin."
        echo ""
        echo "Subcommands:"
        echo "  help    Show this help"
        echo ""
        echo "Environment:"
        echo "  Project: ${PWT_PROJECT:-<none>}"
        echo "  Worktree: ${PWT_WORKTREE:-<none>}"
        ;;
    *)
        echo "Hello from PLUGIN_NAME plugin!"
        echo ""
        echo "Project: ${PWT_PROJECT:-<not detected>}"
        echo "Worktree: ${PWT_WORKTREE:-<not in worktree>}"
        ;;
esac
TEMPLATE

            # Replace PLUGIN_NAME placeholder
            sed -i.bak "s/PLUGIN_NAME/$cmd_name/g" "$plugin" && rm -f "$plugin.bak"
            chmod +x "$plugin"

            echo -e "${GREEN}✓${NC} Created plugin: $cmd_name"
            echo "  Path: $plugin"
            echo "  Edit: \$EDITOR $plugin"
            echo "  Run:  pwt $cmd_name"
            ;;

        help|-h|--help)
            echo "Usage: pwt plugin <action>"
            echo ""
            echo "Manage pwt plugins - extend pwt with custom commands."
            echo ""
            echo "Actions:"
            echo "  list              List installed plugins"
            echo "  install <source>  Install plugin from file or URL"
            echo "  remove <name>     Remove installed plugin"
            echo "  create <name>     Create new plugin from template"
            echo "  path              Print plugins directory"
            echo ""
            echo "Plugin Structure:"
            echo "  Plugins are executable scripts in ~/.pwt/plugins/"
            echo "  Named pwt-<command>, invoked as 'pwt <command>'"
            echo ""
            echo "Environment Variables (available to plugins):"
            echo "  PWT_PROJECT        Current project name"
            echo "  PWT_MAIN_APP       Main app directory"
            echo "  PWT_WORKTREES_DIR  Worktrees directory"
            echo "  PWT_WORKTREE       Current worktree name"
            echo "  PWT_PORT           Current worktree port"
            echo "  PWT_BRANCH         Current worktree branch"
            echo ""
            echo "Examples:"
            echo "  pwt plugin list"
            echo "  pwt plugin create github"
            echo "  pwt plugin install ./my-plugin.sh"
            echo "  pwt plugin remove github"
            ;;

        *)
            echo -e "${RED}Unknown action: $action${NC}"
            echo "Run 'pwt plugin help' for usage"
            exit 1
            ;;
    esac
}

# ============================================================
# Command: status
# Interactive TUI dashboard for monitoring worktrees
# ============================================================

# Theme variables (ANSI 16 colors - universal compatibility)
# These are set by load_status_theme()
TH_BORDER=''
TH_BORDER_ACTIVE=''
TH_HEADER=''
TH_TITLE=''
TH_OK=''
TH_WARN=''
TH_ERR=''
TH_INFO=''
TH_SELECTED=''
TH_DIM=''
TH_BOLD=''
TH_RESET=''

# Load theme for status display
load_status_theme() {
    local theme="${PWT_THEME:-default}"
    local theme_file="$PWT_DIR/themes/${theme}.sh"

    if [ -f "$theme_file" ]; then
        # shellcheck source=/dev/null
        source "$theme_file"
    else
        # Default theme (ANSI 16 colors)
        TH_BORDER='\033[2m'           # Dim - box borders
        TH_BORDER_ACTIVE='\033[1;36m' # Bold cyan - active pane
        TH_HEADER='\033[1;37m'        # Bold white - headers
        TH_TITLE='\033[1;33m'         # Bold yellow - titles
        TH_OK='\033[32m'              # Green - clean/running
        TH_WARN='\033[33m'            # Yellow - changes/warning
        TH_ERR='\033[31m'             # Red - error/conflict
        TH_INFO='\033[36m'            # Cyan - info
        TH_SELECTED='\033[7m'         # Reverse - selected row
        TH_DIM='\033[2m'              # Dim - secondary info
        TH_BOLD='\033[1m'             # Bold - emphasis
        TH_RESET='\033[0m'            # Reset
    fi
}

# Status TUI state variables
declare -a STATUS_WORKTREES=()      # Worktree names
declare -a STATUS_BRANCHES=()       # Branch names
declare -a STATUS_STATUSES=()       # Git status symbols
declare -a STATUS_PORTS=()          # Port numbers
declare -a STATUS_SERVER_STATUS=()  # Server running state
declare -a STATUS_MAIN_DIV=()       # Divergence from main
declare -a STATUS_REMOTE_DIV=()     # Divergence from remote
declare -a STATUS_AGES=()           # Last commit age
declare -a STATUS_PATHS=()          # Full paths
declare -a STATUS_ACTIVITY=()       # Activity log entries

# View navigation state
STATUS_VIEW="project"           # Current view: global, project, worktree
STATUS_SELECTED_PROJECT=""      # Selected project name (for global view navigation)
STATUS_SELECTED_WORKTREE=""     # Selected worktree name (for worktree view)

# Pane state
STATUS_PANE=0           # Current active pane (0=worktrees, 1=details, 2=servers, 3=activity)
STATUS_SELECTED=0       # Selected item in current pane
STATUS_SERVER_SELECTED=0  # Selected item in servers pane
STATUS_SCROLL=0         # Scroll offset for worktrees pane
STATUS_SERVER_SCROLL=0  # Scroll offset for servers pane
STATUS_ACTIVITY_SCROLL=0  # Scroll offset for activity pane
STATUS_TERM_WIDTH=80    # Terminal width
STATUS_TERM_HEIGHT=24   # Terminal height
STATUS_REFRESH_INTERVAL=2  # Refresh interval in seconds
STATUS_LAST_REFRESH=0   # Last refresh timestamp
STATUS_RUNNING=true     # Main loop control
STATUS_SHOW_HELP=false  # Show help overlay
STATUS_NEEDS_CLEAR=false  # Flag to trigger full screen clear (on view change, resize, etc.)
STATUS_FILTER=""        # Filter string
STATUS_SHOW_ALL=false   # Show all projects (--all flag)

# Global view state (list of all projects)
declare -a STATUS_PROJECTS=()        # Project names
declare -a STATUS_PROJECT_PATHS=()   # Project paths
declare -a STATUS_PROJECT_WT_COUNT=()  # Worktree count per project
declare -a STATUS_PROJECT_DIRTY=()   # Dirty worktree count per project
declare -a STATUS_PROJECT_SERVERS=() # Running server count per project
STATUS_PROJECT_SELECTED=0            # Selected project in global view
STATUS_PROJECT_SCROLL=0              # Scroll offset for global view

# Spinners for loading animation
STATUS_SPINNERS=('⠋' '⠙' '⠹' '⠸' '⠼' '⠴' '⠦' '⠧' '⠇' '⠏')
STATUS_SPINNER_IDX=0

# Initialize TUI (alternate screen, hide cursor, setup trap)
status_init() {
    # Save terminal state and switch to alternate screen
    tput smcup 2>/dev/null || true
    # Hide cursor
    tput civis 2>/dev/null || true
    # Enable keypad mode for arrow keys
    tput smkx 2>/dev/null || true
    # Reset scroll region (ensure full screen is usable)
    printf '\033[r' 2>/dev/null || true
    # Clear screen once at start
    tput clear 2>/dev/null || true
    # Position cursor at top-left
    tput cup 0 0 2>/dev/null || true

    # Get terminal dimensions - try multiple methods
    status_update_terminal_size

    # Setup cleanup trap
    trap status_cleanup EXIT INT TERM
    # Handle terminal resize
    trap 'STATUS_NEEDS_CLEAR=true; status_update_terminal_size' WINCH

    # Load theme
    load_status_theme

    # Initial data collection based on view
    if [ "$STATUS_VIEW" = "global" ]; then
        status_collect_global_data
    else
        status_collect_data
    fi
}

# Cleanup TUI (restore terminal)
status_cleanup() {
    # Show cursor
    tput cnorm 2>/dev/null || true
    # Disable keypad mode
    tput rmkx 2>/dev/null || true
    # Switch back from alternate screen
    tput rmcup 2>/dev/null || true
    # Reset colors
    echo -ne '\033[0m'

    # Remove traps
    trap - EXIT INT TERM WINCH
}

# Read a single key with timeout (non-blocking)
# Returns the key in STATUS_KEY variable
status_read_key() {
    STATUS_KEY=""
    local key=""
    local escape_seq=""

    # Read single character with timeout from /dev/tty
    if IFS= read -rsn1 -t 0.5 key </dev/tty 2>/dev/null; then
        # Check for escape sequences (arrow keys, etc.)
        if [[ "$key" == $'\e' ]]; then
            # Read up to 2 more characters for escape sequence with short timeout
            if IFS= read -rsn1 -t 0.1 escape_seq </dev/tty 2>/dev/null; then
                if [[ "$escape_seq" == "[" ]] || [[ "$escape_seq" == "O" ]]; then
                    local third=""
                    if IFS= read -rsn1 -t 0.1 third </dev/tty 2>/dev/null; then
                        case "${escape_seq}${third}" in
                            '[A'|'OA') STATUS_KEY="UP" ;;
                            '[B'|'OB') STATUS_KEY="DOWN" ;;
                            '[C'|'OC') STATUS_KEY="RIGHT" ;;
                            '[D'|'OD') STATUS_KEY="LEFT" ;;
                            '[Z')      STATUS_KEY="SHIFT_TAB" ;;
                            *)         STATUS_KEY="ESC" ;;
                        esac
                    else
                        STATUS_KEY="ESC"
                    fi
                else
                    STATUS_KEY="ESC"
                fi
            else
                STATUS_KEY="ESC"
            fi
        else
            STATUS_KEY="$key"
        fi
        return 0
    fi
    return 1
}

# Collect data for all worktrees
status_collect_data() {
    # Clear arrays
    STATUS_WORKTREES=()
    STATUS_BRANCHES=()
    STATUS_STATUSES=()
    STATUS_PORTS=()
    STATUS_SERVER_STATUS=()
    STATUS_MAIN_DIV=()
    STATUS_REMOTE_DIV=()
    STATUS_AGES=()
    STATUS_PATHS=()

    # Add main app first
    if [ -d "$MAIN_APP" ]; then
        STATUS_WORKTREES+=("@")
        STATUS_BRANCHES+=("$(git -C "$MAIN_APP" branch --show-current 2>/dev/null || echo "?")")
        STATUS_STATUSES+=("$(get_status_symbols "$MAIN_APP")")
        STATUS_PORTS+=("${BASE_PORT:-5000}")
        STATUS_PATHS+=("$MAIN_APP")

        # Check if server is running on main port
        local main_port="${BASE_PORT:-5000}"
        local main_pids=$(get_pids_on_port "$main_port" 2>/dev/null || true)
        if [ -n "$main_pids" ]; then
            STATUS_SERVER_STATUS+=("RUNNING")
        else
            STATUS_SERVER_STATUS+=("STOPPED")
        fi

        STATUS_MAIN_DIV+=("")
        STATUS_REMOTE_DIV+=("$(get_remote_divergence "$MAIN_APP")")

        local age_ts=$(git -C "$MAIN_APP" log -1 --format=%ct 2>/dev/null || echo "0")
        STATUS_AGES+=("$(format_relative_time "$age_ts")")
    fi

    # Add worktrees
    if [ -d "$WORKTREES_DIR" ]; then
        for dir in "$WORKTREES_DIR"/*/; do
            [ -d "$dir" ] || continue
            local name=$(basename "$dir")
            local path="${dir%/}"

            STATUS_WORKTREES+=("$name")
            STATUS_BRANCHES+=("$(git -C "$path" branch --show-current 2>/dev/null || echo "detached")")
            STATUS_STATUSES+=("$(get_status_symbols "$path")")
            STATUS_PATHS+=("$path")

            # Get port from metadata
            local port=$(get_metadata "$name" "port" 2>/dev/null || echo "")
            STATUS_PORTS+=("$port")

            # Check if server is running
            if [ -n "$port" ]; then
                local pids=$(get_pids_on_port "$port" 2>/dev/null || true)
                if [ -n "$pids" ]; then
                    STATUS_SERVER_STATUS+=("RUNNING")
                else
                    STATUS_SERVER_STATUS+=("STOPPED")
                fi
            else
                STATUS_SERVER_STATUS+=("")
            fi

            # Divergence
            STATUS_MAIN_DIV+=("$(get_divergence "$path" "origin/${DEFAULT_BRANCH:-master}" 2>/dev/null || echo "")")
            STATUS_REMOTE_DIV+=("$(get_remote_divergence "$path" 2>/dev/null || echo "")")

            # Age
            local age_ts=$(git -C "$path" log -1 --format=%ct 2>/dev/null || echo "0")
            STATUS_AGES+=("$(format_relative_time "$age_ts")")
        done
    fi
}

# Collect data for all projects (global view)
status_collect_global_data() {
    # Clear arrays
    STATUS_PROJECTS=()
    STATUS_PROJECT_PATHS=()
    STATUS_PROJECT_WT_COUNT=()
    STATUS_PROJECT_DIRTY=()
    STATUS_PROJECT_SERVERS=()

    # Iterate over all configured projects
    if [ -d "$PWT_PROJECTS_DIR" ]; then
        for project_dir in "$PWT_PROJECTS_DIR"/*/; do
            [ -d "$project_dir" ] || continue
            local project_name=$(basename "$project_dir")
            local config_file="$project_dir/config.json"
            [ -f "$config_file" ] || continue

            STATUS_PROJECTS+=("$project_name")

            # Get project path
            local main_app=$(jq -r '.path // .main_app // empty' "$config_file" 2>/dev/null)
            STATUS_PROJECT_PATHS+=("${main_app:-}")

            # Get worktrees directory
            local worktrees_dir=$(jq -r '.worktrees_dir // empty' "$config_file" 2>/dev/null)

            # Count worktrees
            local wt_count=0
            local dirty_count=0
            local server_count=0

            if [ -n "$worktrees_dir" ] && [ -d "$worktrees_dir" ]; then
                for wt_dir in "$worktrees_dir"/*/; do
                    [ -d "$wt_dir" ] || continue
                    wt_count=$((wt_count + 1))

                    # Check dirty status
                    local status=$(get_status_symbols "$wt_dir" 2>/dev/null)
                    [ -n "$status" ] && dirty_count=$((dirty_count + 1))
                done
            fi

            # Check running servers from metadata
            if [ -f "$PWT_META_FILE" ]; then
                local ports=$(jq -r --arg proj "$project_name" '.[$proj] // {} | to_entries[] | .value.port // empty' "$PWT_META_FILE" 2>/dev/null)
                for port in $ports; do
                    if [ -n "$port" ]; then
                        local pids=$(get_pids_on_port "$port" 2>/dev/null || true)
                        [ -n "$pids" ] && server_count=$((server_count + 1))
                    fi
                done
            fi

            STATUS_PROJECT_WT_COUNT+=("$wt_count")
            STATUS_PROJECT_DIRTY+=("$dirty_count")
            STATUS_PROJECT_SERVERS+=("$server_count")
        done
    fi
}

# Navigate into a project (global -> project view)
status_drill_down_project() {
    if [ "$STATUS_VIEW" = "global" ]; then
        local selected_project="${STATUS_PROJECTS[$STATUS_PROJECT_SELECTED]:-}"
        if [ -n "$selected_project" ]; then
            STATUS_SELECTED_PROJECT="$selected_project"
            STATUS_VIEW="project"
            STATUS_NEEDS_CLEAR=true  # Clear screen on view change

            # Load project config (suppress any errors to prevent exit)
            if ! load_project_config "$selected_project" 2>/dev/null; then
                status_add_activity "Warning: Could not load config for $selected_project"
            fi
            CURRENT_PROJECT="$selected_project"

            # Reset project view state
            STATUS_SELECTED=0
            STATUS_SCROLL=0
            STATUS_PANE=0

            # Collect project data (suppress errors)
            status_collect_data 2>/dev/null || true
            status_add_activity "Entered project: $selected_project"
        fi
    fi
}

# Navigate into a worktree (project -> worktree view)
status_drill_down_worktree() {
    if [ "$STATUS_VIEW" = "project" ]; then
        local selected_wt="${STATUS_WORKTREES[$STATUS_SELECTED]:-}"
        if [ -n "$selected_wt" ]; then
            STATUS_SELECTED_WORKTREE="$selected_wt"
            STATUS_VIEW="worktree"
            STATUS_NEEDS_CLEAR=true  # Clear screen on view change
            STATUS_PANE=0
            status_add_activity "Viewing worktree: $selected_wt"
        fi
    fi
}

# Navigate back one level
status_nav_back() {
    STATUS_NEEDS_CLEAR=true  # Clear screen on view change
    case "$STATUS_VIEW" in
        worktree)
            STATUS_VIEW="project"
            STATUS_SELECTED_WORKTREE=""
            STATUS_PANE=0
            ;;
        project)
            if [ "$STATUS_SHOW_ALL" = true ]; then
                STATUS_VIEW="global"
                STATUS_SELECTED_PROJECT=""
                STATUS_PANE=0
                status_collect_global_data
            fi
            ;;
        global)
            # Already at top level, do nothing or exit
            ;;
    esac
}

# Get breadcrumb string for current view
status_get_breadcrumb() {
    case "$STATUS_VIEW" in
        global)
            echo "All Projects"
            ;;
        project)
            if [ "$STATUS_SHOW_ALL" = true ]; then
                echo "All Projects > ${STATUS_SELECTED_PROJECT:-$CURRENT_PROJECT}"
            else
                echo "${CURRENT_PROJECT:-unknown}"
            fi
            ;;
        worktree)
            if [ "$STATUS_SHOW_ALL" = true ]; then
                echo "All Projects > ${STATUS_SELECTED_PROJECT:-$CURRENT_PROJECT} > ${STATUS_SELECTED_WORKTREE:-}"
            else
                echo "${CURRENT_PROJECT:-unknown} > ${STATUS_SELECTED_WORKTREE:-}"
            fi
            ;;
    esac
}

# Add activity log entry
status_add_activity() {
    local message="$1"
    local timestamp=$(date +%H:%M)
    local worktree="${STATUS_WORKTREES[$STATUS_SELECTED]:-}"

    # Prepend to activity array (newest first)
    STATUS_ACTIVITY=("$timestamp $worktree $message" "${STATUS_ACTIVITY[@]}")

    # Keep only last 50 entries
    if [ ${#STATUS_ACTIVITY[@]} -gt 50 ]; then
        STATUS_ACTIVITY=("${STATUS_ACTIVITY[@]:0:50}")
    fi
}

# Draw a horizontal line
status_update_terminal_size() {
    local width=0 height=0

    # Check if /dev/tty is available
    local use_tty=false
    if [ -c /dev/tty ] && [ -r /dev/tty ] && [ -w /dev/tty ]; then
        use_tty=true
    fi

    # Method 1: Use stty size (most reliable for actual terminal)
    if $use_tty; then
        local stty_size
        stty_size=$(stty size 2>/dev/null </dev/tty) || stty_size=""
        if [ -n "$stty_size" ]; then
            height=${stty_size%% *}
            width=${stty_size##* }
        fi
    fi

    # Method 2: Use tput
    if [ "$width" -le 0 ] 2>/dev/null || [ -z "$width" ]; then
        if $use_tty; then
            width=$(tput cols 2>/dev/null </dev/tty) || width=0
            height=$(tput lines 2>/dev/null </dev/tty) || height=0
        else
            width=$(tput cols 2>/dev/null) || width=0
            height=$(tput lines 2>/dev/null) || height=0
        fi
    fi

    # Method 3: Query terminal using escape sequence (only if tty available)
    if [ "$width" -le 0 ] 2>/dev/null || [ -z "$width" ]; then
        if $use_tty; then
            # Save cursor, move to 999,999, get position, restore cursor
            local pos
            printf '\033[s\033[999;999H\033[6n\033[u' >/dev/tty 2>/dev/null
            IFS=';' read -t 1 -s -d 'R' -r _ pos </dev/tty 2>/dev/null
            if [ -n "$pos" ]; then
                width=${pos##*;}
                height=${pos%%;*}
                height=${height#*[}
            fi
        fi
    fi

    # Method 4: Use COLUMNS/LINES environment variables (often set by shell)
    if [ "$width" -le 0 ] 2>/dev/null || [ -z "$width" ]; then
        # Force bash to update COLUMNS/LINES
        shopt -s checkwinsize 2>/dev/null
        (:)  # Subshell triggers checkwinsize
        width=${COLUMNS:-80}
        height=${LINES:-24}
    fi

    # Fallback to defaults
    [ -z "$width" ] || [ "$width" -le 0 ] 2>/dev/null && width=80
    [ -z "$height" ] || [ "$height" -le 0 ] 2>/dev/null && height=24

    # Ensure minimum values
    [ "$width" -lt 60 ] && width=60
    [ "$height" -lt 15 ] && height=15

    STATUS_TERM_WIDTH=$width
    STATUS_TERM_HEIGHT=$height
}

status_draw_hline() {
    local width="$1"
    local char="${2:-─}"
    local i
    for ((i=0; i<width; i++)); do
        printf "%s" "$char"
    done
}

# Draw outer frame borders for all content rows (just the edges, no clearing)
status_render_frame() {
    local start_row=3
    local end_row=$((STATUS_TERM_HEIGHT - 3))

    echo -ne "$TH_HEADER"
    for ((row=start_row; row<=end_row; row++)); do
        tput cup $row 0
        printf "║"
        tput cup $row $((STATUS_TERM_WIDTH - 1))
        printf "║"
    done
    echo -ne "$TH_RESET"
}

# Draw box border top
status_draw_box_top() {
    local width="$1"
    local title="$2"
    local active="${3:-false}"

    if [ "$active" = true ]; then
        echo -ne "$TH_BORDER_ACTIVE"
    else
        echo -ne "$TH_BORDER"
    fi

    printf "┌─"
    if [ -n "$title" ]; then
        printf " %s " "$title"
        local title_len=$((${#title} + 4))
        status_draw_hline $((width - title_len - 3))
    else
        status_draw_hline $((width - 4))
    fi
    printf "─┐"
    echo -ne "$TH_RESET"
}

# Draw box border bottom
status_draw_box_bottom() {
    local width="$1"
    local active="${2:-false}"

    if [ "$active" = true ]; then
        echo -ne "$TH_BORDER_ACTIVE"
    else
        echo -ne "$TH_BORDER"
    fi

    printf "└"
    status_draw_hline $((width - 2))
    printf "┘"
    echo -ne "$TH_RESET"
}

# Render header bar
status_render_header() {
    local time_str=$(date +%H:%M:%S)
    local breadcrumb=$(status_get_breadcrumb)
    local spinner="${STATUS_SPINNERS[$STATUS_SPINNER_IDX]}"

    # Advance spinner
    STATUS_SPINNER_IDX=$(( (STATUS_SPINNER_IDX + 1) % ${#STATUS_SPINNERS[@]} ))

    # Move to top
    tput cup 0 0

    echo -ne "$TH_HEADER"
    printf "╔"
    status_draw_hline $((STATUS_TERM_WIDTH - 2)) "═"
    printf "╗"
    echo -ne "$TH_RESET"

    tput cup 1 0
    echo -ne "$TH_HEADER"
    printf "║  "
    echo -ne "$TH_TITLE"
    printf "⚡ PWT STATUS"
    echo -ne "$TH_RESET$TH_HEADER"
    printf " ══ "
    echo -ne "$TH_INFO"
    printf "%s" "$breadcrumb"
    echo -ne "$TH_RESET$TH_HEADER"

    # Right side: spinner and time
    local left_content="  ⚡ PWT STATUS ══ $breadcrumb"
    local right_content="$spinner $time_str  "
    local padding=$((STATUS_TERM_WIDTH - ${#left_content} - ${#right_content} - 2))
    [ $padding -lt 0 ] && padding=0

    printf "%*s" "$padding" ""
    echo -ne "$TH_DIM"
    printf "%s %s" "$spinner" "$time_str"
    echo -ne "$TH_RESET$TH_HEADER"
    printf "  ║"
    echo -ne "$TH_RESET"

    tput cup 2 0
    echo -ne "$TH_HEADER"
    printf "╠"
    status_draw_hline $((STATUS_TERM_WIDTH - 2)) "═"
    printf "╣"
    echo -ne "$TH_RESET"
}

# Render worktrees pane (left side)
status_render_pane_worktrees() {
    local start_row=3
    local start_col=1  # After outer frame
    local content_width=$((STATUS_TERM_WIDTH - 2))  # Between outer frames
    local pane_width=$(( content_width * 2 / 3 ))
    local pane_height=$((STATUS_TERM_HEIGHT - 10))
    local is_active=$([[ $STATUS_PANE -eq 0 ]] && echo true || echo false)

    tput cup $start_row $start_col
    status_draw_box_top "$pane_width" "WORKTREES" "$is_active"

    local visible_rows=$((pane_height - 2))
    local total_items=${#STATUS_WORKTREES[@]}

    # Adjust scroll to keep selected visible
    if [ $STATUS_SELECTED -lt $STATUS_SCROLL ]; then
        STATUS_SCROLL=$STATUS_SELECTED
    elif [ $STATUS_SELECTED -ge $((STATUS_SCROLL + visible_rows)) ]; then
        STATUS_SCROLL=$((STATUS_SELECTED - visible_rows + 1))
    fi

    local row=0
    for ((i=STATUS_SCROLL; i < STATUS_SCROLL + visible_rows && i < total_items; i++)); do
        tput cup $((start_row + 1 + row)) $start_col

        local name="${STATUS_WORKTREES[$i]}"
        local branch="${STATUS_BRANCHES[$i]}"
        local status="${STATUS_STATUSES[$i]}"
        local port="${STATUS_PORTS[$i]}"
        local server="${STATUS_SERVER_STATUS[$i]}"
        local main_div="${STATUS_MAIN_DIV[$i]}"
        local remote_div="${STATUS_REMOTE_DIV[$i]}"

        # Build marker
        local marker=" "
        local path="${STATUS_PATHS[$i]}"
        if [ "$PWD" = "$path" ]; then
            marker="@"
        elif is_previous_worktree "$path" 2>/dev/null; then
            marker="*"
        fi

        # Selection highlight
        if [ "$is_active" = true ] && [ $i -eq $STATUS_SELECTED ]; then
            echo -ne "$TH_SELECTED"
            printf "│▶"
        else
            echo -ne "$TH_BORDER"
            printf "│"
            echo -ne "$TH_RESET"
            printf " "
        fi

        # Marker
        if [ "$marker" = "@" ]; then
            echo -ne "$TH_INFO"
        elif [ "$marker" = "*" ]; then
            echo -ne "$TH_DIM"
        fi
        printf "%s " "$marker"
        echo -ne "$TH_RESET"

        # Name (with selection if active)
        if [ "$is_active" = true ] && [ $i -eq $STATUS_SELECTED ]; then
            echo -ne "$TH_SELECTED"
        fi
        printf "%-15s " "${name:0:15}"

        # Status symbols
        if [ -n "$status" ]; then
            echo -ne "$TH_WARN"
        else
            echo -ne "$TH_OK"
            status="✓"
        fi
        printf "%-4s" "$status"
        echo -ne "$TH_RESET"

        # Server status icon
        if [ "$is_active" = true ] && [ $i -eq $STATUS_SELECTED ]; then
            echo -ne "$TH_SELECTED"
        fi
        if [ -n "$port" ]; then
            if [ "$server" = "RUNNING" ]; then
                echo -ne "$TH_OK"
                printf "▶"
            else
                echo -ne "$TH_DIM"
                printf "◼"
            fi
            echo -ne "$TH_RESET"
            if [ "$is_active" = true ] && [ $i -eq $STATUS_SELECTED ]; then
                echo -ne "$TH_SELECTED"
            fi
            printf ":%-5s" "$port"
        else
            printf "  -    "
        fi
        echo -ne "$TH_RESET"

        # Divergence
        if [ "$is_active" = true ] && [ $i -eq $STATUS_SELECTED ]; then
            echo -ne "$TH_SELECTED"
        fi
        if [ -n "$main_div" ]; then
            echo -ne "$TH_INFO"
            printf "%-8s" "${main_div:0:8}"
        else
            printf "%-8s" ""
        fi
        echo -ne "$TH_RESET"

        # Remote divergence
        if [ "$is_active" = true ] && [ $i -eq $STATUS_SELECTED ]; then
            echo -ne "$TH_SELECTED"
        fi
        if [ -n "$remote_div" ]; then
            echo -ne "$TH_WARN"
            printf "%-6s" "${remote_div:0:6}"
        else
            printf "%-6s" ""
        fi
        echo -ne "$TH_RESET"

        # Fill remaining space
        local content_len=$((2 + 2 + 16 + 4 + 7 + 8 + 6))
        local remaining=$((pane_width - content_len - 1))
        if [ "$is_active" = true ] && [ $i -eq $STATUS_SELECTED ]; then
            echo -ne "$TH_SELECTED"
        fi
        printf "%*s" "$remaining" ""
        echo -ne "$TH_RESET"

        echo -ne "$TH_BORDER"
        printf "│"
        echo -ne "$TH_RESET"

        row=$((row + 1))
    done

    # Fill empty rows
    while [ $row -lt $visible_rows ]; do
        tput cup $((start_row + 1 + row)) $start_col
        echo -ne "$TH_BORDER"
        printf "│"
        printf "%*s" $((pane_width - 2)) ""
        printf "│"
        echo -ne "$TH_RESET"
        row=$((row + 1))
    done

    # Scrollbar indicator
    if [ $total_items -gt $visible_rows ]; then
        local scrollbar_pos=$((start_row + 1 + (STATUS_SCROLL * visible_rows / total_items)))
        tput cup $scrollbar_pos $((start_col + pane_width - 1))
        echo -ne "$TH_INFO"
        printf "▓"
        echo -ne "$TH_RESET"
    fi

    tput cup $((start_row + pane_height - 1)) $start_col
    status_draw_box_bottom "$pane_width" "$is_active"
}

# Render details pane (right side)
status_render_pane_details() {
    local start_row=3
    local content_width=$((STATUS_TERM_WIDTH - 2))
    local left_pane_width=$(( content_width * 2 / 3 ))
    local start_col=$((1 + left_pane_width))
    local pane_width=$((content_width - left_pane_width))
    local pane_height=$((STATUS_TERM_HEIGHT - 10))
    local is_active=$([[ $STATUS_PANE -eq 1 ]] && echo true || echo false)

    tput cup $start_row $start_col
    status_draw_box_top "$pane_width" "DETAILS" "$is_active"

    # Get selected worktree info
    local idx=$STATUS_SELECTED
    local name="${STATUS_WORKTREES[$idx]:-}"
    local branch="${STATUS_BRANCHES[$idx]:-}"
    local status="${STATUS_STATUSES[$idx]:-}"
    local port="${STATUS_PORTS[$idx]:-}"
    local server="${STATUS_SERVER_STATUS[$idx]:-}"
    local path="${STATUS_PATHS[$idx]:-}"
    local age="${STATUS_AGES[$idx]:-}"

    local row=1

    # Selected worktree name
    tput cup $((start_row + row)) $start_col
    echo -ne "$TH_BORDER"
    printf "│"
    echo -ne "$TH_RESET"
    printf " "
    echo -ne "$TH_TITLE"
    printf "▶ %s" "${name:-none}"
    echo -ne "$TH_RESET"
    printf "%*s" $((pane_width - ${#name} - 5)) ""
    echo -ne "$TH_BORDER"
    printf "│"
    echo -ne "$TH_RESET"
    row=$((row + 1))

    # Empty line
    tput cup $((start_row + row)) $start_col
    echo -ne "$TH_BORDER"
    printf "│%*s│" $((pane_width - 2)) ""
    echo -ne "$TH_RESET"
    row=$((row + 1))

    # Branch
    tput cup $((start_row + row)) $start_col
    echo -ne "$TH_BORDER"
    printf "│"
    echo -ne "$TH_RESET$TH_DIM"
    printf " Branch:"
    echo -ne "$TH_RESET"
    printf " %-*s" $((pane_width - 11)) "${branch:0:$((pane_width - 12))}"
    echo -ne "$TH_BORDER"
    printf "│"
    echo -ne "$TH_RESET"
    row=$((row + 1))

    # Status
    tput cup $((start_row + row)) $start_col
    echo -ne "$TH_BORDER"
    printf "│"
    echo -ne "$TH_RESET$TH_DIM"
    printf " Status:"
    echo -ne "$TH_RESET"
    if [ -n "$status" ]; then
        # Parse status symbols
        local staged=0 modified=0 untracked=0
        [[ "$status" == *"+"* ]] && staged=1
        [[ "$status" == *"!"* ]] && modified=1
        [[ "$status" == *"?"* ]] && untracked=1

        local status_str=""
        [ $staged -eq 1 ] && status_str="${status_str}+staged "
        [ $modified -eq 1 ] && status_str="${status_str}!modified "
        [ $untracked -eq 1 ] && status_str="${status_str}?untracked"

        echo -ne "$TH_WARN"
        printf " %-*s" $((pane_width - 11)) "$status_str"
    else
        echo -ne "$TH_OK"
        printf " %-*s" $((pane_width - 11)) "✓ clean"
    fi
    echo -ne "$TH_RESET$TH_BORDER"
    printf "│"
    echo -ne "$TH_RESET"
    row=$((row + 1))

    # Server info
    tput cup $((start_row + row)) $start_col
    echo -ne "$TH_BORDER"
    printf "│"
    echo -ne "$TH_RESET$TH_DIM"
    printf " Server:"
    echo -ne "$TH_RESET"
    if [ -n "$port" ]; then
        if [ "$server" = "RUNNING" ]; then
            echo -ne "$TH_OK"
            printf " ▶ :%-5s RUNNING" "$port"
        else
            echo -ne "$TH_DIM"
            printf " ◼ :%-5s STOPPED" "$port"
        fi
        printf "%*s" $((pane_width - 26)) ""
    else
        printf " %-*s" $((pane_width - 11)) "-"
    fi
    echo -ne "$TH_RESET$TH_BORDER"
    printf "│"
    echo -ne "$TH_RESET"
    row=$((row + 1))

    # Last activity
    tput cup $((start_row + row)) $start_col
    echo -ne "$TH_BORDER"
    printf "│"
    echo -ne "$TH_RESET$TH_DIM"
    printf " Last:"
    echo -ne "$TH_RESET"
    printf " %-*s" $((pane_width - 9)) "${age:-?} ago"
    echo -ne "$TH_BORDER"
    printf "│"
    echo -ne "$TH_RESET"
    row=$((row + 1))

    # Path
    tput cup $((start_row + row)) $start_col
    echo -ne "$TH_BORDER"
    printf "│"
    echo -ne "$TH_RESET$TH_DIM"
    printf " Path:"
    echo -ne "$TH_RESET"
    # Truncate path if too long
    local max_path=$((pane_width - 10))
    local display_path="$path"
    if [ ${#path} -gt $max_path ]; then
        display_path="...${path: -$((max_path - 3))}"
    fi
    printf " %-*s" $((pane_width - 9)) "$display_path"
    echo -ne "$TH_BORDER"
    printf "│"
    echo -ne "$TH_RESET"
    row=$((row + 1))

    # Fill remaining rows
    local visible_rows=$((pane_height - 2))
    while [ $row -lt $visible_rows ]; do
        tput cup $((start_row + row)) $start_col
        echo -ne "$TH_BORDER"
        printf "│%*s│" $((pane_width - 2)) ""
        echo -ne "$TH_RESET"
        row=$((row + 1))
    done

    tput cup $((start_row + pane_height - 1)) $start_col
    status_draw_box_bottom "$pane_width" "$is_active"
}

# Render servers pane (bottom left)
status_render_pane_servers() {
    local worktrees_height=$((STATUS_TERM_HEIGHT - 10))
    local start_row=$((3 + worktrees_height))
    local start_col=1
    local content_width=$((STATUS_TERM_WIDTH - 2))
    local pane_width=$(( content_width * 2 / 3 ))
    local pane_height=5
    local is_active=$([[ $STATUS_PANE -eq 2 ]] && echo true || echo false)

    tput cup $start_row $start_col
    status_draw_box_top "$pane_width" "SERVERS" "$is_active"

    local row=0
    local visible_rows=$((pane_height - 2))

    # Collect servers with ports
    local server_indices=()
    for ((i=0; i<${#STATUS_WORKTREES[@]}; i++)); do
        if [ -n "${STATUS_PORTS[$i]}" ]; then
            server_indices+=($i)
        fi
    done

    # Adjust scroll
    local total_servers=${#server_indices[@]}
    if [ $STATUS_SERVER_SELECTED -lt $STATUS_SERVER_SCROLL ]; then
        STATUS_SERVER_SCROLL=$STATUS_SERVER_SELECTED
    elif [ $STATUS_SERVER_SELECTED -ge $((STATUS_SERVER_SCROLL + visible_rows)) ]; then
        STATUS_SERVER_SCROLL=$((STATUS_SERVER_SELECTED - visible_rows + 1))
    fi

    for ((si=STATUS_SERVER_SCROLL; si < STATUS_SERVER_SCROLL + visible_rows && si < total_servers; si++)); do
        local i=${server_indices[$si]}
        local name="${STATUS_WORKTREES[$i]}"
        local port="${STATUS_PORTS[$i]}"
        local server="${STATUS_SERVER_STATUS[$i]}"

        tput cup $((start_row + 1 + row)) $start_col

        if [ "$is_active" = true ] && [ $si -eq $STATUS_SERVER_SELECTED ]; then
            echo -ne "$TH_SELECTED"
            printf "│▶"
        else
            echo -ne "$TH_BORDER"
            printf "│ "
            echo -ne "$TH_RESET"
        fi

        # Port
        echo -ne "$TH_INFO"
        printf ":%-5s" "$port"
        echo -ne "$TH_RESET"

        if [ "$is_active" = true ] && [ $si -eq $STATUS_SERVER_SELECTED ]; then
            echo -ne "$TH_SELECTED"
        fi

        # Worktree name
        printf " %-12s " "${name:0:12}"

        # Status
        if [ "$server" = "RUNNING" ]; then
            echo -ne "$TH_OK"
            printf "▶ RUNNING "
        else
            echo -ne "$TH_DIM"
            printf "◼ STOPPED "
        fi
        echo -ne "$TH_RESET"

        if [ "$is_active" = true ] && [ $si -eq $STATUS_SERVER_SELECTED ]; then
            echo -ne "$TH_SELECTED"
        fi

        # PID if running
        if [ "$server" = "RUNNING" ]; then
            local pids=$(get_pids_on_port "$port" 2>/dev/null | head -1)
            printf "PID %-6s" "${pids:-?}"
        else
            printf "%10s" ""
        fi

        # Fill remaining
        local content_len=$((2 + 6 + 13 + 10 + 10))
        local remaining=$((pane_width - content_len - 1))
        printf "%*s" "$remaining" ""
        echo -ne "$TH_RESET$TH_BORDER"
        printf "│"
        echo -ne "$TH_RESET"

        row=$((row + 1))
    done

    # Fill empty rows
    while [ $row -lt $visible_rows ]; do
        tput cup $((start_row + 1 + row)) $start_col
        echo -ne "$TH_BORDER"
        printf "│%*s│" $((pane_width - 2)) ""
        echo -ne "$TH_RESET"
        row=$((row + 1))
    done

    tput cup $((start_row + pane_height - 1)) $start_col
    status_draw_box_bottom "$pane_width" "$is_active"
}

# Render activity pane (bottom right)
status_render_pane_activity() {
    local worktrees_height=$((STATUS_TERM_HEIGHT - 10))
    local start_row=$((3 + worktrees_height))
    local content_width=$((STATUS_TERM_WIDTH - 2))
    local left_pane_width=$(( content_width * 2 / 3 ))
    local start_col=$((1 + left_pane_width))
    local pane_width=$((content_width - left_pane_width))
    local pane_height=5
    local is_active=$([[ $STATUS_PANE -eq 3 ]] && echo true || echo false)

    tput cup $start_row $start_col
    status_draw_box_top "$pane_width" "ACTIVITY" "$is_active"

    local row=0
    local visible_rows=$((pane_height - 2))
    local total_activities=${#STATUS_ACTIVITY[@]}

    for ((i=STATUS_ACTIVITY_SCROLL; i < STATUS_ACTIVITY_SCROLL + visible_rows && i < total_activities; i++)); do
        local entry="${STATUS_ACTIVITY[$i]}"

        tput cup $((start_row + 1 + row)) $start_col
        echo -ne "$TH_BORDER"
        printf "│"
        echo -ne "$TH_RESET"

        echo -ne "$TH_DIM"
        printf " ░ "
        echo -ne "$TH_RESET"

        # Truncate entry to fit
        local max_len=$((pane_width - 6))
        printf "%-*s" "$max_len" "${entry:0:$max_len}"

        echo -ne "$TH_BORDER"
        printf "│"
        echo -ne "$TH_RESET"

        row=$((row + 1))
    done

    # Fill empty rows or show placeholder
    if [ $total_activities -eq 0 ] && [ $row -eq 0 ]; then
        tput cup $((start_row + 1)) $start_col
        echo -ne "$TH_BORDER"
        printf "│"
        echo -ne "$TH_DIM"
        printf " (no recent activity)"
        printf "%*s" $((pane_width - 23)) ""
        echo -ne "$TH_RESET$TH_BORDER"
        printf "│"
        echo -ne "$TH_RESET"
        row=1
    fi

    while [ $row -lt $visible_rows ]; do
        tput cup $((start_row + 1 + row)) $start_col
        echo -ne "$TH_BORDER"
        printf "│%*s│" $((pane_width - 2)) ""
        echo -ne "$TH_RESET"
        row=$((row + 1))
    done

    tput cup $((start_row + pane_height - 1)) $start_col
    status_draw_box_bottom "$pane_width" "$is_active"
}

# Render footer with keyboard shortcuts
status_render_footer() {
    local start_row=$((STATUS_TERM_HEIGHT - 2))

    tput cup $start_row 0
    echo -ne "$TH_HEADER"
    printf "╠"
    status_draw_hline $((STATUS_TERM_WIDTH - 2)) "═"
    printf "╣"
    echo -ne "$TH_RESET"

    tput cup $((start_row + 1)) 0
    echo -ne "$TH_HEADER"
    printf "║"
    echo -ne "$TH_RESET"

    # Shortcuts
    echo -ne "$TH_INFO"
    printf " [Tab]"
    echo -ne "$TH_DIM"
    printf "pane"

    echo -ne "$TH_INFO"
    printf " [q]"
    echo -ne "$TH_DIM"
    printf "uit"

    echo -ne "$TH_INFO"
    printf " [↑↓]"
    echo -ne "$TH_DIM"
    printf "nav"

    echo -ne "$TH_INFO"
    printf " [Enter]"
    echo -ne "$TH_DIM"
    printf "cd"

    echo -ne "$TH_INFO"
    printf " [s]"
    echo -ne "$TH_DIM"
    printf "erver"

    echo -ne "$TH_INFO"
    printf " [p]"
    echo -ne "$TH_DIM"
    printf "ull"

    echo -ne "$TH_INFO"
    printf " [P]"
    echo -ne "$TH_DIM"
    printf "ush"

    echo -ne "$TH_INFO"
    printf " [d]"
    echo -ne "$TH_DIM"
    printf "iff"

    echo -ne "$TH_INFO"
    printf " [r]"
    echo -ne "$TH_DIM"
    printf "efresh"

    echo -ne "$TH_INFO"
    printf " [?]"
    echo -ne "$TH_DIM"
    printf "help"
    echo -ne "$TH_RESET"

    # Fill to end of line and close
    local shortcuts_len=90  # approximate
    local remaining=$((STATUS_TERM_WIDTH - shortcuts_len - 2))
    [ $remaining -lt 0 ] && remaining=0
    printf "%*s" "$remaining" ""
    echo -ne "$TH_HEADER"
    printf "║"
    tput el  # Clear to end of line
    echo -ne "$TH_RESET"

    tput cup $((STATUS_TERM_HEIGHT - 1)) 0
    echo -ne "$TH_HEADER"
    printf "╚"
    status_draw_hline $((STATUS_TERM_WIDTH - 2)) "═"
    printf "╝"
    tput el  # Clear to end of line
    echo -ne "$TH_RESET"
}

# Render help overlay
status_render_help() {
    local help_width=50
    local help_height=20
    local start_col=$(( (STATUS_TERM_WIDTH - help_width) / 2 ))
    local start_row=$(( (STATUS_TERM_HEIGHT - help_height) / 2 ))

    # Draw help box
    tput cup $start_row $start_col
    echo -ne "$TH_BORDER_ACTIVE"
    printf "╔"
    status_draw_hline $((help_width - 2)) "═"
    printf "╗"

    local help_lines=(
        ""
        "  KEYBOARD SHORTCUTS"
        ""
        "  Navigation:"
        "    Tab/Shift+Tab    Switch panes"
        "    ↑/k  ↓/j         Move up/down"
        "    1-4              Jump to pane"
        ""
        "  Actions:"
        "    Enter            cd to selected worktree"
        "    s                Toggle server start/stop"
        "    p                Git pull"
        "    P                Git push"
        "    d                Show git diff"
        "    f                Git fetch"
        "    r                Force refresh"
        ""
        "    q/Esc            Quit"
        ""
    )

    for ((i=0; i<${#help_lines[@]}; i++)); do
        tput cup $((start_row + 1 + i)) $start_col
        printf "║"
        printf "%-*s" $((help_width - 2)) "${help_lines[$i]}"
        printf "║"
    done

    tput cup $((start_row + help_height - 1)) $start_col
    printf "╚"
    status_draw_hline $((help_width - 2)) "═"
    printf "╝"
    echo -ne "$TH_RESET"
}

# Render projects pane for global view (left side)
status_render_pane_projects() {
    local start_row=3
    local start_col=1
    local content_width=$((STATUS_TERM_WIDTH - 2))
    local pane_width=$(( content_width * 2 / 3 ))
    local pane_height=$((STATUS_TERM_HEIGHT - 7))
    local is_active=$([[ $STATUS_PANE -eq 0 ]] && echo true || echo false)

    tput cup $start_row $start_col
    status_draw_box_top "$pane_width" "PROJECTS" "$is_active"

    local visible_rows=$((pane_height - 2))
    local total_items=${#STATUS_PROJECTS[@]}

    # Adjust scroll to keep selected visible
    if [ $STATUS_PROJECT_SELECTED -lt $STATUS_PROJECT_SCROLL ]; then
        STATUS_PROJECT_SCROLL=$STATUS_PROJECT_SELECTED
    elif [ $STATUS_PROJECT_SELECTED -ge $((STATUS_PROJECT_SCROLL + visible_rows)) ]; then
        STATUS_PROJECT_SCROLL=$((STATUS_PROJECT_SELECTED - visible_rows + 1))
    fi

    local row=0
    for ((i=STATUS_PROJECT_SCROLL; i < STATUS_PROJECT_SCROLL + visible_rows && i < total_items; i++)); do
        tput cup $((start_row + 1 + row)) $start_col

        local name="${STATUS_PROJECTS[$i]}"
        local path="${STATUS_PROJECT_PATHS[$i]}"
        local wt_count="${STATUS_PROJECT_WT_COUNT[$i]}"
        local dirty="${STATUS_PROJECT_DIRTY[$i]}"
        local servers="${STATUS_PROJECT_SERVERS[$i]}"

        # Selection highlight
        if [ "$is_active" = true ] && [ $i -eq $STATUS_PROJECT_SELECTED ]; then
            echo -ne "$TH_SELECTED"
            printf "│▶ "
        else
            echo -ne "$TH_BORDER"
            printf "│"
            echo -ne "$TH_RESET"
            printf "  "
        fi

        # Project name
        if [ "$is_active" = true ] && [ $i -eq $STATUS_PROJECT_SELECTED ]; then
            echo -ne "$TH_SELECTED"
        fi
        echo -ne "$TH_TITLE"
        printf "%-20s" "${name:0:20}"
        echo -ne "$TH_RESET"

        if [ "$is_active" = true ] && [ $i -eq $STATUS_PROJECT_SELECTED ]; then
            echo -ne "$TH_SELECTED"
        fi

        # Worktree count
        printf " %2d wt" "$wt_count"

        # Dirty count
        if [ "$dirty" -gt 0 ]; then
            echo -ne "$TH_WARN"
            printf "  !%d dirty" "$dirty"
            echo -ne "$TH_RESET"
            if [ "$is_active" = true ] && [ $i -eq $STATUS_PROJECT_SELECTED ]; then
                echo -ne "$TH_SELECTED"
            fi
        else
            printf "         "
        fi

        # Server count
        if [ "$servers" -gt 0 ]; then
            echo -ne "$TH_OK"
            printf "  ▶%d" "$servers"
            echo -ne "$TH_RESET"
            if [ "$is_active" = true ] && [ $i -eq $STATUS_PROJECT_SELECTED ]; then
                echo -ne "$TH_SELECTED"
            fi
        else
            printf "    "
        fi

        # Fill remaining space
        local content_len=$((3 + 20 + 6 + 10 + 4))
        local remaining=$((pane_width - content_len - 1))
        [ $remaining -lt 0 ] && remaining=0
        printf "%*s" "$remaining" ""
        echo -ne "$TH_RESET$TH_BORDER"
        printf "│"
        echo -ne "$TH_RESET"

        row=$((row + 1))
    done

    # Fill empty rows
    while [ $row -lt $visible_rows ]; do
        tput cup $((start_row + 1 + row)) $start_col
        echo -ne "$TH_BORDER"
        printf "│"
        printf "%*s" $((pane_width - 2)) ""
        printf "│"
        echo -ne "$TH_RESET"
        row=$((row + 1))
    done

    tput cup $((start_row + pane_height - 1)) $start_col
    status_draw_box_bottom "$pane_width" "$is_active"
}

# Render project details pane for global view (right side)
status_render_pane_project_details() {
    local start_row=3
    local content_width=$((STATUS_TERM_WIDTH - 2))
    local left_pane_width=$(( content_width * 2 / 3 ))
    local start_col=$((1 + left_pane_width))
    local pane_width=$((content_width - left_pane_width))
    local pane_height=$((STATUS_TERM_HEIGHT - 7))
    local is_active=$([[ $STATUS_PANE -eq 1 ]] && echo true || echo false)

    tput cup $start_row $start_col
    status_draw_box_top "$pane_width" "PROJECT DETAILS" "$is_active"

    # Get selected project info
    local idx=$STATUS_PROJECT_SELECTED
    local name="${STATUS_PROJECTS[$idx]:-}"
    local path="${STATUS_PROJECT_PATHS[$idx]:-}"
    local wt_count="${STATUS_PROJECT_WT_COUNT[$idx]:-0}"
    local dirty="${STATUS_PROJECT_DIRTY[$idx]:-0}"
    local servers="${STATUS_PROJECT_SERVERS[$idx]:-0}"

    local row=1

    # Project name
    tput cup $((start_row + row)) $start_col
    echo -ne "$TH_BORDER"
    printf "│"
    echo -ne "$TH_RESET"
    printf " "
    echo -ne "$TH_TITLE"
    printf "▶ %s" "${name:-none}"
    echo -ne "$TH_RESET"
    printf "%*s" $((pane_width - ${#name} - 5)) ""
    echo -ne "$TH_BORDER"
    printf "│"
    echo -ne "$TH_RESET"
    row=$((row + 1))

    # Empty line
    tput cup $((start_row + row)) $start_col
    echo -ne "$TH_BORDER"
    printf "│%*s│" $((pane_width - 2)) ""
    echo -ne "$TH_RESET"
    row=$((row + 1))

    # Path
    tput cup $((start_row + row)) $start_col
    echo -ne "$TH_BORDER"
    printf "│"
    echo -ne "$TH_RESET$TH_DIM"
    printf " Path:"
    echo -ne "$TH_RESET"
    local max_path=$((pane_width - 10))
    local display_path="$path"
    if [ ${#path} -gt $max_path ]; then
        display_path="...${path: -$((max_path - 3))}"
    fi
    printf " %-*s" $((pane_width - 9)) "$display_path"
    echo -ne "$TH_BORDER"
    printf "│"
    echo -ne "$TH_RESET"
    row=$((row + 1))

    # Worktrees
    tput cup $((start_row + row)) $start_col
    echo -ne "$TH_BORDER"
    printf "│"
    echo -ne "$TH_RESET$TH_DIM"
    printf " Worktrees:"
    echo -ne "$TH_RESET"
    printf " %-*s" $((pane_width - 14)) "$wt_count"
    echo -ne "$TH_BORDER"
    printf "│"
    echo -ne "$TH_RESET"
    row=$((row + 1))

    # Dirty
    tput cup $((start_row + row)) $start_col
    echo -ne "$TH_BORDER"
    printf "│"
    echo -ne "$TH_RESET$TH_DIM"
    printf " Dirty:"
    echo -ne "$TH_RESET"
    if [ "$dirty" -gt 0 ]; then
        echo -ne "$TH_WARN"
        printf " %-*s" $((pane_width - 10)) "$dirty"
        echo -ne "$TH_RESET"
    else
        echo -ne "$TH_OK"
        printf " %-*s" $((pane_width - 10)) "0 (clean)"
        echo -ne "$TH_RESET"
    fi
    echo -ne "$TH_BORDER"
    printf "│"
    echo -ne "$TH_RESET"
    row=$((row + 1))

    # Servers
    tput cup $((start_row + row)) $start_col
    echo -ne "$TH_BORDER"
    printf "│"
    echo -ne "$TH_RESET$TH_DIM"
    printf " Servers:"
    echo -ne "$TH_RESET"
    if [ "$servers" -gt 0 ]; then
        echo -ne "$TH_OK"
        printf " %d running" "$servers"
    else
        printf " none"
    fi
    printf "%*s" $((pane_width - 20)) ""
    echo -ne "$TH_RESET$TH_BORDER"
    printf "│"
    echo -ne "$TH_RESET"
    row=$((row + 1))

    # Fill remaining rows
    local visible_rows=$((pane_height - 2))
    while [ $row -lt $visible_rows ]; do
        tput cup $((start_row + row)) $start_col
        echo -ne "$TH_BORDER"
        printf "│%*s│" $((pane_width - 2)) ""
        echo -ne "$TH_RESET"
        row=$((row + 1))
    done

    tput cup $((start_row + pane_height - 1)) $start_col
    status_draw_box_bottom "$pane_width" "$is_active"
}

# Worktree view data
declare -a STATUS_WT_FILES=()        # Modified files list
declare -a STATUS_WT_COMMITS=()      # Recent commits
declare -a STATUS_WT_STASHES=()      # Stash list
STATUS_WT_STAGED=0                   # Staged file count
STATUS_WT_MODIFIED=0                 # Modified file count
STATUS_WT_UNTRACKED=0                # Untracked file count

# Collect detailed worktree data for worktree view
status_collect_worktree_data() {
    local idx=$STATUS_SELECTED
    local path="${STATUS_PATHS[$idx]:-}"

    [ -z "$path" ] || [ ! -d "$path" ] && return

    # Clear arrays
    STATUS_WT_FILES=()
    STATUS_WT_COMMITS=()
    STATUS_WT_STASHES=()

    # Get detailed file status
    STATUS_WT_STAGED=$(git -C "$path" diff --cached --numstat 2>/dev/null | wc -l | tr -d ' ')
    STATUS_WT_MODIFIED=$(git -C "$path" diff --numstat 2>/dev/null | wc -l | tr -d ' ')
    STATUS_WT_UNTRACKED=$(git -C "$path" ls-files --others --exclude-standard 2>/dev/null | wc -l | tr -d ' ')

    # Get modified files (limited to 20)
    while IFS= read -r file; do
        [ -n "$file" ] && STATUS_WT_FILES+=("M $file")
    done < <(git -C "$path" diff --name-only 2>/dev/null | head -20)

    # Get staged files
    while IFS= read -r file; do
        [ -n "$file" ] && STATUS_WT_FILES+=("+ $file")
    done < <(git -C "$path" diff --cached --name-only 2>/dev/null | head -10)

    # Get untracked files
    while IFS= read -r file; do
        [ -n "$file" ] && STATUS_WT_FILES+=("? $file")
    done < <(git -C "$path" ls-files --others --exclude-standard 2>/dev/null | head -10)

    # Get recent commits (last 10)
    while IFS= read -r commit; do
        [ -n "$commit" ] && STATUS_WT_COMMITS+=("$commit")
    done < <(git -C "$path" log --oneline -10 2>/dev/null)

    # Get stashes
    while IFS= read -r stash; do
        [ -n "$stash" ] && STATUS_WT_STASHES+=("$stash")
    done < <(git -C "$path" stash list 2>/dev/null | head -5)
}

# Render git status pane for worktree view (left)
status_render_pane_git_status() {
    local start_row=3
    local start_col=1
    local content_width=$((STATUS_TERM_WIDTH - 2))
    local pane_width=$(( content_width * 2 / 3 ))
    local pane_height=$(( (STATUS_TERM_HEIGHT - 10) / 2 ))
    local is_active=$([[ $STATUS_PANE -eq 0 ]] && echo true || echo false)

    tput cup $start_row $start_col
    local wt="${STATUS_SELECTED_WORKTREE:-?}"
    status_draw_box_top "$pane_width" "GIT STATUS: $wt" "$is_active"

    local row=1
    local visible_rows=$((pane_height - 2))

    # Summary line
    tput cup $((start_row + row)) $start_col
    echo -ne "$TH_BORDER"
    printf "│"
    echo -ne "$TH_RESET"
    printf " "

    if [ $STATUS_WT_STAGED -gt 0 ]; then
        echo -ne "$TH_OK"
        printf "+%d staged  " "$STATUS_WT_STAGED"
        echo -ne "$TH_RESET"
    fi
    if [ $STATUS_WT_MODIFIED -gt 0 ]; then
        echo -ne "$TH_WARN"
        printf "!%d modified  " "$STATUS_WT_MODIFIED"
        echo -ne "$TH_RESET"
    fi
    if [ $STATUS_WT_UNTRACKED -gt 0 ]; then
        echo -ne "$TH_DIM"
        printf "?%d untracked" "$STATUS_WT_UNTRACKED"
        echo -ne "$TH_RESET"
    fi
    if [ $STATUS_WT_STAGED -eq 0 ] && [ $STATUS_WT_MODIFIED -eq 0 ] && [ $STATUS_WT_UNTRACKED -eq 0 ]; then
        echo -ne "$TH_OK"
        printf "✓ Clean"
        echo -ne "$TH_RESET"
    fi

    local remaining=$((pane_width - 50))
    [ $remaining -lt 0 ] && remaining=0
    printf "%*s" "$remaining" ""
    echo -ne "$TH_BORDER"
    printf "│"
    echo -ne "$TH_RESET"
    row=$((row + 1))

    # Separator
    tput cup $((start_row + row)) $start_col
    echo -ne "$TH_BORDER"
    printf "├"
    status_draw_hline $((pane_width - 2))
    printf "┤"
    echo -ne "$TH_RESET"
    row=$((row + 1))

    # File list
    local file_count=${#STATUS_WT_FILES[@]}
    for ((i=0; i < visible_rows - 3 && i < file_count; i++)); do
        local file="${STATUS_WT_FILES[$i]}"
        local prefix="${file:0:1}"
        local name="${file:2}"

        tput cup $((start_row + row)) $start_col
        echo -ne "$TH_BORDER"
        printf "│"
        echo -ne "$TH_RESET"
        printf " "

        case "$prefix" in
            "+") echo -ne "$TH_OK" ;;
            "M") echo -ne "$TH_WARN" ;;
            "?") echo -ne "$TH_DIM" ;;
        esac
        printf "%s " "$prefix"
        echo -ne "$TH_RESET"

        local max_name=$((pane_width - 6))
        printf "%-*s" "$max_name" "${name:0:$max_name}"
        echo -ne "$TH_BORDER"
        printf "│"
        echo -ne "$TH_RESET"
        row=$((row + 1))
    done

    # Fill remaining rows
    while [ $row -lt $((visible_rows)) ]; do
        tput cup $((start_row + row)) $start_col
        echo -ne "$TH_BORDER"
        printf "│%*s│" $((pane_width - 2)) ""
        echo -ne "$TH_RESET"
        row=$((row + 1))
    done

    tput cup $((start_row + pane_height - 1)) $start_col
    status_draw_box_bottom "$pane_width" "$is_active"
}

# Render recent commits pane for worktree view (right)
status_render_pane_commits() {
    local start_row=3
    local content_width=$((STATUS_TERM_WIDTH - 2))
    local left_pane_width=$(( content_width * 2 / 3 ))
    local start_col=$((1 + left_pane_width))
    local pane_width=$((content_width - left_pane_width))
    local pane_height=$(( (STATUS_TERM_HEIGHT - 10) / 2 ))
    local is_active=$([[ $STATUS_PANE -eq 1 ]] && echo true || echo false)

    tput cup $start_row $start_col
    status_draw_box_top "$pane_width" "RECENT COMMITS" "$is_active"

    local row=1
    local visible_rows=$((pane_height - 2))
    local commit_count=${#STATUS_WT_COMMITS[@]}

    for ((i=0; i < visible_rows && i < commit_count; i++)); do
        local commit="${STATUS_WT_COMMITS[$i]}"

        tput cup $((start_row + row)) $start_col
        echo -ne "$TH_BORDER"
        printf "│"
        echo -ne "$TH_RESET"

        # Hash (first 7 chars)
        echo -ne "$TH_INFO"
        printf " %.7s " "${commit%% *}"
        echo -ne "$TH_RESET"

        # Message
        local msg="${commit#* }"
        local max_msg=$((pane_width - 12))
        printf "%-*s" "$max_msg" "${msg:0:$max_msg}"

        echo -ne "$TH_BORDER"
        printf "│"
        echo -ne "$TH_RESET"
        row=$((row + 1))
    done

    # Fill empty rows
    while [ $row -lt $visible_rows ]; do
        tput cup $((start_row + row)) $start_col
        echo -ne "$TH_BORDER"
        printf "│%*s│" $((pane_width - 2)) ""
        echo -ne "$TH_RESET"
        row=$((row + 1))
    done

    tput cup $((start_row + pane_height - 1)) $start_col
    status_draw_box_bottom "$pane_width" "$is_active"
}

# Render stashes pane for worktree view (bottom left)
status_render_pane_stashes() {
    local git_height=$(( (STATUS_TERM_HEIGHT - 10) / 2 ))
    local start_row=$((3 + git_height))
    local start_col=1
    local content_width=$((STATUS_TERM_WIDTH - 2))
    local pane_width=$(( content_width * 2 / 3 ))
    local pane_height=$((STATUS_TERM_HEIGHT - start_row - 4))
    local is_active=$([[ $STATUS_PANE -eq 2 ]] && echo true || echo false)

    tput cup $start_row $start_col
    status_draw_box_top "$pane_width" "STASHES" "$is_active"

    local row=1
    local visible_rows=$((pane_height - 2))
    local stash_count=${#STATUS_WT_STASHES[@]}

    if [ $stash_count -eq 0 ]; then
        tput cup $((start_row + row)) $start_col
        echo -ne "$TH_BORDER"
        printf "│"
        echo -ne "$TH_DIM"
        printf " (no stashes)"
        printf "%*s" $((pane_width - 15)) ""
        echo -ne "$TH_RESET$TH_BORDER"
        printf "│"
        echo -ne "$TH_RESET"
        row=$((row + 1))
    else
        for ((i=0; i < visible_rows && i < stash_count; i++)); do
            local stash="${STATUS_WT_STASHES[$i]}"

            tput cup $((start_row + row)) $start_col
            echo -ne "$TH_BORDER"
            printf "│"
            echo -ne "$TH_RESET"

            local max_stash=$((pane_width - 4))
            printf " %-*s" "$max_stash" "${stash:0:$max_stash}"

            echo -ne "$TH_BORDER"
            printf "│"
            echo -ne "$TH_RESET"
            row=$((row + 1))
        done
    fi

    # Fill empty rows
    while [ $row -lt $visible_rows ]; do
        tput cup $((start_row + row)) $start_col
        echo -ne "$TH_BORDER"
        printf "│%*s│" $((pane_width - 2)) ""
        echo -ne "$TH_RESET"
        row=$((row + 1))
    done

    tput cup $((start_row + pane_height - 1)) $start_col
    status_draw_box_bottom "$pane_width" "$is_active"
}

# Render worktree info pane for worktree view (bottom right)
status_render_pane_worktree_info() {
    local git_height=$(( (STATUS_TERM_HEIGHT - 10) / 2 ))
    local start_row=$((3 + git_height))
    local content_width=$((STATUS_TERM_WIDTH - 2))
    local left_pane_width=$(( content_width * 2 / 3 ))
    local start_col=$((1 + left_pane_width))
    local pane_width=$((content_width - left_pane_width))
    local pane_height=$((STATUS_TERM_HEIGHT - start_row - 4))
    local is_active=$([[ $STATUS_PANE -eq 3 ]] && echo true || echo false)

    tput cup $start_row $start_col
    status_draw_box_top "$pane_width" "WORKTREE INFO" "$is_active"

    local idx=$STATUS_SELECTED
    local name="${STATUS_WORKTREES[$idx]:-}"
    local branch="${STATUS_BRANCHES[$idx]:-}"
    local port="${STATUS_PORTS[$idx]:-}"
    local server="${STATUS_SERVER_STATUS[$idx]:-}"
    local path="${STATUS_PATHS[$idx]:-}"
    local age="${STATUS_AGES[$idx]:-}"

    local row=1
    local visible_rows=$((pane_height - 2))

    # Branch
    tput cup $((start_row + row)) $start_col
    echo -ne "$TH_BORDER"
    printf "│"
    echo -ne "$TH_RESET$TH_DIM"
    printf " Branch: "
    echo -ne "$TH_RESET$TH_INFO"
    printf "%-*s" $((pane_width - 12)) "${branch:0:$((pane_width - 13))}"
    echo -ne "$TH_RESET$TH_BORDER"
    printf "│"
    echo -ne "$TH_RESET"
    row=$((row + 1))

    # Server
    tput cup $((start_row + row)) $start_col
    echo -ne "$TH_BORDER"
    printf "│"
    echo -ne "$TH_RESET$TH_DIM"
    printf " Server: "
    echo -ne "$TH_RESET"
    if [ -n "$port" ]; then
        if [ "$server" = "RUNNING" ]; then
            echo -ne "$TH_OK"
            printf "▶ :%s RUNNING" "$port"
        else
            echo -ne "$TH_DIM"
            printf "◼ :%s STOPPED" "$port"
        fi
    else
        printf "-"
    fi
    printf "%*s" $((pane_width - 25)) ""
    echo -ne "$TH_RESET$TH_BORDER"
    printf "│"
    echo -ne "$TH_RESET"
    row=$((row + 1))

    # Last activity
    tput cup $((start_row + row)) $start_col
    echo -ne "$TH_BORDER"
    printf "│"
    echo -ne "$TH_RESET$TH_DIM"
    printf " Last:   "
    echo -ne "$TH_RESET"
    printf "%-*s" $((pane_width - 12)) "${age:-?} ago"
    echo -ne "$TH_BORDER"
    printf "│"
    echo -ne "$TH_RESET"
    row=$((row + 1))

    # Fill remaining rows
    while [ $row -lt $visible_rows ]; do
        tput cup $((start_row + row)) $start_col
        echo -ne "$TH_BORDER"
        printf "│%*s│" $((pane_width - 2)) ""
        echo -ne "$TH_RESET"
        row=$((row + 1))
    done

    tput cup $((start_row + pane_height - 1)) $start_col
    status_draw_box_bottom "$pane_width" "$is_active"
}

# Main render function
status_render() {
    # Check if terminal was resized
    local old_width=$STATUS_TERM_WIDTH
    local old_height=$STATUS_TERM_HEIGHT
    status_update_terminal_size
    if [ "$old_width" != "$STATUS_TERM_WIDTH" ] || [ "$old_height" != "$STATUS_TERM_HEIGHT" ]; then
        STATUS_NEEDS_CLEAR=true
    fi

    # Clear screen if needed (view change, resize, help toggle)
    if [ "$STATUS_NEEDS_CLEAR" = true ]; then
        # Reset scroll region and clear completely
        printf '\033[r' 2>/dev/null || true
        tput clear 2>/dev/null || true
        tput cup 0 0 2>/dev/null || true
        STATUS_NEEDS_CLEAR=false
    fi

    # Move cursor to top-left
    tput cup 0 0 2>/dev/null || true

    # Minimum size check
    if [ $STATUS_TERM_WIDTH -lt 60 ] || [ $STATUS_TERM_HEIGHT -lt 15 ]; then
        tput cup 0 0
        echo "Terminal too small. Minimum: 60x15"
        return
    fi

    status_render_header
    status_render_frame  # Draw outer frame borders

    # Render panes based on current view
    case "$STATUS_VIEW" in
        global)
            status_render_pane_projects
            status_render_pane_project_details
            # No servers/activity panes in global view - simpler layout
            ;;
        project)
            status_render_pane_worktrees
            status_render_pane_details
            status_render_pane_servers
            status_render_pane_activity
            ;;
        worktree)
            # Detailed worktree view with git status, commits, stashes
            status_collect_worktree_data
            status_render_pane_git_status
            status_render_pane_commits
            status_render_pane_stashes
            status_render_pane_worktree_info
            ;;
    esac

    status_render_footer

    if [ "$STATUS_SHOW_HELP" = true ]; then
        status_render_help
    fi

    # Position cursor at safe location to prevent any stray output
    tput cup 0 $((STATUS_TERM_WIDTH - 1)) 2>/dev/null || true
}

# Handle navigation
status_nav_up() {
    case "$STATUS_VIEW" in
        global)
            case $STATUS_PANE in
                0) # Projects pane
                    if [ $STATUS_PROJECT_SELECTED -gt 0 ]; then
                        STATUS_PROJECT_SELECTED=$((STATUS_PROJECT_SELECTED - 1))
                    fi
                    ;;
            esac
            ;;
        project|worktree)
            case $STATUS_PANE in
                0) # Worktrees pane
                    if [ $STATUS_SELECTED -gt 0 ]; then
                        STATUS_SELECTED=$((STATUS_SELECTED - 1))
                    fi
                    ;;
                2) # Servers pane
                    if [ $STATUS_SERVER_SELECTED -gt 0 ]; then
                        STATUS_SERVER_SELECTED=$((STATUS_SERVER_SELECTED - 1))
                    fi
                    ;;
                3) # Activity pane
                    if [ $STATUS_ACTIVITY_SCROLL -gt 0 ]; then
                        STATUS_ACTIVITY_SCROLL=$((STATUS_ACTIVITY_SCROLL - 1))
                    fi
                    ;;
            esac
            ;;
    esac
}

status_nav_down() {
    case "$STATUS_VIEW" in
        global)
            case $STATUS_PANE in
                0) # Projects pane
                    local max=$((${#STATUS_PROJECTS[@]} - 1))
                    if [ $STATUS_PROJECT_SELECTED -lt $max ]; then
                        STATUS_PROJECT_SELECTED=$((STATUS_PROJECT_SELECTED + 1))
                    fi
                    ;;
            esac
            ;;
        project|worktree)
            case $STATUS_PANE in
                0) # Worktrees pane
                    local max=$((${#STATUS_WORKTREES[@]} - 1))
                    if [ $STATUS_SELECTED -lt $max ]; then
                        STATUS_SELECTED=$((STATUS_SELECTED + 1))
                    fi
                    ;;
                2) # Servers pane
                    # Count servers
                    local count=0
                    for port in "${STATUS_PORTS[@]}"; do
                        [ -n "$port" ] && count=$((count + 1))
                    done
                    local max=$((count - 1))
                    if [ $STATUS_SERVER_SELECTED -lt $max ]; then
                        STATUS_SERVER_SELECTED=$((STATUS_SERVER_SELECTED + 1))
                    fi
                    ;;
                3) # Activity pane
                    local max=$((${#STATUS_ACTIVITY[@]} - 3))
                    [ $max -lt 0 ] && max=0
                    if [ $STATUS_ACTIVITY_SCROLL -lt $max ]; then
                        STATUS_ACTIVITY_SCROLL=$((STATUS_ACTIVITY_SCROLL + 1))
                    fi
                    ;;
            esac
            ;;
    esac
}

status_nav_pane_next() {
    case "$STATUS_VIEW" in
        global)
            # Global view only has 2 panes
            STATUS_PANE=$(( (STATUS_PANE + 1) % 2 ))
            ;;
        *)
            STATUS_PANE=$(( (STATUS_PANE + 1) % 4 ))
            ;;
    esac
}

status_nav_pane_prev() {
    case "$STATUS_VIEW" in
        global)
            # Global view only has 2 panes
            STATUS_PANE=$(( (STATUS_PANE + 1) % 2 ))
            ;;
        *)
            STATUS_PANE=$(( (STATUS_PANE + 3) % 4 ))
            ;;
    esac
}

# Action: cd to selected worktree
status_action_cd() {
    local path="${STATUS_PATHS[$STATUS_SELECTED]}"
    if [ -n "$path" ] && [ -d "$path" ]; then
        # Cleanup and print cd command for shell integration
        status_cleanup
        echo "cd $path"
        exit 0
    fi
}

# Action: toggle server
status_action_toggle_server() {
    local idx=$STATUS_SELECTED
    if [ $STATUS_PANE -eq 2 ]; then
        # In servers pane, use server selection
        local count=0
        for ((i=0; i<${#STATUS_PORTS[@]}; i++)); do
            if [ -n "${STATUS_PORTS[$i]}" ]; then
                if [ $count -eq $STATUS_SERVER_SELECTED ]; then
                    idx=$i
                    break
                fi
                count=$((count + 1))
            fi
        done
    fi

    local name="${STATUS_WORKTREES[$idx]}"
    local port="${STATUS_PORTS[$idx]}"
    local server="${STATUS_SERVER_STATUS[$idx]}"
    local path="${STATUS_PATHS[$idx]}"

    if [ -z "$port" ]; then
        status_add_activity "No port configured"
        return
    fi

    if [ "$server" = "RUNNING" ]; then
        # Stop server
        local pids=$(get_pids_on_port "$port" 2>/dev/null)
        if [ -n "$pids" ]; then
            echo "$pids" | xargs kill 2>/dev/null || true
            status_add_activity "Server stopped :$port"
            STATUS_SERVER_STATUS[$idx]="STOPPED"
        fi
    else
        # Start server - this needs to run in background
        status_add_activity "Starting server :$port..."

        # Export environment and run Pwtfile server command
        (
            cd "$path" || exit 1
            export PWT_PORT="$port"
            export PWT_WORKTREE="$name"
            export PWT_WORKTREE_PATH="$path"
            export PORT="$port"

            # Try to run Pwtfile server command
            if has_pwtfile_command "server" 2>/dev/null; then
                run_pwtfile "server" &
            fi
        ) &>/dev/null &

        # Give it a moment to start
        sleep 1
        status_collect_data  # Refresh to get new status
    fi
}

# Action: git pull
status_action_git_pull() {
    local path="${STATUS_PATHS[$STATUS_SELECTED]}"
    local name="${STATUS_WORKTREES[$STATUS_SELECTED]}"

    if [ -n "$path" ] && [ -d "$path" ]; then
        status_add_activity "git pull..."
        git -C "$path" pull --quiet 2>/dev/null && \
            status_add_activity "pull completed" || \
            status_add_activity "pull failed"
        status_collect_data
    fi
}

# Action: git push
status_action_git_push() {
    local path="${STATUS_PATHS[$STATUS_SELECTED]}"
    local name="${STATUS_WORKTREES[$STATUS_SELECTED]}"

    if [ -n "$path" ] && [ -d "$path" ]; then
        status_add_activity "git push..."
        git -C "$path" push --quiet 2>/dev/null && \
            status_add_activity "push completed" || \
            status_add_activity "push failed"
        status_collect_data
    fi
}

# Action: show diff
status_action_show_diff() {
    local path="${STATUS_PATHS[$STATUS_SELECTED]}"

    if [ -n "$path" ] && [ -d "$path" ]; then
        # Temporarily exit TUI to show diff
        status_cleanup

        echo -e "${BLUE}Git diff for: ${STATUS_WORKTREES[$STATUS_SELECTED]}${NC}"
        echo ""
        git -C "$path" diff --stat
        echo ""
        echo -e "${DIM}Press Enter to return to status...${NC}"
        read -r

        # Re-initialize TUI
        status_init
    fi
}

# Action: git fetch
status_action_git_fetch() {
    status_add_activity "git fetch --all..."
    for path in "${STATUS_PATHS[@]}"; do
        if [ -d "$path" ]; then
            git -C "$path" fetch --quiet 2>/dev/null || true
        fi
    done
    status_add_activity "fetch completed"
    status_collect_data
}

# Handle keyboard input
status_handle_key() {
    local key="$1"

    # Debug mode: log key to activity
    if [ "${PWT_DEBUG:-}" = "1" ]; then
        local key_display="$key"
        case "$key" in
            $'\n') key_display="NEWLINE" ;;
            $'\r') key_display="CR" ;;
            $'\t') key_display="TAB" ;;
            $'\e') key_display="ESC_CHAR" ;;
            "") key_display="EMPTY" ;;
            " ") key_display="SPACE" ;;
        esac
        status_add_activity "KEY: [$key_display] VIEW: $STATUS_VIEW PANE: $STATUS_PANE"
    fi

    # Help mode toggle
    if [ "$STATUS_SHOW_HELP" = true ]; then
        STATUS_SHOW_HELP=false
        STATUS_NEEDS_CLEAR=true  # Clear after closing help
        return
    fi

    case "$key" in
        q|Q)
            STATUS_RUNNING=false
            ;;
        ESC)
            # Navigate back or quit if at top level
            if [ "$STATUS_VIEW" = "global" ]; then
                STATUS_RUNNING=false
            elif [ "$STATUS_VIEW" = "project" ] && [ "$STATUS_SHOW_ALL" != true ]; then
                STATUS_RUNNING=false
            else
                status_nav_back
            fi
            ;;
        $'\x7f'|LEFT|h)  # Backspace, Left arrow, or h
            # Navigate back one level
            if [ "$STATUS_VIEW" != "global" ]; then
                if [ "$STATUS_VIEW" = "project" ] && [ "$STATUS_SHOW_ALL" != true ]; then
                    # At project level without --all, just exit
                    :
                else
                    status_nav_back
                fi
            fi
            ;;
        "?")
            STATUS_SHOW_HELP=true
            STATUS_NEEDS_CLEAR=true  # Clear to show help overlay
            ;;
        UP|k)
            status_nav_up
            ;;
        DOWN|j)
            status_nav_down
            ;;
        $'\t') # Tab
            status_nav_pane_next
            ;;
        SHIFT_TAB)
            status_nav_pane_prev
            ;;
        1)
            STATUS_PANE=0
            ;;
        2)
            STATUS_PANE=1
            ;;
        3)
            STATUS_PANE=2
            ;;
        4)
            STATUS_PANE=3
            ;;
        ""|" "|$'\n'|$'\r'|RIGHT|l)  # Enter, Space, Newline, CR, Right arrow, or l
            # Drill down or action based on current view and pane
            case "$STATUS_VIEW" in
                global)
                    # Drill down into selected project
                    status_drill_down_project
                    ;;
                project)
                    if [ $STATUS_PANE -eq 0 ]; then
                        # Drill down into selected worktree
                        status_drill_down_worktree
                    else
                        # On other panes, do cd action
                        status_action_cd
                    fi
                    ;;
                worktree)
                    # In worktree view, cd to the worktree
                    status_action_cd
                    ;;
            esac
            ;;
        c)
            # Quick cd and exit (always)
            status_action_cd
            ;;
        s)
            status_action_toggle_server
            ;;
        p)
            status_action_git_pull
            ;;
        P)
            status_action_git_push
            ;;
        d)
            status_action_show_diff
            ;;
        f)
            status_action_git_fetch
            ;;
        r|R)
            # Refresh based on current view
            if [ "$STATUS_VIEW" = "global" ]; then
                status_collect_global_data
            else
                status_collect_data
            fi
            status_add_activity "Refreshed"
            ;;
    esac
}

# Main status command
cmd_status() {
    local show_all=false

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            -h|--help)
                echo "Usage: pwt status [options]"
                echo ""
                echo "Interactive TUI dashboard for monitoring worktrees."
                echo ""
                echo "Options:"
                echo "  --all, -a     Show all projects (global view)"
                echo "  --help, -h    Show this help"
                echo ""
                echo "Views:"
                echo "  Global        All projects (with --all flag)"
                echo "  Project       Worktrees for current project (default)"
                echo "  Worktree      Details for a single worktree"
                echo ""
                echo "Navigation:"
                echo "  Tab           Switch between panes"
                echo "  ↑/k ↓/j       Navigate up/down"
                echo "  Enter/→/l     Drill down into selection"
                echo "  Esc/←/h       Go back up one level"
                echo "  1-4           Jump to pane"
                echo ""
                echo "Actions:"
                echo "  c             cd to selected worktree and exit"
                echo "  s             Toggle server start/stop"
                echo "  p             Git pull"
                echo "  P             Git push"
                echo "  d             Show git diff"
                echo "  f             Git fetch all"
                echo "  r             Force refresh data"
                echo "  q             Quit"
                echo ""
                echo "Theme:"
                echo "  Set PWT_THEME environment variable to use custom theme."
                echo "  Themes are stored in ~/.pwt/themes/<name>.sh"
                return 0
                ;;
            -a|--all)
                show_all=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    STATUS_SHOW_ALL=$show_all

    # Set initial view based on flags
    if [ "$show_all" = true ]; then
        STATUS_VIEW="global"
        STATUS_SELECTED_PROJECT=""
    else
        STATUS_VIEW="project"
        STATUS_SELECTED_PROJECT="$CURRENT_PROJECT"
    fi

    # Initialize TUI
    status_init

    # Initial render
    status_render

    # Main event loop
    while [ "$STATUS_RUNNING" = true ]; do
        local now=$(date +%s)

        # Auto-refresh every N seconds based on current view
        if (( now - STATUS_LAST_REFRESH >= STATUS_REFRESH_INTERVAL )); then
            if [ "$STATUS_VIEW" = "global" ]; then
                status_collect_global_data 2>/dev/null || true
            else
                status_collect_data 2>/dev/null || true
            fi
            STATUS_LAST_REFRESH=$now
        fi

        # Render (suppress any stray output)
        status_render 2>/dev/null

        # Handle input
        if status_read_key; then
            status_handle_key "$STATUS_KEY" 2>/dev/null || true
        fi
    done

    # Cleanup
    status_cleanup
}

# Handle short flags that look like commands (before the main loop)
case "${1:-}" in
    -v|-V)
        echo "pwt version $PWT_VERSION"
        exit 0
        ;;
    -h)
        set -- "help"
        ;;
    -q)
        PWT_QUIET=true
        shift
        ;;
esac

# Parse global flags
while [[ "${1:-}" == --* ]]; do
    case "$1" in
        --project)
            CURRENT_PROJECT="$2"
            PROJECT_EXPLICIT=true
            shift 2
            ;;
        --help)
            set -- "help"
            break
            ;;
        --version)
            echo "pwt version $PWT_VERSION"
            exit 0
            ;;
        --quiet)
            PWT_QUIET=true
            shift
            ;;
        --verbose)
            PWT_VERBOSE=true
            shift
            ;;
        *)
            echo -e "${RED}Unknown option: $1${NC}"
            exit $EXIT_USAGE
            ;;
    esac
done

# Initialize pwt
init_pwt

# Check if first argument is a project name or alias (before command dispatch)
# This allows: pwt myproject list (instead of pwt --project myproject list)
if [ -n "${1:-}" ]; then
    _resolved=$(resolve_project_alias "$1")
    if [ -d "$PWT_PROJECTS_DIR/${_resolved}" ]; then
        # Existing project
        if [ "${2:-}" = "init" ]; then
            # pwt <existing-project> init → show already configured
            echo -e "${YELLOW}Already configured: $_resolved${NC}"
            echo ""
            cat "$PWT_PROJECTS_DIR/${_resolved}/config.json"
            exit 0
        fi
        # Load config and shift for other commands
        CURRENT_PROJECT="$_resolved"
        PROJECT_EXPLICIT=true
        load_project_config "$_resolved"
        shift

        # Check for: pwt <project> <worktree> <pwtfile-cmd|-->
        # e.g., pwt acme @ clean
        #       pwt acme WORKTREE-123 clean
        #       pwt acme @ -- git status
        #       pwt acme 17744 -- git status -- rspec
        if [ -n "${1:-}" ] && [ -n "${2:-}" ]; then
            _wt_target="$1"
            _second_arg="$2"
            _wt_path=""

            # Resolve worktree path (supports @, exact match, and fuzzy match)
            _wt_path=$(resolve_worktree_path "$_wt_target" 2>/dev/null) || true

            if [ -n "$_wt_path" ] && [ -d "$_wt_path" ]; then
                # Check if second arg is -- (run mode: pwt <worktree> -- <cmd>)
                if [ "$_second_arg" = "--" ]; then
                    shift 2  # Remove worktree and -- from args
                    cmd_run "$_wt_target" "$@"
                    exit 0
                fi

                # Check if second arg is a Pwtfile command
                if has_pwtfile_command "$_second_arg"; then
                    shift 2  # Remove worktree and command from args
                    # Set up context and run
                    if [ "$_wt_target" = "@" ]; then
                        PWT_WORKTREE="@"
                        PWT_WORKTREE_PATH="$MAIN_APP"
                        PWT_PORT=""
                        PWT_BRANCH=$(git -C "$MAIN_APP" branch --show-current 2>/dev/null || echo "master")
                    else
                        PWT_WORKTREE="$_wt_target"
                        PWT_WORKTREE_PATH="$_wt_path"
                        _wt_name=$(basename "$_wt_path")
                        PWT_PORT=$(get_metadata "$_wt_name" "port" 2>/dev/null || echo "")
                        PWT_BRANCH=$(get_metadata "$_wt_name" "branch" 2>/dev/null || echo "")
                    fi
                    export PWT_ARGS="$*"
                    run_pwtfile "$_second_arg"
                    exit 0
                fi
            fi
            unset _wt_target _second_arg _wt_path
        fi
    elif [ "${2:-}" = "init" ] && [ "$1" != "project" ]; then
        # New project name + init command: pwt <name> init [url]
        # Exclude "project" to allow: pwt project init <name>
        cmd_init_named "$1" "${3:-}"
        exit 0
    fi
    unset _resolved
fi

# Only run main dispatch when executed directly (not when sourced for testing)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then

# Detect project from current directory (unless already set via --project or first arg)
detect_project

# Check required dependencies
check_dependencies

# Main command dispatch
case "${1:-}" in
    init)
        cmd_init "${2:-}"
        ;;
    create|add)
        require_project --clone
        shift  # remove "create/add" from args
        cmd_create "$@"
        ;;
    list|ls)
        require_project --info-only
        shift  # remove "list" from args
        cmd_list "$@"
        ;;
    tree)
        shift  # remove "tree" from args
        cmd_tree "$@"
        ;;
    status)
        require_project --info-only
        shift  # remove "status" from args
        cmd_status "$@"
        ;;
    info|show)
        require_project --info-only
        cmd_info "${2:-}"
        ;;
    current)
        require_project --info-only
        shift  # remove "current" from args
        cmd_current "$@"
        ;;
    use)
        require_project
        shift  # remove "use" from args
        cmd_use "$@"
        ;;
    ps1)
        require_project --info-only
        cmd_ps1
        ;;
    remove|rm)
        require_project
        shift  # remove "remove" from args
        cmd_remove "$@"
        ;;
    server|s)
        require_project
        cmd_server "${2:-}"
        ;;
    repair|fix)
        require_project
        cmd_repair "${2:-}"
        ;;
    auto-remove|cleanup)
        require_project
        shift  # remove "auto-remove" from args
        cmd_auto_remove "$@"
        ;;
    restore)
        shift  # remove "restore" from args
        cmd_restore "$@"
        ;;
    fix-port)
        require_project
        cmd_fix_port "${2:-}"
        ;;
    meta)
        cmd_meta "${2:-}" "${3:-}" "${4:-}" "${5:-}"
        ;;
    alias)
        require_project --info-only
        cmd_alias "${2:-}"
        ;;
    config)
        cmd_config "${2:-}" "${3:-}"
        ;;
    -)
        # Shortcut: pwt - = pwt cd - (go to previous worktree)
        require_project --info-only
        cmd_cd "-"
        _cd_status=$?
        [ -t 1 ] && echo -e "${DIM}Tip: eval \"\$(pwt shell-init)\" for actual cd${NC}" >&2
        exit $_cd_status
        ;;
    cd)
        # Public cd - outputs path (use shell-init for actual directory change)
        require_project --info-only
        cmd_cd "${2:-}"
        _cd_status=$?
        # Hint only if interactive (not piped)
        [ -t 1 ] && echo -e "${DIM}Tip: eval \"\$(pwt shell-init)\" for actual cd${NC}" >&2
        exit $_cd_status
        ;;
    _cd)
        # Internal: output path for cd (used by shell function)
        require_project --info-only
        cmd_cd "${2:-}"
        ;;
    run)
        require_project
        shift  # remove "run" from args
        cmd_run "$@"
        ;;
    shell)
        require_project
        shift  # remove "shell" from args
        cmd_shell "$@"
        ;;
    editor|e)
        require_project
        cmd_editor "${2:-}"
        ;;
    ai)
        require_project
        shift  # remove "ai" from args
        cmd_ai "$@"
        ;;
    open)
        require_project
        cmd_open "${2:-}"
        ;;
    diff)
        require_project
        cmd_diff "${2:-}" "${3:-}"
        ;;
    copy|cp)
        require_project
        shift  # remove "copy" from args
        cmd_copy "$@"
        ;;
    for-each)
        require_project
        shift  # remove "for-each" from args
        cmd_for_each "$@"
        ;;
    steps)
        require_project
        cmd_steps
        ;;
    step)
        require_project
        shift  # remove "step" from args
        cmd_step "$@"
        ;;
    doctor)
        shift  # remove "doctor" from args
        cmd_doctor "$@"
        ;;
    select)
        require_project --info-only
        shift  # remove "select" from args
        cmd_select "$@"
        ;;
    _select)
        require_project --info-only
        shift
        cmd__select "$@"
        ;;
    pick)
        require_project
        shift  # remove "pick" from args
        cmd_pick "$@"
        ;;
    shell-init)
        cmd_shell_init "${2:-}"
        ;;
    setup-shell)
        cmd_setup_shell
        ;;
    claude-setup)
        shift  # remove "claude-setup" from args
        cmd_claude_setup "$@"
        ;;
    project)
        cmd_project "${2:-}" "${3:-}" "${4:-}" "${5:-}"
        ;;
    port)
        cmd_port "${2:-}"
        ;;
    version)
        echo "pwt version $PWT_VERSION"
        ;;
    "")
        # No command: if project was explicitly specified, cd to main; otherwise show help
        if [ "$PROJECT_EXPLICIT" = true ]; then
            cmd_cd "@"
            exit $?
        fi
        # Show help (duplicated from help case for bash compatibility)
        echo "pwt - Power Worktrees"
        echo "A tool for managing git worktrees across multiple projects"
        echo ""
        if [ -n "$CURRENT_PROJECT" ]; then
            echo -e "Current project: ${GREEN}$CURRENT_PROJECT${NC}"
            echo ""
        fi
        echo "Run 'pwt help' for full usage"
        ;;
    -h|--help|help)
        # Show help
        echo "pwt - Power Worktrees"
        echo "A tool for managing git worktrees across multiple projects"
        echo ""
        if [ -n "$CURRENT_PROJECT" ]; then
            echo -e "Current project: ${GREEN}$CURRENT_PROJECT${NC}"
            echo ""
        fi
        echo "Commands:"
        echo "  init [url]                     Initialize project (clone URL or configure current repo)"
        echo "  <name> init [url]              Initialize with specific name (pwt pc init <url>)"
        echo "  create|add <name> [base] [desc] Create new worktree (-e -a --from --from-current --dry-run)"
        echo "  list [flags]                   List worktrees (-v/--verbose, --dirty, --porcelain)"
        echo "  list statusline                Output for shell prompts"
        echo "  tree [--all|--dirty|--ports]   Visual tree view of worktrees"
        echo "  status                         Interactive TUI dashboard (like htop)"
        echo "  select [--preview]             Interactive worktree selector (fzf)"
        echo "  info [worktree]                Show worktree details"
        echo "  current [--name|--resolved]    Show current (symlink path, --resolved for actual)"
        echo "  use <worktree>                 Set worktree as current (atomic symlink swap)"
        echo "  pick                           Interactive select + auto-use (fzf)"
        echo "  ps1                            Fast prompt helper (O(1), no git)"
        echo "  remove [worktree] [flags]      Remove worktree (--with-branch, --force-branch)"
        echo "  cd [worktree|@|-]              Navigate to worktree (@ main, - previous)"
        echo "  run <worktree> <cmd>           Run command in worktree"
        echo "  for-each <cmd>                 Run command in all worktrees"
        echo "  editor [worktree]              Open worktree in editor"
        echo "  ai [worktree] [-- args]        Start AI tool in worktree"
        echo "  open [worktree]                Open worktree in Finder"
        echo "  diff <wt1> [wt2]               Show diff between worktrees"
        echo "  copy <src> <dest> <patterns>   Copy files between worktrees"
        echo "  server [worktree]              Start dev server (from Pwtfile)"
        echo "  fix-port [worktree]            Fix port conflict"
        echo "  auto-remove [target] [--execute] Remove worktrees merged into target"
        echo "  restore [backup] [worktree]    Recover backed up changes from trash"
        echo "  doctor                         Check system health and configuration"
        echo "  shell-init                     Output shell function for cd integration"
        echo "  meta [action] [args]           Manage worktree metadata"
        echo "  project [action] [args]        Manage project configs"
        echo "  plugin [action]                Manage plugins (list, install, create)"
        echo ""
        echo "Project selection (in order of priority):"
        echo "  1. pwt <project> <command>     Project as first argument"
        echo "  2. pwt --project <name> ...    Explicit flag"
        echo "  3. Auto-detect from pwd        Inside project or worktree dir"
        echo ""
        echo "First time setup:"
        echo "  pwt project init myproject"
        echo "  pwt project set myproject main_app ~/path/to/app"
        echo "  pwt project set myproject worktrees_dir ~/path/to/worktrees"
        echo "  pwt project set myproject branch_prefix \"user/\""
        echo ""
        echo "Examples:"
        echo "  pwt init git@github.com:user/app.git       # Clone and configure"
        echo "  pwt create TICKET-123 master \"fix\" -e -a  # Create + open editor + start AI"
        echo "  pwt create hotfix --from v1.2.3            # Create from tag"
        echo "  pwt list --dirty                           # Only show dirty worktrees"
        echo "  pwt run TICKET-123 npm test                # Run command in worktree"
        echo "  pwt diff TICKET-123                        # Diff worktree vs main"
        echo "  pwt auto-remove master                     # Preview cleanup (dry-run by default)"
        echo "  pwt restore list                           # List available backups"
        echo "  pwt doctor                                 # Check configuration"
        echo ""
        echo "Shell integration (add to ~/.zshrc):"
        echo "  eval \"\$(pwt shell-init)\""
        echo ""
        echo "After shell-init:"
        echo "  \$PWT_WORKTREE      Current worktree name (when in worktree)"
        echo "  \$PWT_PREVIOUS_PATH Previous path (enables 'pwt cd -')"
        echo ""
        echo "Plugins:"
        echo "  Extend pwt with custom commands. Run 'pwt plugin help' for details."
        echo "  Available via plugins: topology, context, benchmark, marker, conflicts, prompt"
        ;;
    plugin)
        shift
        cmd_plugin "$@"
        ;;
    *)
        # Try to run as Pwtfile command
        _pwtfile_cmd="$1"
        shift

        # 1. Check for plugin first (global extension)
        _plugin_dir="$PWT_DIR/plugins"
        _plugin="$_plugin_dir/pwt-$_pwtfile_cmd"
        if [ -x "$_plugin" ]; then
            # Export context for plugin
            export PWT_PLUGIN_NAME="$_pwtfile_cmd"
            export PWT_VERSION="$PWT_VERSION"
            export PWT_DIR="$PWT_DIR"

            # Project context (may be empty if no project detected)
            if detect_project 2>/dev/null; then
                export PWT_PROJECT="$CURRENT_PROJECT"
                export PWT_MAIN_APP="$MAIN_APP"
                export PWT_WORKTREES_DIR="$WORKTREES_DIR"
                export PWT_DEFAULT_BRANCH="${DEFAULT_BRANCH:-master}"
                export PWT_BASE_PORT="$BASE_PORT"
                export PWT_BRANCH_PREFIX="${BRANCH_PREFIX:-}"

                # Current worktree context (if in one)
                if [ -n "${PWT_WORKTREE:-}" ]; then
                    export PWT_WORKTREE
                    export PWT_WORKTREE_PATH="${WORKTREES_DIR}/${PWT_WORKTREE}"
                    export PWT_PORT=$(get_metadata "$PWT_WORKTREE" "port" 2>/dev/null || echo "")
                    export PWT_BRANCH=$(git -C "${WORKTREES_DIR}/${PWT_WORKTREE}" branch --show-current 2>/dev/null || echo "")
                fi
            fi

            # Execute plugin
            exec "$_plugin" "$@"
        fi

        # 2. Check if project has Pwtfile with this function
        if has_pwtfile_command "$_pwtfile_cmd"; then
            require_project --info-only

            # If project was explicitly specified (pwt <project> <cmd>), require worktree
            # e.g., "pwt acme clean" should error, use "pwt acme @ clean" instead
            if [ "$PROJECT_EXPLICIT" = true ]; then
                echo -e "${RED}Error: Pwtfile command '$_pwtfile_cmd' requires worktree context${NC}"
                echo ""
                echo "Usage:"
                echo "  pwt $CURRENT_PROJECT @ $_pwtfile_cmd              # Run in main app"
                echo "  pwt $CURRENT_PROJECT <worktree> $_pwtfile_cmd     # Run in specific worktree"
                echo "  pwt $CURRENT_PROJECT for-each $_pwtfile_cmd       # Run in all worktrees"
                echo "  cd <worktree> && pwt $_pwtfile_cmd                # Run in current directory"
                exit 1
            fi

            run_pwtfile_command "$_pwtfile_cmd" "$@"
        else
            echo -e "${RED}Unknown command: $_pwtfile_cmd${NC}"
            # Try to suggest similar commands (include installed plugins)
            _known_commands="create list tree info current use pick select remove cd run shell editor ai open diff copy server fix-port auto-remove restore doctor meta project plugin port help version for-each"
            # Add installed plugins to suggestions
            if [ -d "$_plugin_dir" ]; then
                for _p in "$_plugin_dir"/pwt-*; do
                    [ -x "$_p" ] && _known_commands+=" $(basename "$_p" | sed 's/^pwt-//')"
                done
            fi
            _suggestion=$(find_similar "$_pwtfile_cmd" "$_known_commands")
            if [ -n "$_suggestion" ]; then
                echo -e "Did you mean: ${GREEN}pwt $_suggestion${NC}?"
            fi
            echo "Run 'pwt help' for usage"
            exit $EXIT_USAGE
        fi
        ;;
esac

fi  # End of source guard
