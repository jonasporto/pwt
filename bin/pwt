#!/bin/bash
# pwt - Power Worktrees
# A generic tool for managing git worktrees across multiple projects
#
# Usage:
#   pwt create <branch> [base] [desc]   # Create worktree from branch
#   pwt list                            # List worktrees and status
#   pwt info [worktree]                 # Show worktree details
#   pwt remove <worktree>               # Remove worktree
#   pwt server                          # Start dev server
#   pwt fix-port [worktree]             # Fix port conflict
#   pwt auto-remove [target]            # Remove worktrees merged into target
#   pwt meta [action] [args]            # Manage worktree metadata
#   pwt project [action] [args]         # Manage project configs
#
# Project auto-detection:
#   pwt detects the current project from your working directory
#   or you can specify: pwt myproject create ...
#   or use flag: pwt --project myproject create ...
#
# First time setup:
#   pwt project init myproject
#   pwt project set myproject main_app ~/path/to/main/app
#   pwt project set myproject worktrees_dir ~/path/to/worktrees

set -e

# PWT directory structure
PWT_DIR="$HOME/.pwt"
PWT_META_FILE="$PWT_DIR/meta.json"
PWT_PROJECTS_DIR="$PWT_DIR/projects"

# Legacy support - will be overridden by project config
METADATA_DIR="$PWT_DIR"
METADATA_FILE="$PWT_META_FILE"
PROJECTS_DIR="$PWT_PROJECTS_DIR"

# Current project context (set by detect_project or --project flag)
CURRENT_PROJECT=""
MAIN_APP=""
WORKTREES_DIR=""
BRANCH_PREFIX=""
PROJECT_REMOTE=""
DEFAULT_BRANCH=""  # Detected from remote (master or main)
BASE_PORT=5000

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Cross-platform sed in-place edit (BSD/GNU compatible)
sed_inplace() {
    local expr="$1"
    local file="$2"
    if sed --version >/dev/null 2>&1; then
        sed -i "$expr" "$file"        # GNU sed
    else
        sed -i '' "$expr" "$file"     # BSD sed (macOS)
    fi
}

# Initialize PWT directory
init_pwt() {
    # Create directory structure if it doesn't exist
    if [ ! -d "$PWT_DIR" ]; then
        mkdir -p "$PWT_DIR"
        mkdir -p "$PWT_PROJECTS_DIR"
    fi

    # Create empty metadata file if it doesn't exist
    if [ ! -f "$PWT_META_FILE" ]; then
        echo '{}' > "$PWT_META_FILE"
    fi
}

# Alias for compatibility
init_metadata() {
    init_pwt
}

# Detect default branch from remote (master or main)
# Usage: detect_default_branch <repo_path>
# Sets DEFAULT_BRANCH global variable
detect_default_branch() {
    local repo="${1:-$MAIN_APP}"
    [ -z "$repo" ] || [ ! -d "$repo" ] && return

    # Try to get from remote HEAD
    local remote_head=$(git -C "$repo" symbolic-ref refs/remotes/origin/HEAD 2>/dev/null)
    if [ -n "$remote_head" ]; then
        DEFAULT_BRANCH="${remote_head#refs/remotes/origin/}"
        return
    fi

    # Fallback: check if main or master exists
    if git -C "$repo" rev-parse --verify origin/main >/dev/null 2>&1; then
        DEFAULT_BRANCH="main"
    elif git -C "$repo" rev-parse --verify origin/master >/dev/null 2>&1; then
        DEFAULT_BRANCH="master"
    else
        # Last resort default
        DEFAULT_BRANCH="master"
    fi
}

# Detect project from current directory
# Sets CURRENT_PROJECT, MAIN_APP, WORKTREES_DIR, BRANCH_PREFIX
detect_project() {
    local current_dir="$1"
    [ -z "$current_dir" ] && current_dir=$(pwd)

    # Already set via --project flag
    if [ -n "$CURRENT_PROJECT" ]; then
        load_project_config "$CURRENT_PROJECT"
        return 0
    fi

    # Search through existing configured projects
    if [ -d "$PWT_PROJECTS_DIR" ]; then
        for project_dir in "$PWT_PROJECTS_DIR"/*/; do
            [ -d "$project_dir" ] || continue
            local project_name=$(basename "$project_dir")
            local config_file="$project_dir/config.json"
            [ -f "$config_file" ] || continue

            local main_app=$(jq -r '.path // .main_app // empty' "$config_file")
            local worktrees_dir=$(jq -r '.worktrees_dir // empty' "$config_file")

            # Check if current dir is main_app or inside worktrees_dir
            if [ -n "$main_app" ]; then
                case "$current_dir" in
                    "$main_app"*|"$main_app")
                        CURRENT_PROJECT="$project_name"
                        load_project_config "$project_name"
                        return 0
                        ;;
                esac
            fi
            if [ -n "$worktrees_dir" ]; then
                case "$current_dir" in
                    "$worktrees_dir"*|"$worktrees_dir")
                        CURRENT_PROJECT="$project_name"
                        load_project_config "$project_name"
                        return 0
                        ;;
                esac
            fi
        done
    fi

    # No configured project found - try auto-detect from git
    auto_detect_project "$current_dir" || true
    return 0
}

# Auto-detect project from git repository (zero-config)
auto_detect_project() {
    local current_dir="$1"

    # Find git root
    local git_root=$(git -C "$current_dir" rev-parse --show-toplevel 2>/dev/null)
    [ -z "$git_root" ] && return 1

    # Project name = directory name
    local project_name=$(basename "$git_root")

    # Check if we're in a worktree (git-common-dir points to main repo's .git)
    local git_dir=$(git -C "$current_dir" rev-parse --git-dir 2>/dev/null)
    local git_common=$(git -C "$current_dir" rev-parse --git-common-dir 2>/dev/null)

    # In a worktree: git_dir is .git file, git_common is path to main's .git
    # In main repo: git_dir == git_common == .git
    if [ -n "$git_common" ] && [ "$git_dir" != "$git_common" ]; then
        # We're in a worktree, find the main repo
        # git_common = /path/to/main/.git, so main = dirname
        local main_repo=$(dirname "$git_common")
        if [ -d "$main_repo" ]; then
            git_root="$main_repo"
            project_name=$(basename "$git_root")
        fi
    fi

    # Set globals using conventions
    CURRENT_PROJECT="$project_name"
    MAIN_APP="$git_root"
    WORKTREES_DIR="$(dirname "$git_root")/${project_name}-worktrees"
    BRANCH_PREFIX=""

    return 0
}

# Resolve project alias to real project name
# Scans all project configs for "aliases" array
resolve_project_alias() {
    local name="$1"

    # First check if it's a real project
    if [ -f "$PWT_PROJECTS_DIR/$name/config.json" ]; then
        # Check it's not just an alias pointer (legacy) - check both .path and .main_app
        local has_main=$(jq -r '.path // .main_app // empty' "$PWT_PROJECTS_DIR/$name/config.json")
        if [ -n "$has_main" ]; then
            echo "$name"
            return 0
        fi
    fi

    # Scan all projects for aliases
    for config in "$PWT_PROJECTS_DIR"/*/config.json; do
        [ -f "$config" ] || continue
        if jq -e --arg name "$name" '.aliases // [] | index($name) != null' "$config" >/dev/null 2>&1; then
            basename "$(dirname "$config")"
            return 0
        fi
    done

    # Not found, return original (might be auto-detected)
    echo "$name"
}

# Load project configuration into global variables
# Falls back to auto-detect if config doesn't exist
# Supports aliases: config can have "aliases": ["pc", "planning-center"]
load_project_config() {
    local project="$1"

    # Resolve alias to real project name
    project=$(resolve_project_alias "$project")
    local config_file="$PWT_PROJECTS_DIR/$project/config.json"

    CURRENT_PROJECT="$project"

    if [ -f "$config_file" ]; then
        # Load from config file
        # path is preferred, main_app for backwards compatibility
        local cfg_path=$(jq -r '.path // .main_app // empty' "$config_file")
        local cfg_wt=$(jq -r '.worktrees_dir // empty' "$config_file")
        local cfg_prefix=$(jq -r '.branch_prefix // empty' "$config_file")
        local cfg_port=$(jq -r '.base_port // empty' "$config_file")
        local cfg_remote=$(jq -r '.remote // empty' "$config_file")

        [ -n "$cfg_path" ] && MAIN_APP="$cfg_path"
        [ -n "$cfg_wt" ] && WORKTREES_DIR="$cfg_wt"
        [ -n "$cfg_prefix" ] && BRANCH_PREFIX="$cfg_prefix"
        [ -n "$cfg_port" ] && BASE_PORT="$cfg_port"
        [ -n "$cfg_remote" ] && PROJECT_REMOTE="$cfg_remote"
    fi

    # Detect default branch after MAIN_APP is set
    detect_default_branch "$MAIN_APP"

    return 0
}

# Require project context for commands that need it
# Auto-creates worktrees directory if needed
# Usage: require_project [--clone] [--info-only]
#   --clone     Auto-clone from remote if not cloned
#   --info-only Skip clone check (for list/info commands)
require_project() {
    local auto_clone=false
    local info_only=false
    for arg in "$@"; do
        [ "$arg" = "--clone" ] && auto_clone=true
        [ "$arg" = "--info-only" ] && info_only=true
    done

    if [ -z "$CURRENT_PROJECT" ]; then
        echo -e "${RED}Error: No project detected${NC}"
        echo ""
        echo "Make sure you're inside a git repository."
        exit 1
    fi

    if [ -z "$MAIN_APP" ] || [ -z "$WORKTREES_DIR" ]; then
        echo -e "${RED}Error: Could not determine project paths${NC}"
        echo ""
        echo "Run from inside a git repository, or initialize a project:"
        echo "  cd /path/to/repo && pwt init"
        echo "  pwt init git@github.com:user/repo.git"
        echo ""
        echo "Or configure manually:"
        echo "  pwt project set myproject path /path/to/main/app"
        echo "  pwt project set myproject worktrees_dir /path/to/worktrees"
        exit 1
    fi

    # For info-only mode, skip clone/exist checks
    [ "$info_only" = true ] && return 0

    # Check if main app exists
    if [ ! -d "$MAIN_APP" ]; then
        if [ -n "$PROJECT_REMOTE" ]; then
            if [ "$auto_clone" = true ]; then
                echo -e "${BLUE}Cloning from remote: $PROJECT_REMOTE${NC}"
                local parent_dir=$(dirname "$MAIN_APP")
                mkdir -p "$parent_dir"
                if git clone "$PROJECT_REMOTE" "$MAIN_APP"; then
                    echo -e "${GREEN}✓ Cloned successfully${NC}"
                else
                    echo -e "${RED}Error: Failed to clone from $PROJECT_REMOTE${NC}"
                    exit 1
                fi
            else
                echo -e "${RED}Error: Project not cloned${NC}"
                echo ""
                echo "Run: pwt clone $CURRENT_PROJECT"
                echo "Or:  pwt $CURRENT_PROJECT create <branch> <base> <desc>"
                exit 1
            fi
        else
            echo -e "${RED}Error: Main app directory not found: $MAIN_APP${NC}"
            exit 1
        fi
    fi

    # Auto-create worktrees directory if it doesn't exist
    if [ ! -d "$WORKTREES_DIR" ]; then
        echo -e "${BLUE}Creating worktrees directory: $WORKTREES_DIR${NC}"
        mkdir -p "$WORKTREES_DIR"
    fi
}

# Initialize a project (clone from URL or configure current directory)
# Usage: cmd_init [url]
#   With url: clone and configure as pwt project
#   Without url: configure current git repo as pwt project
cmd_init() {
    local url="${1:-}"

    # If URL provided, clone and configure
    if [ -n "$url" ]; then
        # Extract project name from URL
        local project_name=$(basename "$url" .git)
        local target_dir="${PWD}/${project_name}"

        if [ -d "$target_dir" ]; then
            echo -e "${YELLOW}Already exists: $target_dir${NC}"
            echo "To configure: cd $target_dir && pwt init"
            return 0
        fi

        echo -e "${BLUE}Cloning: $url${NC}"
        if ! git clone "$url" "$target_dir"; then
            echo -e "${RED}Error: Failed to clone${NC}"
            exit 1
        fi

        # Configure the project
        local project_dir="$PWT_PROJECTS_DIR/$project_name"
        mkdir -p "$project_dir"

        cat > "$project_dir/config.json" << EOF
{
  "path": "$target_dir",
  "remote": "$url",
  "worktrees_dir": "${target_dir}-worktrees"
}
EOF

        echo -e "${GREEN}✓ Cloned and configured: $project_name${NC}"
        echo ""
        echo "Usage:"
        echo -e "  ${GREEN}pwt $project_name list${NC}"
        echo -e "  ${GREEN}pwt $project_name create TICKET base \"description\"${NC}"
        return 0
    fi

    # No URL - configure current directory
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        echo -e "${RED}Error: Not a git repository${NC}"
        echo ""
        echo "Usage:"
        echo "  pwt init <url>    # Clone and configure new project"
        echo "  cd <repo> && pwt init  # Configure existing repo"
        exit 1
    fi

    local repo_root=$(git rev-parse --show-toplevel)
    local project_name=$(basename "$repo_root")
    local remote_url=$(git remote get-url origin 2>/dev/null || echo "")

    # Check if already configured
    if [ -f "$PWT_PROJECTS_DIR/$project_name/config.json" ]; then
        echo -e "${YELLOW}Already configured: $project_name${NC}"
        echo ""
        cat "$PWT_PROJECTS_DIR/$project_name/config.json"
        return 0
    fi

    # Create config
    local project_dir="$PWT_PROJECTS_DIR/$project_name"
    mkdir -p "$project_dir"

    local config="{
  \"path\": \"$repo_root\",
  \"worktrees_dir\": \"${repo_root}-worktrees\""

    if [ -n "$remote_url" ]; then
        config="$config,
  \"remote\": \"$remote_url\""
    fi

    config="$config
}"

    echo "$config" > "$project_dir/config.json"

    echo -e "${GREEN}✓ Configured: $project_name${NC}"
    echo ""
    cat "$project_dir/config.json"
    echo ""
    echo "Usage:"
    echo -e "  ${GREEN}pwt $project_name list${NC}"
    echo -e "  ${GREEN}pwt $project_name create TICKET base \"description\"${NC}"
}

# Atomic write to metadata file with file locking
# Usage: atomic_metadata_write <jq_filter> [jq_args...]
atomic_metadata_write() {
    local jq_filter="$1"
    shift

    init_metadata

    local lock_dir="$METADATA_FILE.lock"
    local tmp_file=$(mktemp)
    local max_wait=50  # 5 seconds (50 * 0.1s)

    # Create tmp_file early and set trap to clean it up on any exit
    trap "rm -f '$tmp_file'" RETURN

    # Acquire lock using mkdir (atomic on all systems)
    local waited=0
    while ! mkdir "$lock_dir" 2>/dev/null; do
        waited=$((waited + 1))
        if [ $waited -ge $max_wait ]; then
            echo -e "${RED}Error: Could not acquire lock on metadata file${NC}" >&2
            return 1
        fi
        sleep 0.1
    done

    # Update trap to also clean lock after acquiring it
    trap "rm -rf '$lock_dir' '$tmp_file'" RETURN

    # Perform atomic write
    if jq "$jq_filter" "$@" "$METADATA_FILE" > "$tmp_file"; then
        mv "$tmp_file" "$METADATA_FILE"
        return 0
    else
        return 1
    fi
    # trap handles cleanup on return
}

# Save worktree metadata (namespaced by project)
# Usage: save_metadata <name> <path> <branch> <base> <base_commit> <port> <description>
save_metadata() {
    local name="$1"
    local path="$2"
    local branch="$3"
    local base="$4"
    local base_commit="$5"
    local port="$6"
    local description="$7"
    local created_at=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    local project="${CURRENT_PROJECT:-unknown}"

    atomic_metadata_write \
       '.[$project][$name] = {
           path: $path,
           branch: $branch,
           base: $base,
           base_commit: $base_commit,
           port: $port,
           description: $description,
           created_at: $created_at
       }' \
       --arg project "$project" \
       --arg name "$name" \
       --arg path "$path" \
       --arg branch "$branch" \
       --arg base "$base" \
       --arg base_commit "$base_commit" \
       --argjson port "$port" \
       --arg description "$description" \
       --arg created_at "$created_at"
}

# Get worktree metadata field (namespaced by project)
# Usage: get_metadata <name> <field>
get_metadata() {
    local name="$1"
    local field="$2"
    local project="${CURRENT_PROJECT:-unknown}"

    init_metadata

    jq -r --arg project "$project" --arg name "$name" --arg field "$field" \
        '.[$project][$name][$field] // empty' "$METADATA_FILE" 2>/dev/null
}

# Remove worktree metadata (namespaced by project)
# Usage: remove_metadata <name>
remove_metadata() {
    local name="$1"
    local project="${CURRENT_PROJECT:-unknown}"
    atomic_metadata_write 'del(.[$project][$name])' \
        --arg project "$project" --arg name "$name"
}

# Update worktree metadata field (namespaced by project)
# Usage: update_metadata <name> <field> <value>
update_metadata() {
    local name="$1"
    local field="$2"
    local value="$3"
    local project="${CURRENT_PROJECT:-unknown}"
    atomic_metadata_write \
       'if .[$project][$name] then .[$project][$name][$field] = $value else . end' \
       --arg project "$project" --arg name "$name" --arg field "$field" --arg value "$value"
}

# List all metadata for current project
list_metadata() {
    local project="${CURRENT_PROJECT:-unknown}"
    init_metadata
    jq --arg project "$project" '.[$project] // {}' "$METADATA_FILE"
}

# Get project config directory
# Usage: get_project_dir <project_name>
get_project_dir() {
    local project="$1"
    echo "$PROJECTS_DIR/$project"
}

# Get project config value
# Usage: get_project_config <project_name> <key>
get_project_config() {
    local project="$1"
    local key="$2"
    local config_file="$PROJECTS_DIR/$project/config.json"

    if [ -f "$config_file" ]; then
        jq -r --arg key "$key" '.[$key] // empty' "$config_file" 2>/dev/null
    fi
}

# Pwtfile helpers (available in Pwtfile)
# These are sourced when running a Pwtfile
pwtfile_env() {
    local key="$1"
    local value="$2"
    if [ -f .env ]; then
        if grep -q "^${key}=" .env; then
            sed_inplace "s|^${key}=.*|${key}=${value}|" .env
        else
            echo "${key}=${value}" >> .env
        fi
    fi
}

pwtfile_replace() {
    local file="$1"
    local from="$2"
    local to="$3"
    [ -f "$file" ] && sed_inplace "s|${from}|${to}|g" "$file"
}

pwtfile_database() {
    local action="$1"
    local name="$2"
    case "$action" in
        create) createdb "$name" 2>/dev/null || true ;;
        drop) dropdb "$name" 2>/dev/null || true ;;
    esac
}

pwtfile_rake() {
    bundle exec rake "$@" 2>/dev/null || true
}

pwtfile_run() {
    "$@" 2>/dev/null || true
}

# Symlink from main app to current worktree
# Usage: pwtfile_symlink <path>
# Example: pwtfile_symlink "node_modules"
pwtfile_symlink() {
    local path="$1"
    local source="$MAIN_APP/$path"
    local target="$PWD/$path"

    if [ ! -e "$source" ]; then
        echo "  ! Source not found: $source"
        return 1
    fi

    if [ -e "$target" ] && [ ! -L "$target" ]; then
        echo "  ! Target exists (not a symlink): $target"
        return 1
    fi

    rm -f "$target" 2>/dev/null
    ln -sf "$source" "$target"
    echo "  ✓ Symlinked: $path"
}

# Copy from main app to current worktree
# Usage: pwtfile_copy <path>
# Example: pwtfile_copy ".env"
pwtfile_copy() {
    local path="$1"
    local source="$MAIN_APP/$path"
    local target="$PWD/$path"

    if [ ! -e "$source" ]; then
        echo "  ! Source not found: $source"
        return 1
    fi

    if [ -d "$source" ]; then
        cp -r "$source" "$target"
    else
        cp "$source" "$target"
    fi
    echo "  ✓ Copied: $path"
}

# ============================================================
# List display helpers
# ============================================================

# Format relative time from Unix timestamp or git date
# Usage: format_relative_time <timestamp_or_git_date>
# Output: "30m", "4h", "2d", "3w", "5M"
format_relative_time() {
    local input="$1"
    local now=$(date +%s)
    local timestamp

    # Handle git date format or Unix timestamp
    if [[ "$input" =~ ^[0-9]+$ ]]; then
        timestamp="$input"
    else
        timestamp=$(date -j -f "%Y-%m-%d %H:%M:%S %z" "$input" +%s 2>/dev/null || \
                   date -d "$input" +%s 2>/dev/null || \
                   echo "$now")
    fi

    local diff=$((now - timestamp))

    if [ $diff -lt 60 ]; then
        echo "now"
    elif [ $diff -lt 3600 ]; then
        echo "$((diff / 60))m"
    elif [ $diff -lt 86400 ]; then
        echo "$((diff / 3600))h"
    elif [ $diff -lt 604800 ]; then
        echo "$((diff / 86400))d"
    elif [ $diff -lt 2592000 ]; then
        echo "$((diff / 604800))w"
    else
        echo "$((diff / 2592000))M"
    fi
}

# Get git status symbols
# Usage: get_status_symbols <dir>
# Output: "+!?" format (+ staged, ! modified, ? untracked)
get_status_symbols() {
    local dir="$1"
    local symbols=""

    local staged=$(git -C "$dir" diff --cached --numstat 2>/dev/null | wc -l | tr -d ' ')
    local modified=$(git -C "$dir" diff --numstat 2>/dev/null | wc -l | tr -d ' ')
    local untracked=$(git -C "$dir" ls-files --others --exclude-standard 2>/dev/null | wc -l | tr -d ' ')

    [ "$staged" -gt 0 ] && symbols="${symbols}+"
    [ "$modified" -gt 0 ] && symbols="${symbols}!"
    [ "$untracked" -gt 0 ] && symbols="${symbols}?"

    echo "$symbols"
}

# Get divergence from a ref (ahead/behind)
# Usage: get_divergence <dir> <ref>
# Output: "↑3" or "↓2" or "↑3↓2" or ""
get_divergence() {
    local dir="$1"
    local ref="$2"
    local result=""

    local ahead=$(git -C "$dir" rev-list --count "HEAD...$ref" --left-only 2>/dev/null || echo "0")
    local behind=$(git -C "$dir" rev-list --count "HEAD...$ref" --right-only 2>/dev/null || echo "0")

    # Remove whitespace
    ahead=$(echo "$ahead" | tr -d ' ')
    behind=$(echo "$behind" | tr -d ' ')

    [ "$ahead" -gt 0 ] && result="↑${ahead}"
    [ "$behind" -gt 0 ] && result="${result}↓${behind}"

    echo "$result"
}

# Get remote divergence (vs upstream)
# Usage: get_remote_divergence <dir>
# Output: "⇡3" or "⇣2" or "⇡3⇣2" or ""
get_remote_divergence() {
    local dir="$1"
    local branch=$(git -C "$dir" branch --show-current 2>/dev/null)
    [ -z "$branch" ] && return

    local upstream=$(git -C "$dir" rev-parse --abbrev-ref "${branch}@{upstream}" 2>/dev/null)
    [ -z "$upstream" ] && return

    local result=""
    local ahead=$(git -C "$dir" rev-list --count "${upstream}..HEAD" 2>/dev/null || echo "0")
    local behind=$(git -C "$dir" rev-list --count "HEAD..${upstream}" 2>/dev/null || echo "0")

    # Remove whitespace
    ahead=$(echo "$ahead" | tr -d ' ')
    behind=$(echo "$behind" | tr -d ' ')

    [ "$ahead" -gt 0 ] && result="⇡${ahead}"
    [ "$behind" -gt 0 ] && result="${result}⇣${behind}"

    echo "$result"
}

# Check if path is the previous worktree
# Usage: is_previous_worktree <path>
# Returns: 0 if previous, 1 otherwise
is_previous_worktree() {
    local path="$1"
    [ -n "$PWT_PREVIOUS_PATH" ] && [ "$PWT_PREVIOUS_PATH" = "$path" ]
}

# Calculate visual width of string (accounting for multi-byte Unicode)
# Usage: visual_width <string>
visual_width() {
    local str="$1"
    # Use LC_ALL=C to count actual characters, not bytes
    # This counts Unicode code points as 1 char each
    printf "%s" "$str" | LC_ALL=en_US.UTF-8 wc -m | tr -d ' '
}

# Pad string to fixed visual width
# Usage: pad_visual <string> <width>
pad_visual() {
    local str="$1"
    local width="$2"
    local visual=$(visual_width "$str")
    printf "%s" "$str"
    local i
    for ((i=visual; i<width; i++)); do
        printf " "
    done
}

# Get short commit hash
# Usage: get_short_hash <dir>
get_short_hash() {
    local dir="$1"
    git -C "$dir" rev-parse --short HEAD 2>/dev/null || echo "?"
}

# Get base branch from metadata or detect from reflog
# Usage: get_base_branch <worktree_name> <dir>
get_base_branch() {
    local name="$1"
    local dir="$2"

    # First try metadata
    local base=$(get_metadata "$name" "base")
    if [ -n "$base" ]; then
        echo "$base"
        return
    fi

    # Fallback to default branch
    echo "${DEFAULT_BRANCH:-master}"
}

# Hash-based port generation (deterministic)
# Usage: pwtfile_hash_port [name] [base]
# Output: port number
pwtfile_hash_port() {
    local name="${1:-$PWT_WORKTREE}"
    local base="${2:-${PORT_BASE:-5000}}"

    # Hash the name and take first 4 hex chars for offset 0-65535
    local hash=$(echo -n "$name" | md5 2>/dev/null || echo -n "$name" | md5sum | cut -d' ' -f1)
    local offset=$((16#${hash:0:4} % 1000))

    echo $((base + offset))
}

# ============================================================
# End list display helpers
# ============================================================

# Read PORT_BASE from Pwtfile (if defined)
# Sets BASE_PORT global variable
read_port_base() {
    local pwtfile=""

    # Check project config for custom pwtfile path first
    local config_pwtfile=$(get_project_config "$CURRENT_PROJECT" "pwtfile")
    if [ -n "$config_pwtfile" ]; then
        config_pwtfile="${config_pwtfile/#\~/$HOME}"
        [[ "$config_pwtfile" != /* ]] && config_pwtfile="$MAIN_APP/$config_pwtfile"
        [ -f "$config_pwtfile" ] && pwtfile="$config_pwtfile"
    fi

    # Fallback to default location
    if [ -z "$pwtfile" ] && [ -n "$MAIN_APP" ] && [ -f "$MAIN_APP/Pwtfile" ]; then
        pwtfile="$MAIN_APP/Pwtfile"
    fi

    [ -z "$pwtfile" ] && return 0

    # Extract PORT_BASE from Pwtfile (bash only)
    local port_base=$(grep -E "^PORT_BASE=" "$pwtfile" 2>/dev/null | head -1 | cut -d= -f2)

    if [ -n "$port_base" ] && [[ "$port_base" =~ ^[0-9]+$ ]]; then
        BASE_PORT=$((port_base - 1))  # -1 because next_available_port does +1
    fi
}

# Run Pwtfile if exists
# Looks for: Pwtfile, Pwtfile.rb, Pwtfile.js
# Usage: run_pwtfile <phase> (setup|teardown|server)
# Execute a single Pwtfile
# Arguments: pwtfile_path phase label
run_single_pwtfile() {
    local pwtfile="$1"
    local phase="$2"
    local label="$3"

    [ ! -f "$pwtfile" ] && return 0

    echo -e "${BLUE}Running $label ($phase)...${NC}"

    case "$pwtfile" in
        *.rb)
            ruby "$pwtfile" "$phase"
            ;;
        *.js)
            if command -v bun >/dev/null 2>&1; then
                bun "$pwtfile" "$phase"
            else
                node "$pwtfile" "$phase"
            fi
            ;;
        *)
            # Bash Pwtfile - source and call function
            (
                cd "$PWT_WORKTREE_PATH"
                # Make helpers available
                env() { pwtfile_env "$@"; }
                replace() { pwtfile_replace "$@"; }
                database() { pwtfile_database "$@"; }
                rake() { pwtfile_rake "$@"; }
                run() { pwtfile_run "$@"; }

                source "$pwtfile"

                # Call the phase function if it exists
                if type "$phase" &>/dev/null; then
                    "$phase"
                fi
            )
            ;;
    esac

    echo -e "  ${GREEN}✓${NC} $label ($phase) completed"
}

# Run Pwtfiles: project first, then global
run_pwtfile() {
    local phase="$1"

    # Export canonical PWT_* variables (always available)
    export PWT_PORT="${PWT_PORT:-}"
    export PWT_WORKTREE="${PWT_WORKTREE:-}"
    export PWT_WORKTREE_PATH="${PWT_WORKTREE_PATH:-}"
    export PWT_BRANCH="${PWT_BRANCH:-}"
    export PWT_TICKET="${PWT_TICKET:-}"
    export PWT_PROJECT="${PWT_PROJECT:-$CURRENT_PROJECT}"
    export MAIN_APP="${MAIN_APP:-}"

    # Back-compat aliases (short names)
    export PORT="$PWT_PORT"
    export WORKTREE="$PWT_WORKTREE"
    export WORKTREE_PATH="$PWT_WORKTREE_PATH"
    export BRANCH="$PWT_BRANCH"
    export TICKET="$PWT_TICKET"
    export PROJECT="$PWT_PROJECT"

    # Find and run project Pwtfile
    # Check project config for custom pwtfile path first
    local project_pwtfile=""
    local config_pwtfile=$(get_project_config "$CURRENT_PROJECT" "pwtfile")

    if [ -n "$config_pwtfile" ]; then
        # Expand ~ and resolve relative paths from MAIN_APP
        config_pwtfile="${config_pwtfile/#\~/$HOME}"
        [[ "$config_pwtfile" != /* ]] && config_pwtfile="$MAIN_APP/$config_pwtfile"
        [ -f "$config_pwtfile" ] && project_pwtfile="$config_pwtfile"
    fi

    # Fallback to default locations
    if [ -z "$project_pwtfile" ]; then
        if [ -f "$MAIN_APP/Pwtfile" ]; then
            project_pwtfile="$MAIN_APP/Pwtfile"
        elif [ -f "$MAIN_APP/Pwtfile.rb" ]; then
            project_pwtfile="$MAIN_APP/Pwtfile.rb"
        elif [ -f "$MAIN_APP/Pwtfile.js" ]; then
            project_pwtfile="$MAIN_APP/Pwtfile.js"
        fi
    fi

    [ -n "$project_pwtfile" ] && run_single_pwtfile "$project_pwtfile" "$phase" "Pwtfile"

    # Run global Pwtfile (user preferences)
    local global_pwtfile="$PWT_DIR/Pwtfile"
    [ -f "$global_pwtfile" ] && run_single_pwtfile "$global_pwtfile" "$phase" "Global Pwtfile"
}

# Run project hook if it exists
# Usage: run_hook <hook_name>
# Environment variables passed to hooks:
#   PWT_PROJECT      - Project name
#   PWT_WORKTREE     - Worktree name (directory name)
#   PWT_WORKTREE_PATH - Full path to worktree
#   PWT_BRANCH       - Git branch name
#   PWT_PORT         - Allocated port
#   PWT_TICKET       - Ticket/worktree name
#   PWT_BASE         - Base branch
#   PWT_DESC         - Description
run_hook() {
    local hook_name="$1"
    local hook_file="$PWT_PROJECTS_DIR/$CURRENT_PROJECT/hooks/$hook_name"

    [ -x "$hook_file" ] || return 0

    echo -e "${BLUE}Running $hook_name hook...${NC}"

    # Export all PWT_* variables for the hook
    export PWT_PROJECT="${PWT_PROJECT:-$CURRENT_PROJECT}"
    export PWT_WORKTREE="${PWT_WORKTREE:-}"
    export PWT_WORKTREE_PATH="${PWT_WORKTREE_PATH:-}"
    export PWT_BRANCH="${PWT_BRANCH:-}"
    export PWT_PORT="${PWT_PORT:-}"
    export PWT_TICKET="${PWT_TICKET:-}"
    export PWT_BASE="${PWT_BASE:-}"
    export PWT_DESC="${PWT_DESC:-}"

    if "$hook_file"; then
        echo -e "  ${GREEN}✓${NC} $hook_name hook completed"
        return 0
    else
        echo -e "  ${YELLOW}⚠${NC} $hook_name hook failed (exit $?)"
        return 1
    fi
}

# Legacy wrapper
run_project_hook() {
    local project="$1"
    local hook="$2"
    shift 2
    CURRENT_PROJECT="$project" run_hook "$hook"
}

# Initialize project config directory
# Usage: init_project <project_name>
init_project() {
    local project="$1"
    local project_dir="$PROJECTS_DIR/$project"

    if [ ! -d "$project_dir" ]; then
        mkdir -p "$project_dir/hooks"
        cat > "$project_dir/config.json" << 'EOF'
{
  "name": "PROJECT_NAME",
  "main_app": "",
  "worktrees_dir": "",
  "branch_prefix": "",
  "post_create_commands": [],
  "pre_remove_commands": []
}
EOF
        sed_inplace "s/PROJECT_NAME/$project/" "$project_dir/config.json"
        echo -e "${GREEN}✓ Created project config: $project_dir${NC}"
    fi
}

# Extract worktree name from branch
# Removes path prefix (feature/, jp/, etc) and sanitizes for directory use
extract_worktree_name() {
    local branch="$1"
    echo "$branch" | sed -E 's|.*/||; s|[^A-Za-z0-9._-]|-|g'
}

# Check if a port (and its Vite port +1) are free
# Returns 0 if both free, 1 if any occupied
is_port_pair_free() {
    local rails_port="$1"
    local vite_port=$((rails_port + 1))

    # Check if Rails port is occupied
    if lsof -ti ":$rails_port" > /dev/null 2>&1; then
        return 1
    fi

    # Check if Vite port is occupied
    if lsof -ti ":$vite_port" > /dev/null 2>&1; then
        return 1
    fi

    return 0
}

# Find next available port
# Strategy: try to reuse ports from removed worktrees before incrementing
next_available_port() {
    # Collect all ports "allocated" by existing worktrees
    local -a allocated_ports=()
    local project="${CURRENT_PROJECT:-unknown}"

    # BASE_PORT is reserved for main app
    allocated_ports+=("$BASE_PORT")

    # Read ports from metadata for current project (primary source)
    if [ -f "$METADATA_FILE" ]; then
        while IFS= read -r port; do
            if [[ "$port" =~ ^[0-9]+$ ]]; then
                allocated_ports+=("$port")
            fi
        done < <(jq -r --arg project "$project" '.[$project] // {} | .[].port // empty' "$METADATA_FILE" 2>/dev/null)
    fi

    # Also scan directory names (fallback for legacy worktrees without metadata)
    if [ -d "$WORKTREES_DIR" ]; then
        for dir in "$WORKTREES_DIR"/*/; do
            if [ -d "$dir" ]; then
                local dirname=$(basename "$dir")
                # Only extract port if it looks like old format (ends with -XXXX)
                if [[ "$dirname" =~ -([0-9]{4})$ ]]; then
                    local port="${BASH_REMATCH[1]}"
                    allocated_ports+=("$port")
                fi
            fi
        done
    fi

    # Find next free port, starting from BASE_PORT+1
    # Try to reuse "holes" from removed worktrees
    local candidate=$((BASE_PORT + 1))
    local max_attempts=100  # Avoid infinite loop

    for ((i=0; i<max_attempts; i++)); do
        local is_allocated=false

        # Check if port is allocated by existing worktree
        for allocated in "${allocated_ports[@]}"; do
            if [ "$candidate" -eq "$allocated" ]; then
                is_allocated=true
                break
            fi
        done

        if [ "$is_allocated" = false ]; then
            # Check if port (and Vite +1) are actually free on the system
            if is_port_pair_free "$candidate"; then
                echo "$candidate"
                return 0
            fi
        fi

        candidate=$((candidate + 1))
    done

    # Fallback: return next after all allocated
    local max_port=$BASE_PORT
    for allocated in "${allocated_ports[@]}"; do
        if [ "$allocated" -gt "$max_port" ]; then
            max_port=$allocated
        fi
    done
    echo $((max_port + 1))
}

# Check if server is running in a worktree
check_server_status() {
    local dir="$1"
    local pidfile="$dir/tmp/pids/server.pid"

    if [ -f "$pidfile" ]; then
        local pid=$(cat "$pidfile")
        if ps -p "$pid" > /dev/null 2>&1; then
            local port=$(ps -p "$pid" -o command= 2>/dev/null | grep -oE ':([0-9]+)\)' | tr -d ':)' || echo "?")
            echo -e "${GREEN}[running]${NC} PID $pid port $port"
            return
        fi
    fi
    echo -e "${YELLOW}[stopped]${NC}"
}



# Ensure JS dependencies (devDependencies) are installed.
# Prevents error: `error Command "vite" not found.`
install_js_deps() {
    if [ ! -f "package.json" ]; then
        return 0
    fi

    if [ -e "node_modules/.bin/vite" ]; then
        echo "  ✓ JS dependencies ok (vite already installed)"
        return 0
    fi

    echo "  Running yarn install (including devDependencies)..."

    if command -v yarn > /dev/null 2>&1; then
        if ! NODE_ENV=development YARN_PRODUCTION=false yarn install --silent --frozen-lockfile; then
            echo -e "  ${YELLOW}Warning: yarn.lock out of sync; running yarn install without --frozen-lockfile...${NC}"
            NODE_ENV=development YARN_PRODUCTION=false yarn install --silent
        fi
    elif command -v yarnpkg > /dev/null 2>&1; then
        if ! NODE_ENV=development YARN_PRODUCTION=false yarnpkg install --silent --frozen-lockfile; then
            echo -e "  ${YELLOW}Warning: yarn.lock out of sync; running yarnpkg install without --frozen-lockfile...${NC}"
            NODE_ENV=development YARN_PRODUCTION=false yarnpkg install --silent
        fi
    else
        echo -e "  ${YELLOW}Yarn not found; using npm install...${NC}"
        NPM_CONFIG_PRODUCTION=false npm install --silent
    fi

    if [ ! -e "node_modules/.bin/vite" ]; then
        echo -e "  ${RED}Error: Vite not found after installing JS dependencies.${NC}"
        echo "  Run manually: NODE_ENV=development YARN_PRODUCTION=false yarn install"
        exit 1
    fi

    echo "  ✓ JS dependencies installed (vite ok)"
}

# Command: create
# Usage: pwt create <branch> [base-ref] [description] [options]
# Options:
#   --dry-run, -n     Show what would be created without creating
#   -e, --editor      Open editor after creating
#   -a, --ai          Start AI tool after creating
#   --from <ref>      Create from specific ref (tag, commit, branch)
#   --from-current    Create from current branch
cmd_create() {
    local branch=""
    local base_ref=""
    local description=""
    local dry_run=false
    local open_editor=false
    local start_ai=false
    local from_current=false

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --dry-run|-n)
                dry_run=true
                shift
                ;;
            -e|--editor)
                open_editor=true
                shift
                ;;
            -a|--ai)
                start_ai=true
                shift
                ;;
            --from)
                base_ref="$2"
                shift 2
                ;;
            --from-current)
                from_current=true
                shift
                ;;
            -*)
                echo -e "${RED}Unknown option: $1${NC}"
                exit 1
                ;;
            --)
                # Everything after -- is the description
                shift
                description="$*"
                break
                ;;
            *)
                # Positional arguments: branch, base_ref, description
                if [ -z "$branch" ]; then
                    branch="$1"
                elif [ -z "$base_ref" ]; then
                    base_ref="$1"
                else
                    # Accumulate all remaining positional args as description
                    if [ -z "$description" ]; then
                        description="$1"
                    else
                        description="$description $1"
                    fi
                fi
                shift
                ;;
        esac
    done

    # Handle --from-current: use current branch as base
    if [ "$from_current" = true ]; then
        cd "$MAIN_APP"
        base_ref=$(git branch --show-current 2>/dev/null)
        if [ -z "$base_ref" ]; then
            echo -e "${RED}Error: Could not detect current branch${NC}"
            exit 1
        fi
    fi

    if [ -z "$branch" ]; then
        echo -e "${RED}Error: Branch/ticket not specified${NC}"
        echo "Usage: pwt create <branch> [base-ref] [description...] [options]"
        echo "       pwt create <branch> [options] -- description with spaces"
        echo ""
        echo "Options:"
        echo "  --dry-run, -n     Show what would be created without creating"
        echo "  -e, --editor      Open editor after creating"
        echo "  -a, --ai          Start AI tool after creating"
        echo "  --from <ref>      Create from specific ref (tag, commit, branch)"
        echo "  --from-current    Create from current branch"
        echo "  --                Everything after is the description"
        echo ""
        echo "Examples:"
        echo "  pwt create feature/my-feature"
        echo "  pwt create PROJ-123 master"
        echo "  pwt create PROJ-123 master \"add auth flow\""
        echo "  pwt create PROJ-123 master add auth flow        # works too"
        echo "  pwt create PROJ-123 --from v1.2.3 -- hotfix for bug"
        echo "  pwt create hotfix --from-current"
        echo "  pwt create PROJ-123 master -e -a"
        exit 1
    fi

    # Ensure worktrees_dir exists
    mkdir -p "$WORKTREES_DIR"

    # Extract worktree name from branch (removes path prefix, sanitizes)
    local worktree_name=$(extract_worktree_name "$branch")
    local worktree_dir="$WORKTREES_DIR/$worktree_name"

    # Check if worktree already exists
    if [ -d "$worktree_dir" ]; then
        echo -e "${RED}Error: Worktree already exists: $worktree_name${NC}"
        echo ""
        echo "Options:"
        echo "  1. Remove existing: pwt remove $worktree_name"
        echo "  2. Use a different branch name"
        exit 1
    fi

    # Read PORT_BASE from Pwtfile (if defined)
    read_port_base

    # Allocate port (stored in metadata only)
    local port=$(next_available_port)

    cd "$MAIN_APP"

    # Determine if need to create new branch or use existing
    local new_branch_name=""
    local git_worktree_args=()

    if [ -n "$base_ref" ]; then
        # Base ref provided: create new branch from it
        # Format: [prefix]ticket-name or [prefix]ticket-name-description-slug
        if [ -n "$description" ]; then
            # Convert description to slug: lowercase, spaces -> hyphens, remove special chars
            local slug=$(echo "$description" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | sed 's/[^a-z0-9-]//g' | sed 's/--*/-/g' | sed 's/^-//;s/-$//')
            new_branch_name="${BRANCH_PREFIX}${worktree_name}-${slug}"
        else
            new_branch_name="${BRANCH_PREFIX}${worktree_name}"
        fi

        # Fetch base ref if remote
        if [[ "$base_ref" == origin/* ]] || [[ "$base_ref" == "master" ]] || [[ "$base_ref" == "main" ]]; then
            local remote_ref="origin/${base_ref#origin/}"
            echo -e "${BLUE}Updating reference:${NC} $remote_ref"
            git fetch origin "${base_ref#origin/}" --quiet 2>/dev/null || true
            base_ref="$remote_ref"
        fi

        echo -e "${BLUE}Creating worktree:${NC} $worktree_name"
        echo -e "  New branch: $new_branch_name"
        echo -e "  Base:   $base_ref"
        echo -e "  Port:   $port"
        echo -e "  Dir:    $worktree_dir"
        echo ""

        git_worktree_args=(-b "$new_branch_name" "$worktree_dir" "$base_ref")
    else
        # No base ref: use existing branch
        echo -e "${BLUE}Creating worktree:${NC} $worktree_name"
        echo -e "  Branch: $branch"
        echo -e "  Port:   $port"
        echo -e "  Dir:    $worktree_dir"
        echo ""

        git_worktree_args=("$worktree_dir" "$branch")
    fi

    # Dry-run mode: show what would be created without creating
    if [ "$dry_run" = true ]; then
        echo -e "${YELLOW}[DRY-RUN] Would create worktree with above settings${NC}"
        echo ""
        echo "Run without --dry-run to create."
        exit 0
    fi

    # Create worktree
    git worktree add "${git_worktree_args[@]}"

    # Copy essential config files only
    echo -e "\n${BLUE}Copying essential config files...${NC}"

    # Copy .env (basic - Pwtfile can customize further)
    if [ -f "$MAIN_APP/.env" ]; then
        cp "$MAIN_APP/.env" "$worktree_dir/.env"
        echo "  ✓ .env"
    elif [ -f "$worktree_dir/.env.example" ]; then
        cp "$worktree_dir/.env.example" "$worktree_dir/.env"
        echo "  ✓ .env (from .env.example)"
    elif [ -f "$worktree_dir/.env.sample" ]; then
        cp "$worktree_dir/.env.sample" "$worktree_dir/.env"
        echo "  ✓ .env (from .env.sample)"
    fi

    # Copy master.key if exists (Rails credential file)
    if [ -f "$MAIN_APP/config/master.key" ]; then
        mkdir -p "$worktree_dir/config"
        cp "$MAIN_APP/config/master.key" "$worktree_dir/config/master.key"
        echo "  ✓ config/master.key"
    fi

    # Save metadata
    local final_branch="${new_branch_name:-$branch}"
    local final_base="${base_ref:-master}"
    local final_base_commit=$(git -C "$worktree_dir" merge-base HEAD "origin/${final_base#origin/}" 2>/dev/null || git -C "$worktree_dir" rev-parse HEAD 2>/dev/null)
    local final_base_short=$(git -C "$worktree_dir" rev-parse --short "$final_base_commit" 2>/dev/null || echo "?")
    local final_desc="${description:-}"

    save_metadata "$worktree_name" "$worktree_dir" "$final_branch" "$final_base" "$final_base_short" "$port" "$final_desc"
    echo -e "  ${GREEN}✓ Metadata saved${NC}"

    # Set context for Pwtfile and hooks
    export PWT_WORKTREE="$worktree_name"
    export PWT_WORKTREE_PATH="$worktree_dir"
    export PWT_BRANCH="$final_branch"
    export PWT_PORT="$port"
    export PWT_TICKET="$worktree_name"  # User can customize via Pwtfile
    export PWT_BASE="$final_base"
    export PWT_DESC="$final_desc"
    export PWT_PROJECT="$CURRENT_PROJECT"
    export MAIN_APP="$MAIN_APP"

    # Run Pwtfile setup (if exists), then hook
    run_pwtfile "setup"
    run_hook "post-create"

    echo -e "\n${GREEN}✓ Worktree created successfully!${NC}"
    echo ""
    echo "To use:"
    echo -e "  ${BLUE}cd $worktree_dir${NC}  or  ${BLUE}z ${worktree_name}${NC}"
    echo -e "  Port: ${BLUE}$port${NC}"

    # Open editor if requested
    if [ "$open_editor" = true ]; then
        echo ""
        cmd_editor "$worktree_name"
    fi

    # Start AI tool if requested
    if [ "$start_ai" = true ]; then
        echo ""
        cmd_ai "$worktree_name"
    fi
}

# Check port status for a worktree
# Arguments: port [worktree_dir]
# Returns: colored text with status
check_port_status() {
    local port="$1"
    local worktree_dir="$2"
    local vite_port=$((port + 1))

    if ! [[ "$port" =~ ^[0-9]+$ ]]; then
        echo -e "${YELLOW}[port ?]${NC}"
        return
    fi

    local rails_pid=$(lsof -ti ":$port" 2>/dev/null)
    local vite_pid=$(lsof -ti ":$vite_port" 2>/dev/null)

    # If no port occupied, it's free
    if [ -z "$rails_pid" ] && [ -z "$vite_pid" ]; then
        echo -e "${GREEN}[port $port free]${NC}"
        return
    fi

    # Check if this worktree's server is running
    # Pragmatic approach: if server.pid exists and PID is active,
    # we consider the port "in use" by the server itself
    # (even if the port PID is a child like puma)
    local own_server_running=false
    if [ -n "$worktree_dir" ] && [ -f "$worktree_dir/tmp/pids/server.pid" ]; then
        local own_server_pid=$(cat "$worktree_dir/tmp/pids/server.pid" 2>/dev/null)
        if [ -n "$own_server_pid" ] && ps -p "$own_server_pid" > /dev/null 2>&1; then
            own_server_running=true
        fi
    fi

    if [ "$own_server_running" = true ]; then
        echo -e "${GREEN}[port $port in use]${NC}"
        return
    fi

    # Port occupied but this worktree's server not running = conflict
    local issues=""
    if [ -n "$rails_pid" ]; then
        local proc=$(ps -p $rails_pid -o comm= 2>/dev/null || echo "?")
        issues="Rails:$proc"
    fi
    if [ -n "$vite_pid" ]; then
        local proc=$(ps -p $vite_pid -o comm= 2>/dev/null || echo "?")
        [ -n "$issues" ] && issues="$issues, "
        issues="${issues}Vite:$proc"
    fi
    echo -e "${RED}[port $port conflict: $issues]${NC}"
}

# Check if branch is merged into master
# IMPORTANT: Also checks for uncommitted changes to avoid data loss
check_merge_status() {
    local dir="$1"
    local target="${2:-master}"
    local wt_commit=$(git -C "$dir" rev-parse HEAD 2>/dev/null)

    if [ -z "$wt_commit" ]; then
        echo -e "${RED}[corrupted]${NC}"
        return
    fi

    # Check for uncommitted changes (staged, modified, or untracked)
    local has_changes=false
    local git_status=$(git -C "$dir" status --porcelain 2>/dev/null)
    if [ -n "$git_status" ]; then
        has_changes=true
    fi

    # If there are uncommitted changes, ALWAYS show as open (unsafe to remove)
    if [ "$has_changes" = true ]; then
        echo -e "${YELLOW}[has changes]${NC}"
        return
    fi

    # Fetch target branch to have updated reference
    cd "$MAIN_APP"
    git fetch origin "$target" --quiet 2>/dev/null || true

    if git merge-base --is-ancestor "$wt_commit" "origin/$target" 2>/dev/null; then
        # Check if branch ever diverged from target
        # If merge-base equals HEAD, branch never had unique commits
        local merge_base=$(git -C "$dir" merge-base HEAD "origin/$target" 2>/dev/null)
        if [ "$merge_base" = "$wt_commit" ]; then
            # Branch never diverged - no work done yet
            echo -e "${BLUE}[clean]${NC}"
        else
            # Branch had commits that are now in target
            echo -e "${GREEN}[merged]${NC}"
        fi
    else
        echo -e "${YELLOW}[open]${NC}"
    fi
}

# Command: list (porcelain output)
# Internal function for JSON output
cmd_list_porcelain() {
    local show_dirty_only="${1:-false}"
    local worktrees=()

    if [ -d "$WORKTREES_DIR" ] && [ "$(ls -A "$WORKTREES_DIR" 2>/dev/null)" ]; then
        for dir in "$WORKTREES_DIR"/*/; do
            [ -d "$dir" ] || continue

            local name=$(basename "$dir")
            local port=$(get_metadata "$name" "port")
            local branch=$(git -C "$dir" branch --show-current 2>/dev/null || echo "detached")
            local commit=$(git -C "$dir" rev-parse --short HEAD 2>/dev/null || echo "?")

            # Check for uncommitted changes
            local is_dirty=false
            local staged=$(git -C "$dir" diff --cached --numstat 2>/dev/null | wc -l | tr -d ' ')
            local unstaged=$(git -C "$dir" diff --numstat 2>/dev/null | wc -l | tr -d ' ')
            local untracked=$(git -C "$dir" ls-files --others --exclude-standard 2>/dev/null | wc -l | tr -d ' ')
            if [ "$staged" -gt 0 ] || [ "$unstaged" -gt 0 ] || [ "$untracked" -gt 0 ]; then
                is_dirty=true
            fi

            # Skip if --dirty and not dirty
            if [ "$show_dirty_only" = true ] && [ "$is_dirty" = false ]; then
                continue
            fi

            local meta_base=$(get_metadata "$name" "base")
            local meta_desc=$(get_metadata "$name" "description")

            worktrees+=("{\"name\":\"$name\",\"path\":\"$dir\",\"branch\":\"$branch\",\"commit\":\"$commit\",\"port\":\"$port\",\"dirty\":$is_dirty,\"base\":\"$meta_base\",\"description\":\"$meta_desc\"}")
        done
    fi

    # Output JSON
    echo "{"
    echo "  \"project\": \"$CURRENT_PROJECT\","
    echo "  \"main_app\": \"$MAIN_APP\","
    echo "  \"worktrees_dir\": \"$WORKTREES_DIR\","
    echo "  \"worktrees\": ["

    local first=true
    for wt in "${worktrees[@]}"; do
        if [ "$first" = true ]; then
            first=false
            echo "    $wt"
        else
            echo "    ,$wt"
        fi
    done

    echo "  ]"
    echo "}"
}

# Command: list
# Usage: pwt list [--dirty] [--porcelain]
cmd_list() {
    local show_dirty_only=false
    local porcelain=false
    local verbose=false
    local statusline=false

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --dirty)
                show_dirty_only=true
                shift
                ;;
            --porcelain)
                porcelain=true
                shift
                ;;
            --verbose|-v)
                verbose=true
                shift
                ;;
            statusline)
                statusline=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    # Statusline mode: compact single-line for prompts
    if [ "$statusline" = true ]; then
        cmd_list_statusline
        return
    fi

    # Porcelain mode: output JSON
    if [ "$porcelain" = true ]; then
        cmd_list_porcelain "$show_dirty_only"
        return
    fi

    # Verbose mode: detailed output (original format)
    if [ "$verbose" = true ]; then
        cmd_list_verbose "$show_dirty_only"
        return
    fi

    # Default: compact tabular format
    cmd_list_compact "$show_dirty_only"
}

# Print a table row with fixed column widths
# Usage: print_table_row <marker> <name> <hash> <base> <mkr> <stat> <main_div> <remote_div> <age> <msg>
print_table_row() {
    local marker="$1"
    local name="$2"
    local hash="$3"
    local base="$4"
    local mkr="$5"
    local stat="$6"
    local main_div="$7"
    local remote_div="$8"
    local age="$9"
    local msg="${10}"

    # Build row with proper visual padding for Unicode columns
    # Format: marker(2) name(20) hash(8) base(8) mkr(3) stat(4) main(10) remote(10) age(4) msg
    printf "  %-2s " "$marker"
    pad_visual "${name:0:20}" 20
    printf " "
    printf "%-8s " "${hash:0:8}"
    pad_visual "${base:0:8}" 8
    printf " "
    printf "%-3s " "${mkr:-·}"
    printf "%-4s " "${stat:-·}"
    pad_visual "${main_div:-·}" 10
    printf " "
    pad_visual "${remote_div:-·}" 10
    printf " "
    printf "%-4s %s\n" "$age" "$msg"
}

# Compact tabular list format (default)
cmd_list_compact() {
    local show_dirty_only="${1:-false}"

    # If project not cloned, show helpful message and exit
    if [ ! -d "$MAIN_APP" ]; then
        echo -e "${BLUE}${CURRENT_PROJECT}${NC}: ${YELLOW}not cloned${NC}"
        [ -n "$PROJECT_REMOTE" ] && echo -e "  Run: ${GREEN}pwt clone${NC}"
        return 0
    fi

    echo -e "${BLUE}${CURRENT_PROJECT}${NC}"
    echo ""

    # Print header
    print_table_row "" "Worktree" "Hash" "Base" "Mkr" "Stat" "main↕" "Remote" "Age" "Message"
    print_table_row "--" "--------------------" "--------" "--------" "---" "----" "----------" "----------" "----" "--------------------"

    # Main app row
    local main_branch=$(git -C "$MAIN_APP" branch --show-current 2>/dev/null || echo "?")
    local main_hash=$(get_short_hash "$MAIN_APP")
    local main_status=$(get_status_symbols "$MAIN_APP")
    local main_age_ts=$(git -C "$MAIN_APP" log -1 --format=%ct 2>/dev/null || echo "0")
    local main_age=$(format_relative_time "$main_age_ts")
    local main_msg=$(git -C "$MAIN_APP" log -1 --format=%s 2>/dev/null | cut -c1-20)
    local main_remote=$(get_remote_divergence "$MAIN_APP")

    # Check if main is current
    local main_marker=" "
    if [ "$PWD" = "$MAIN_APP" ]; then
        main_marker="@"
    elif is_previous_worktree "$MAIN_APP"; then
        main_marker="*"
    fi

    print_table_row "$main_marker" "${main_branch:0:20}" "$main_hash" "·" "" "${main_status:-·}" "·" "${main_remote:-·}" "$main_age" "$main_msg"

    # Worktrees
    local has_merged=false
    if [ -d "$WORKTREES_DIR" ] && [ "$(ls -A "$WORKTREES_DIR" 2>/dev/null)" ]; then
        for dir in "$WORKTREES_DIR"/*/; do
            [ -d "$dir" ] || continue
            local name=$(basename "$dir")

            # Git info
            local branch=$(git -C "$dir" branch --show-current 2>/dev/null || echo "detached")
            local hash=$(get_short_hash "$dir")
            local base=$(get_base_branch "$name" "$dir")

            # Status symbols
            local status=$(get_status_symbols "$dir")
            local is_dirty=false
            [ -n "$status" ] && is_dirty=true

            # Skip if --dirty and not dirty
            if [ "$show_dirty_only" = true ] && [ "$is_dirty" = false ]; then
                continue
            fi

            # Divergence from main
            local main_div=$(get_divergence "$dir" "origin/${DEFAULT_BRANCH:-master}")

            # Remote divergence
            local remote_div=$(get_remote_divergence "$dir")

            # Age
            local age_ts=$(git -C "$dir" log -1 --format=%ct 2>/dev/null || echo "0")
            local age=$(format_relative_time "$age_ts")

            # Markers: @ = current, * = previous
            local marker=" "
            if [ "$PWD" = "${dir%/}" ]; then
                marker="@"
            elif is_previous_worktree "${dir%/}"; then
                marker="*"
            fi

            # Check merge status for tips
            local merge_status=$(check_merge_status "$dir" "${DEFAULT_BRANCH:-master}" 2>/dev/null)
            if [[ "$merge_status" == *"merged"* ]] || [[ "$merge_status" == *"clean"* ]]; then
                has_merged=true
            fi

            # Get custom marker from metadata
            local custom_marker=$(get_metadata "$name" "marker")

            # Message (truncate)
            local msg=$(git -C "$dir" log -1 --format=%s 2>/dev/null | cut -c1-20)

            print_table_row "$marker" "$name" "$hash" "$base" "${custom_marker:-}" "${status:-·}" "${main_div:-·}" "${remote_div:-·}" "$age" "$msg"
        done
    fi

    echo ""

    # Tips
    if [ "$has_merged" = true ]; then
        echo -e "${YELLOW}Tip:${NC} Run ${GREEN}pwt auto-remove${NC} to clean up merged worktrees"
    fi

    # Legend
    echo -e "${BLUE}Legend:${NC} @ current  * previous  + staged  ! modified  ? untracked"
}

# Statusline for shell prompts
# Usage: pwt list statusline
# Output: [TICKET-123 +! ↑3 ⇡2] or empty if in main
cmd_list_statusline() {
    # Only show if in a worktree
    local worktree=""
    local dir=""

    if [ -n "$PWT_WORKTREE" ]; then
        worktree="$PWT_WORKTREE"
        dir="$WORKTREES_DIR/$worktree"
    else
        # Try to detect from PWD
        if [[ "$PWD" == *"-worktrees/"* ]]; then
            worktree=$(basename "$PWD")
            dir="$PWD"
        else
            # In main app or not in worktree - output nothing
            return 0
        fi
    fi

    [ ! -d "$dir" ] && return 0

    local status=$(get_status_symbols "$dir")
    local main_div=$(get_divergence "$dir" "origin/${DEFAULT_BRANCH:-master}")
    local remote_div=$(get_remote_divergence "$dir")

    # Build statusline
    local parts=()
    parts+=("$worktree")
    [ -n "$status" ] && parts+=("$status")
    [ -n "$main_div" ] && parts+=("$main_div")
    [ -n "$remote_div" ] && parts+=("$remote_div")

    echo "[${parts[*]}]"
}

# Verbose list format (original detailed format)
cmd_list_verbose() {
    local show_dirty_only="${1:-false}"

    echo -e "${BLUE}Worktrees (${CURRENT_PROJECT}):${NC}\n"

    # Show config info
    echo -e "  ${BLUE}Config:${NC}"

    # Project path
    if [ -d "$MAIN_APP" ]; then
        echo -e "    Path:      $MAIN_APP"
    else
        echo -e "    Path:      ${YELLOW}$MAIN_APP (not cloned)${NC}"
        [ -n "$PROJECT_REMOTE" ] && echo -e "    Remote:    $PROJECT_REMOTE"
    fi

    # Worktrees directory
    echo -e "    Worktrees: $WORKTREES_DIR"

    # Pwtfiles (show all that would be used)
    local pwtfiles=()
    local config_pwtfile=$(get_project_config "$CURRENT_PROJECT" "pwtfile")
    if [ -n "$config_pwtfile" ]; then
        config_pwtfile="${config_pwtfile/#\~/$HOME}"
        [[ "$config_pwtfile" != /* ]] && config_pwtfile="$MAIN_APP/$config_pwtfile"
        if [ -f "$config_pwtfile" ]; then
            pwtfiles+=("$config_pwtfile (config)")
        else
            pwtfiles+=("${config_pwtfile} ${YELLOW}(config, missing)${NC}")
        fi
    fi
    if [ -f "$MAIN_APP/Pwtfile" ]; then
        pwtfiles+=("$MAIN_APP/Pwtfile (local)")
    fi
    if [ -f "$PWT_DIR/Pwtfile" ]; then
        pwtfiles+=("$PWT_DIR/Pwtfile (global)")
    fi

    if [ ${#pwtfiles[@]} -gt 0 ]; then
        echo -e "    Pwtfile:   ${pwtfiles[0]}"
        for ((i=1; i<${#pwtfiles[@]}; i++)); do
            echo -e "               ${pwtfiles[$i]}"
        done
    else
        echo -e "    Pwtfile:   ${YELLOW}(none)${NC}"
    fi
    echo ""

    # If project not cloned, show helpful message and exit
    if [ ! -d "$MAIN_APP" ]; then
        echo -e "  ${YELLOW}Project not cloned.${NC}"
        if [ -n "$PROJECT_REMOTE" ]; then
            echo -e "  Run: ${GREEN}pwt clone${NC} to clone from remote"
        fi
        echo ""
        return 0
    fi

    # Main app - also used as default target for merge status
    local main_branch=$(git -C "$MAIN_APP" branch --show-current 2>/dev/null || echo "?")
    local default_target="${main_branch:-master}"
    local main_commit=$(git -C "$MAIN_APP" rev-parse --short HEAD 2>/dev/null || echo "?")
    echo -e "  ${YELLOW}${CURRENT_PROJECT}${NC} (main)"
    echo -e "    Branch: $main_branch @ $main_commit"
    echo -n "    Server: "
    check_server_status "$MAIN_APP"
    echo -n "    Port:   "
    check_port_status 5000 "$MAIN_APP"
    echo ""

    # Worktrees
    local has_port_issues=false
    local has_merged=false
    if [ -d "$WORKTREES_DIR" ] && [ "$(ls -A "$WORKTREES_DIR" 2>/dev/null)" ]; then
        for dir in "$WORKTREES_DIR"/*/; do
            if [ -d "$dir" ]; then
                local name=$(basename "$dir")

                # Get port from metadata first, fallback to extracting from name
                local port=$(get_metadata "$name" "port")
                if [ -z "$port" ]; then
                    # Legacy: extract from directory name if ends with -XXXX
                    if [[ "$name" =~ -([0-9]{4})$ ]]; then
                        port="${BASH_REMATCH[1]}"
                    fi
                fi

                # Git info
                local branch=$(git -C "$dir" branch --show-current 2>/dev/null || echo "detached")
                local commit=$(git -C "$dir" rev-parse --short HEAD 2>/dev/null || echo "?")
                local upstream=$(git -C "$dir" rev-parse --abbrev-ref "${branch}@{upstream}" 2>/dev/null || echo "")

                # Get metadata (if exists)
                local meta_base=$(get_metadata "$name" "base")
                local meta_base_commit=$(get_metadata "$name" "base_commit")
                local meta_desc=$(get_metadata "$name" "description")

                # Find base branch info
                local base_name=""
                local base_short=""
                local base_ahead=""

                if [ -n "$meta_base" ]; then
                    # Use metadata for base
                    base_name="$meta_base"
                    base_short="$meta_base_commit"
                    # Calculate ahead/behind from current base
                    local base_ref="origin/${meta_base#origin/}"
                    local base_commit=$(git -C "$dir" merge-base HEAD "$base_ref" 2>/dev/null)
                    if [ -n "$base_commit" ]; then
                        local commits_ahead=$(git -C "$dir" rev-list --count "${base_commit}..HEAD" 2>/dev/null || echo "0")
                        local commits_behind=$(git -C "$dir" rev-list --count "HEAD..$base_ref" 2>/dev/null || echo "0")
                        if [ "$commits_ahead" -gt 0 ] || [ "$commits_behind" -gt 0 ]; then
                            base_ahead=" (↑${commits_ahead} ↓${commits_behind})"
                        fi
                    fi
                else
                    # Fallback: calculate merge-base with default branch
                    base_name="${DEFAULT_BRANCH:-master}"
                    local base_commit=$(git -C "$dir" merge-base HEAD "origin/${DEFAULT_BRANCH:-master}" 2>/dev/null)
                    if [ -n "$base_commit" ]; then
                        base_short=$(git -C "$dir" rev-parse --short "$base_commit" 2>/dev/null)
                        local commits_ahead=$(git -C "$dir" rev-list --count "${base_commit}..HEAD" 2>/dev/null || echo "0")
                        local commits_behind=$(git -C "$dir" rev-list --count "HEAD..origin/${DEFAULT_BRANCH:-master}" 2>/dev/null || echo "0")
                        if [ "$commits_ahead" -gt 0 ] || [ "$commits_behind" -gt 0 ]; then
                            base_ahead=" (↑${commits_ahead} ↓${commits_behind})"
                        fi
                    fi
                fi

                # Get description from metadata or extract from branch name
                local desc=""
                if [ -n "$meta_desc" ]; then
                    desc="$meta_desc"
                elif [ -n "$branch" ] && [ "$branch" != "detached" ]; then
                    desc=$(echo "$branch" | sed -E 's|^[a-z]+/||')
                    desc=$(echo "$desc" | tr '-' ' ')
                fi

                # Check for uncommitted changes
                local changes=""
                local is_dirty=false
                local staged=$(git -C "$dir" diff --cached --numstat 2>/dev/null | wc -l | tr -d ' ')
                local unstaged=$(git -C "$dir" diff --numstat 2>/dev/null | wc -l | tr -d ' ')
                local untracked=$(git -C "$dir" ls-files --others --exclude-standard 2>/dev/null | wc -l | tr -d ' ')
                if [ "$staged" -gt 0 ] || [ "$unstaged" -gt 0 ] || [ "$untracked" -gt 0 ]; then
                    is_dirty=true
                    local parts=()
                    [ "$staged" -gt 0 ] && parts+=("${staged} staged")
                    [ "$unstaged" -gt 0 ] && parts+=("${unstaged} modified")
                    [ "$untracked" -gt 0 ] && parts+=("${untracked} untracked")
                    changes=$(IFS=', '; echo "${parts[*]}")
                fi

                # Skip if --dirty and not dirty
                if [ "$show_dirty_only" = true ] && [ "$is_dirty" = false ]; then
                    continue
                fi

                # Title with description
                if [ -n "$desc" ]; then
                    echo -e "  ${YELLOW}$name${NC} - ${desc}"
                else
                    echo -e "  ${YELLOW}$name${NC}"
                fi

                # Branch and commit
                echo -e "    Branch: $branch @ $commit"

                # Base (where it was created from)
                if [ -n "$base_short" ]; then
                    echo -e "    Base:   $base_name @ $base_short$base_ahead"
                fi

                # Upstream/target only if different from "origin/<branch>" (i.e., meaningful)
                if [ -n "$upstream" ] && [ "$upstream" != "origin/$branch" ] && [ "$upstream" != "origin/${DEFAULT_BRANCH:-master}" ]; then
                    echo -e "    Target: $upstream"
                fi

                # Uncommitted changes
                if [ -n "$changes" ]; then
                    echo -e "    Changes: ${YELLOW}$changes${NC}"
                fi

                # Server status
                echo -n "    Server: "
                check_server_status "$dir"

                # Port status
                echo -n "    Port:   "
                local port_status=$(check_port_status "$port" "$dir")
                echo -e "$port_status"
                if [[ "$port_status" == *"conflict"* ]]; then
                    has_port_issues=true
                fi

                # Merge status
                echo -n "    Status: "
                local merge_status=$(check_merge_status "$dir" "$default_target")
                echo -e "$merge_status"
                if [[ "$merge_status" == *"merged"* ]] || [[ "$merge_status" == *"clean"* ]]; then
                    has_merged=true
                fi
                echo ""
            fi
        done
    else
        echo -e "  ${YELLOW}(no worktrees created)${NC}"
        echo ""
    fi

    # Tips
    if [ "$has_port_issues" = true ]; then
        echo -e "${YELLOW}Tip:${NC} Use ${GREEN}pwt fix-port <worktree>${NC} to resolve occupied ports"
    fi
    if [ "$has_merged" = true ]; then
        echo -e "${YELLOW}Tip:${NC} Use ${GREEN}pwt auto-remove${NC} to clean up merged worktrees"
    fi
    if [ "$has_port_issues" = false ] && [ "$has_merged" = false ]; then
        echo ""
    fi
}

# Command: repair
# Runs post-create hook on worktrees (project-specific repairs via Pwtfile)
cmd_repair() {
    local name="$1"

    if [ -n "$name" ]; then
        # Repair specific worktree
        local worktree_dir="$WORKTREES_DIR/$name"
        if [ ! -d "$worktree_dir" ]; then
            echo -e "${RED}Error: Worktree not found: $name${NC}"
            exit 1
        fi
        echo -e "${BLUE}Repairing: $name${NC}"
        export PWT_WORKTREE="$name"
        export PWT_WORKTREE_PATH="$worktree_dir"
        cd "$worktree_dir"
        run_pwtfile "repair"
        run_hook "repair"
    else
        # Repair all worktrees
        echo -e "${BLUE}Repairing all worktrees...${NC}\n"

        if [ -d "$WORKTREES_DIR" ] && [ "$(ls -A "$WORKTREES_DIR" 2>/dev/null)" ]; then
            for dir in "$WORKTREES_DIR"/*/; do
                [ -d "$dir" ] || continue
                local wt_name=$(basename "$dir")
                echo -e "  ${YELLOW}$wt_name${NC}"
                export PWT_WORKTREE="$wt_name"
                export PWT_WORKTREE_PATH="$dir"
                cd "$dir"
                run_pwtfile "repair"
                run_hook "repair"
            done
        fi

        echo ""
        echo -e "${GREEN}Done!${NC}"
    fi
}

# Command: auto-remove (cleanup merged worktrees)
# Usage: pwt auto-remove [target] [--dry-run]
cmd_auto_remove() {
    local target_branch=""
    local dry_run=false

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --dry-run|-n)
                dry_run=true
                shift
                ;;
            -*)
                echo -e "${RED}Unknown option: $1${NC}"
                exit 1
                ;;
            *)
                target_branch="$1"
                shift
                ;;
        esac
    done

    # If no branch specified, use current branch from main app
    if [ -z "$target_branch" ]; then
        cd "$MAIN_APP"
        target_branch=$(git branch --show-current 2>/dev/null)
        if [ -z "$target_branch" ]; then
            echo -e "${RED}Error: Could not detect current branch${NC}"
            echo "Usage: pwt auto-remove [target]"
            exit 1
        fi
        echo -e "${BLUE}Target branch (detected):${NC} $target_branch"
    fi

    echo -e "${BLUE}Checking worktrees merged into:${NC} $target_branch\n"

    # Fetch to ensure updated branches
    cd "$MAIN_APP"
    git fetch origin "$target_branch" --quiet 2>/dev/null || {
        echo -e "${RED}Error: Branch '$target_branch' not found on remote${NC}"
        exit 1
    }

    # Use origin/$target_branch for comparison (freshly fetched)
    local remote_target="origin/$target_branch"

    # List worktrees to remove
    local to_remove=()
    local pending=()

    if [ ! -d "$WORKTREES_DIR" ] || [ -z "$(ls -A "$WORKTREES_DIR" 2>/dev/null)" ]; then
        echo -e "${YELLOW}No worktrees found${NC}"
        exit 0
    fi

    for dir in "$WORKTREES_DIR"/*/; do
        [ -d "$dir" ] || continue

        local name=$(basename "$dir")

        # Get worktree HEAD commit
        local wt_commit=$(git -C "$dir" rev-parse HEAD 2>/dev/null)

        # Skip worktrees without valid commit (corrupted)
        if [ -z "$wt_commit" ]; then
            echo -e "  ${YELLOW}⚠️  CORRUPTED:${NC} $name (no commit)"
            to_remove+=("$name")
            continue
        fi

        local wt_branch=$(git -C "$dir" branch --show-current 2>/dev/null)
        local branch_display="${wt_branch:-detached}"

        # Check if worktree commit is contained in remote target branch (post-fetch)
        # Uses merge-base --is-ancestor which works even if remote branch was deleted
        if git merge-base --is-ancestor "$wt_commit" "$remote_target" 2>/dev/null; then
            echo -e "  ${GREEN}✅ MERGED:${NC} $name ($branch_display)"
            to_remove+=("$name")
        else
            echo -e "  ${YELLOW}⏳ PENDING:${NC} $name ($branch_display)"
            pending+=("$name")
        fi
    done

    echo ""

    # If nothing to remove, exit
    if [ ${#to_remove[@]} -eq 0 ]; then
        echo -e "${GREEN}No worktrees to remove${NC}"
        echo -e "Kept: ${#pending[@]}"
        exit 0
    fi

    # Dry-run mode: just show what would be removed
    if [ "$dry_run" = true ]; then
        echo -e "${YELLOW}[DRY-RUN] Would remove ${#to_remove[@]} worktree(s):${NC}"
        for name in "${to_remove[@]}"; do
            echo "  - $name"
        done
        echo ""
        echo -e "Would keep: ${#pending[@]}"
        exit 0
    fi

    # Remove merged worktrees
    echo -e "${BLUE}Removing ${#to_remove[@]} worktree(s)...${NC}\n"

    local removed=0
    for name in "${to_remove[@]}"; do
        echo -e "${YELLOW}Removing: $name${NC}"
        if cmd_remove "$name" 2>/dev/null; then
            removed=$((removed + 1))
        else
            # Try manual removal if cmd_remove fails (corrupted worktree)
            rm -rf "$WORKTREES_DIR/$name" 2>/dev/null && {
                echo -e "  ${GREEN}✓ Manually removed${NC}"
                removed=$((removed + 1))
            }
        fi
        echo ""
    done

    echo -e "${GREEN}Done!${NC}"
    echo -e "  Removed: $removed"
    echo -e "  Kept:    ${#pending[@]}"
}

# Command: remove
cmd_remove() {
    local name=""
    local with_branch=false
    local force_branch=false

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --with-branch)
                with_branch=true
                shift
                ;;
            --force-branch)
                with_branch=true
                force_branch=true
                shift
                ;;
            -*)
                echo -e "${RED}Unknown option: $1${NC}"
                exit 1
                ;;
            *)
                name="$1"
                shift
                ;;
        esac
    done

    # If no name, try to use current worktree
    if [ -z "$name" ]; then
        if [ -n "$PWT_WORKTREE" ]; then
            name="$PWT_WORKTREE"
        elif [[ "$PWD" == *"-worktrees/"* ]]; then
            name=$(basename "$PWD")
        else
            echo -e "${RED}Error: Not in a worktree. Specify target.${NC}"
            echo "Usage: pwt remove [worktree] [--with-branch] [--force-branch]"
            exit 1
        fi
        echo -e "${BLUE}Removing current worktree: $name${NC}"
    fi

    local worktree_dir="$WORKTREES_DIR/$name"

    if [ ! -d "$worktree_dir" ]; then
        echo -e "${RED}Error: Worktree not found: $name${NC}"
        exit 1
    fi

    # Get port from metadata, fallback to extracting from name
    local port=$(get_metadata "$name" "port")
    if [ -z "$port" ]; then
        # Legacy: extract from directory name if ends with -XXXX
        if [[ "$name" =~ -([0-9]{4})$ ]]; then
            port="${BASH_REMATCH[1]}"
        fi
    fi

    # Check if Rails server is running
    local pidfile="$worktree_dir/tmp/pids/server.pid"
    if [ -f "$pidfile" ]; then
        local pid=$(cat "$pidfile")
        if ps -p "$pid" > /dev/null 2>&1; then
            echo -e "${RED}Error: Rails server still running (PID $pid)${NC}"
            echo "Stop the server first or use: kill $pid"
            exit 1
        fi
    fi

    # Kill Sidekiq from worktree if running (avoid orphan jobs)
    local sidekiq_pids=$(pgrep -f "sidekiq.*$name" 2>/dev/null || true)
    if [ -n "$sidekiq_pids" ]; then
        echo -e "${YELLOW}Killing Sidekiq from worktree...${NC}"
        echo "$sidekiq_pids" | xargs kill 2>/dev/null || true
        sleep 1
        echo -e "  ${GREEN}✓ Sidekiq killed${NC}"
    fi

    # Kill foreman/processes from worktree by port
    if [ -n "$port" ] && [[ "$port" =~ ^[0-9]+$ ]]; then
        local port_pids=$(lsof -ti ":$port" 2>/dev/null || true)
        if [ -n "$port_pids" ]; then
            echo -e "${YELLOW}Freeing port $port...${NC}"
            echo "$port_pids" | xargs kill -9 2>/dev/null || true
            sleep 1
            echo -e "  ${GREEN}✓ Port $port freed${NC}"
        fi
    fi

    echo -e "${YELLOW}Removing worktree: $name${NC}"

    # Get metadata for hooks/Pwtfile
    local branch=$(get_metadata "$name" "branch")
    local base=$(get_metadata "$name" "base")
    local desc=$(get_metadata "$name" "description")
    # Set context for Pwtfile and hooks
    export PWT_WORKTREE="$name"
    export PWT_WORKTREE_PATH="$worktree_dir"
    export PWT_BRANCH="$branch"
    export PWT_PORT="$port"
    export PWT_TICKET="$name"  # User can customize via Pwtfile
    export PWT_BASE="$base"
    export PWT_DESC="$desc"
    export PWT_PROJECT="$CURRENT_PROJECT"
    export MAIN_APP="$MAIN_APP"

    # Run Pwtfile teardown (if exists), then hook
    # (Pwtfile handles project-specific cleanup like databases)
    run_pwtfile "teardown"
    run_hook "pre-remove"

    cd "$MAIN_APP"
    git worktree remove "$worktree_dir" --force

    # Remove metadata
    remove_metadata "$name"

    echo -e "${GREEN}✓ Worktree removed${NC}"

    # Delete branch if requested
    if [ "$with_branch" = true ] && [ -n "$branch" ]; then
        # Check if branch is merged (unless forcing)
        if [ "$force_branch" = false ]; then
            if ! git branch --merged master 2>/dev/null | grep -q "^\s*${branch}$" && \
               ! git branch --merged main 2>/dev/null | grep -q "^\s*${branch}$"; then
                echo -e "${YELLOW}Branch '$branch' is not merged. Use --force-branch to delete anyway.${NC}"
                return 0
            fi
        fi

        # Delete local branch
        if git branch -D "$branch" 2>/dev/null; then
            echo -e "${GREEN}✓ Local branch deleted: $branch${NC}"
        fi

        # Delete remote branch
        local remote_branch="${BRANCH_PREFIX}${branch#${BRANCH_PREFIX}}"
        if git push origin --delete "$branch" 2>/dev/null; then
            echo -e "${GREEN}✓ Remote branch deleted: origin/$branch${NC}"
        fi
    fi
}

# Command: server
# Start the server using Pwtfile's server() function
cmd_server() {
    local current_dir=$(pwd)

    # Must be inside a worktree
    if [[ "$current_dir" != "$WORKTREES_DIR"/* ]]; then
        echo -e "${RED}Error: Not inside a worktree${NC}"
        echo "Run this command from inside a worktree directory"
        exit 1
    fi

    local worktree_name=$(basename "$current_dir")
    local port=$(get_metadata "$worktree_name" "port")

    if [ -z "$port" ]; then
        echo -e "${YELLOW}Warning: Port not found in metadata${NC}"
        port="3000"
    fi

    # Set context for Pwtfile
    export PWT_WORKTREE="$worktree_name"
    export PWT_WORKTREE_PATH="$current_dir"
    export PWT_PORT="$port"
    export PWT_PROJECT="$CURRENT_PROJECT"
    export MAIN_APP="$MAIN_APP"

    echo -e "${BLUE}Starting server on port $port...${NC}"

    # Run Pwtfile server phase
    run_pwtfile "server"
}

# Command: info
cmd_info() {
    local name="$1"

    # If no name specified, try to detect from current directory
    if [ -z "$name" ]; then
        local current_dir=$(pwd)
        if [[ "$current_dir" == "$WORKTREES_DIR"/* ]]; then
            name=$(basename "$current_dir")
        else
            echo -e "${RED}Error: Worktree not specified${NC}"
            echo "Usage: pwt info <worktree>"
            echo "Or run from inside a worktree"
            exit 1
        fi
    fi

    local worktree_dir="$WORKTREES_DIR/$name"

    if [ ! -d "$worktree_dir" ]; then
        echo -e "${RED}Error: Worktree not found: $name${NC}"
        exit 1
    fi

    # Extract information
    local port=$(get_metadata "$name" "port")
    if [ -z "$port" ]; then
        # Legacy: extract from directory name if ends with -XXXX
        if [[ "$name" =~ -([0-9]{4})$ ]]; then
            port="${BASH_REMATCH[1]}"
        else
            port="-"
        fi
    fi
    local ticket="$name"
    local branch=$(git -C "$worktree_dir" branch --show-current 2>/dev/null || echo "detached")
    local upstream=$(git -C "$worktree_dir" rev-parse --abbrev-ref "${branch}@{upstream}" 2>/dev/null || echo "-")
    local commit=$(git -C "$worktree_dir" rev-parse --short HEAD 2>/dev/null || echo "-")
    local commit_msg=$(git -C "$worktree_dir" log -1 --format='%s' 2>/dev/null | head -c 50)

    # Server status
    local server_status
    local pidfile="$worktree_dir/tmp/pids/server.pid"
    if [ -f "$pidfile" ]; then
        local pid=$(cat "$pidfile")
        if ps -p "$pid" > /dev/null 2>&1; then
            server_status="${GREEN}running${NC} (PID $pid)"
        else
            server_status="${YELLOW}stopped${NC}"
        fi
    else
        server_status="${YELLOW}stopped${NC}"
    fi

    # Commits ahead/behind
    local ahead_behind=""
    if [ "$upstream" != "-" ]; then
        local ahead=$(git -C "$worktree_dir" rev-list --count "${upstream}..${branch}" 2>/dev/null || echo "0")
        local behind=$(git -C "$worktree_dir" rev-list --count "${branch}..${upstream}" 2>/dev/null || echo "0")
        if [ "$ahead" -gt 0 ] || [ "$behind" -gt 0 ]; then
            ahead_behind=" (↑${ahead} ↓${behind})"
        fi
    fi

    # Output
    echo ""
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${YELLOW}$name${NC}"
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
    echo -e "  ${BLUE}Ticket:${NC}    $ticket"
    echo -e "  ${BLUE}Branch:${NC}    $branch"
    echo -e "  ${BLUE}Based on:${NC}  $upstream$ahead_behind"
    echo -e "  ${BLUE}Commit:${NC}    $commit - $commit_msg"
    echo ""
    echo -e "  ${BLUE}Port:${NC}      $port"
    echo -e "  ${BLUE}Server:${NC}    $server_status"
    echo -e "  ${BLUE}Directory:${NC} $worktree_dir"
    echo ""

    # Show modified files if any
    local modified=$(git -C "$worktree_dir" status --porcelain 2>/dev/null | wc -l | tr -d ' ')
    if [ "$modified" -gt 0 ]; then
        echo -e "  ${YELLOW}Modified files:${NC} $modified"
        git -C "$worktree_dir" status --porcelain 2>/dev/null | head -5 | sed 's/^/    /'
        if [ "$modified" -gt 5 ]; then
            echo "    ... and $((modified - 5)) more"
        fi
        echo ""
    fi
}

# Command: fix-port
# Reallocate a worktree to a new free port
cmd_fix_port() {
    local name="$1"

    # If no name specified, try to detect from current directory
    if [ -z "$name" ]; then
        local current_dir=$(pwd)
        if [[ "$current_dir" == "$WORKTREES_DIR"/* ]]; then
            name=$(basename "$current_dir")
        else
            echo -e "${RED}Error: Worktree name not specified${NC}"
            echo "Usage: pwt fix-port <worktree>"
            echo "Or run from inside a worktree"
            exit 1
        fi
    fi

    local worktree_dir="$WORKTREES_DIR/$name"

    if [ ! -d "$worktree_dir" ]; then
        echo -e "${RED}Error: Worktree not found: $name${NC}"
        exit 1
    fi

    # Get current port from metadata, fallback to directory name
    local old_port=$(get_metadata "$name" "port")
    if [ -z "$old_port" ]; then
        # Legacy: extract from directory name if ends with -XXXX
        if [[ "$name" =~ -([0-9]{4})$ ]]; then
            old_port="${BASH_REMATCH[1]}"
        fi
    fi

    if [ -z "$old_port" ] || ! [[ "$old_port" =~ ^[0-9]+$ ]]; then
        echo -e "${RED}Error: Could not find port for worktree: $name${NC}"
        echo "Check metadata with: pwt meta show $name"
        exit 1
    fi

    # Check if current port is actually occupied
    if is_port_pair_free "$old_port"; then
        echo -e "${GREEN}Port $old_port is already free!${NC}"
        echo "No changes needed."
        exit 0
    fi

    # Analyze what's occupying the ports
    local rails_pid=$(lsof -ti ":$old_port" 2>/dev/null)
    local vite_pid=$(lsof -ti ":$((old_port + 1))" 2>/dev/null)
    local rails_proc="" vite_proc=""
    local can_kill_rails=false can_kill_vite=false

    if [ -n "$rails_pid" ]; then
        rails_proc=$(ps -p $rails_pid -o comm= 2>/dev/null || echo "?")
        # Rails-compatible processes: ruby*, puma*, unicorn*, bundle
        if [[ "$rails_proc" =~ ^(ruby|puma|unicorn|bundle) ]]; then
            can_kill_rails=true
        fi
    fi

    if [ -n "$vite_pid" ]; then
        vite_proc=$(ps -p $vite_pid -o comm= 2>/dev/null || echo "?")
        # Vite-compatible processes: node*
        if [[ "$vite_proc" =~ ^node ]]; then
            can_kill_vite=true
        fi
    fi

    echo -e "${YELLOW}Port $old_port is occupied:${NC}"
    if [ -n "$rails_pid" ]; then
        local kill_hint=""
        [ "$can_kill_rails" = true ] && kill_hint=" ${GREEN}(can kill)${NC}"
        echo -e "  Rails ($old_port): $rails_proc (PID $rails_pid)$kill_hint"
    fi
    if [ -n "$vite_pid" ]; then
        local kill_hint=""
        [ "$can_kill_vite" = true ] && kill_hint=" ${GREEN}(can kill)${NC}"
        echo -e "  Vite ($((old_port + 1))): $vite_proc (PID $vite_pid)$kill_hint"
    fi
    echo ""

    # If all occupying processes are compatible, offer to kill
    local all_killable=true
    [ -n "$rails_pid" ] && [ "$can_kill_rails" = false ] && all_killable=false
    [ -n "$vite_pid" ] && [ "$can_kill_vite" = false ] && all_killable=false

    if [ "$all_killable" = true ]; then
        echo -e "${BLUE}Options:${NC}"
        echo "  1) Kill orphan processes and keep port $old_port"
        echo "  2) Reallocate to new port"
        echo "  3) Cancel"
        echo ""
        read -p "Choose (1/2/3): " -n 1 -r choice
        echo ""

        case "$choice" in
            1)
                echo ""
                echo -e "${YELLOW}Killing processes...${NC}"
                [ -n "$rails_pid" ] && kill -9 "$rails_pid" 2>/dev/null && echo "  ✓ Rails (PID $rails_pid) killed"
                [ -n "$vite_pid" ] && kill -9 "$vite_pid" 2>/dev/null && echo "  ✓ Vite (PID $vite_pid) killed"
                sleep 1

                # Check if freed
                if is_port_pair_free "$old_port"; then
                    echo ""
                    echo -e "${GREEN}✓ Port $old_port freed!${NC}"
                    echo ""
                    echo "Now you can start the server:"
                    echo -e "  ${BLUE}pwt server${NC}"
                    exit 0
                else
                    echo -e "${RED}Port still occupied. Reallocating...${NC}"
                fi
                ;;
            2)
                echo ""
                echo "Reallocating to new port..."
                ;;
            *)
                echo "Cancelled."
                exit 0
                ;;
        esac
    else
        echo -e "${YELLOW}Incompatible processes occupying ports.${NC}"
        echo "Not safe to kill automatically."
        echo ""
        read -p "Reallocate to new port? (y/N) " -n 1 -r
        echo ""
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Cancelled."
            exit 0
        fi
    fi

    # Find new port
    local new_port=$(next_available_port)

    echo -e "${BLUE}Reallocating to port $new_port...${NC}"
    echo "  Port: $old_port → $new_port"
    echo ""

    # Check if server is running
    local pidfile="$worktree_dir/tmp/pids/server.pid"
    if [ -f "$pidfile" ]; then
        local pid=$(cat "$pidfile")
        if ps -p "$pid" > /dev/null 2>&1; then
            echo -e "${RED}Error: Rails server still running (PID $pid)${NC}"
            echo "Stop the server first."
            exit 1
        fi
    fi

    # 1. Update .env (generic patterns)
    if [ -f "$worktree_dir/.env" ]; then
        sed_inplace "s/localhost:$old_port/localhost:$new_port/g" "$worktree_dir/.env"
        sed_inplace "s/_wt$old_port/_wt$new_port/g" "$worktree_dir/.env"
        echo -e "  ${GREEN}✓${NC} .env updated"
    fi

    # 2. Update metadata
    update_metadata "$name" "port" "$new_port"
    echo -e "  ${GREEN}✓${NC} Metadata updated"

    # 3. Set context for hook
    export PWT_OLD_PORT="$old_port"
    export PWT_PORT="$new_port"
    export PWT_WORKTREE="$name"
    export PWT_WORKTREE_PATH="$worktree_dir"

    # 4. Run project hook (for database/config updates)
    run_hook "post-fix-port"

    echo ""
    echo -e "${GREEN}✓ Port reallocated successfully!${NC}"
    echo ""
    echo "To start server:"
    echo -e "  ${BLUE}pwt server${NC}  # Starts on port $new_port"
}

# Command: meta
# View or edit worktree metadata
cmd_meta() {
    local action="$1"
    local name="$2"
    local field="$3"
    local value="$4"

    init_metadata

    local project="${CURRENT_PROJECT:-unknown}"

    case "$action" in
        ""|list)
            # List all metadata for current project
            echo -e "${BLUE}Worktree Metadata ($project):${NC}"
            echo ""
            jq -r --arg project "$project" '.[$project] // {} | to_entries[] | "\(.key):\n  path: \(.value.path)\n  branch: \(.value.branch)\n  base: \(.value.base) @ \(.value.base_commit)\n  port: \(.value.port)\n  description: \(.value.description)\n  created: \(.value.created_at)\n"' "$METADATA_FILE"
            ;;
        show)
            if [ -z "$name" ]; then
                echo -e "${RED}Error: Worktree name required${NC}"
                echo "Usage: pwt meta show <worktree>"
                exit 1
            fi
            local meta=$(jq --arg project "$project" --arg name "$name" '.[$project][$name]' "$METADATA_FILE")
            if [ "$meta" = "null" ]; then
                echo -e "${YELLOW}No metadata found for: $name${NC}"
            else
                echo -e "${BLUE}Metadata for $name:${NC}"
                echo "$meta" | jq '.'
            fi
            ;;
        set)
            if [ -z "$name" ] || [ -z "$field" ] || [ -z "$value" ]; then
                echo -e "${RED}Error: Missing arguments${NC}"
                echo "Usage: pwt meta set <worktree> <field> <value>"
                echo ""
                echo "Fields: base, description, branch"
                exit 1
            fi
            update_metadata "$name" "$field" "$value"
            echo -e "${GREEN}✓ Updated $name.$field = $value${NC}"
            ;;
        import)
            # Import metadata for existing worktrees
            echo -e "${BLUE}Importing metadata for existing worktrees...${NC}"
            if [ -d "$WORKTREES_DIR" ] && [ "$(ls -A "$WORKTREES_DIR" 2>/dev/null)" ]; then
                for dir in "$WORKTREES_DIR"/*/; do
                    [ -d "$dir" ] || continue
                    local wt_name=$(basename "$dir")
                    local existing=$(get_metadata "$wt_name" "path")
                    if [ -z "$existing" ]; then
                        local wt_branch=$(git -C "$dir" branch --show-current 2>/dev/null || echo "?")
                        # Try to extract port from directory name (legacy format)
                        local wt_port=""
                        if [[ "$wt_name" =~ -([0-9]{4})$ ]]; then
                            wt_port="${BASH_REMATCH[1]}"
                        else
                            # Allocate new port for new format directories
                            wt_port=$(next_available_port)
                        fi
                        local wt_base_commit=$(git -C "$dir" merge-base HEAD "origin/${DEFAULT_BRANCH:-master}" 2>/dev/null)
                        local wt_base_short=$(git -C "$dir" rev-parse --short "$wt_base_commit" 2>/dev/null || echo "?")
                        local wt_desc=$(echo "$wt_branch" | sed -E 's|^[a-z]+/||' | tr '-' ' ')

                        save_metadata "$wt_name" "$dir" "$wt_branch" "${DEFAULT_BRANCH:-master}" "$wt_base_short" "$wt_port" "$wt_desc"
                        echo -e "  ${GREEN}✓${NC} Imported: $wt_name (port $wt_port)"
                    else
                        echo -e "  ${YELLOW}○${NC} Exists: $wt_name"
                    fi
                done
            fi
            echo -e "${GREEN}Done!${NC}"
            ;;
        *)
            echo -e "${RED}Unknown action: $action${NC}"
            echo "Usage: pwt meta [list|show|set|import]"
            echo ""
            echo "Commands:"
            echo "  list              - List all worktree metadata"
            echo "  show <name>       - Show metadata for a worktree"
            echo "  set <name> <field> <value> - Update a metadata field"
            echo "  import            - Import metadata for existing worktrees"
            exit 1
            ;;
    esac
}

# Command: cd (internal)
# Output path for worktree navigation
# Usage: pwt _cd [worktree|@]
#   @ or empty = main worktree
#   worktree = specific worktree
cmd_cd() {
    local target="${1:-@}"

    # @ or empty = main worktree
    if [ "$target" = "@" ] || [ -z "$target" ]; then
        echo "$MAIN_APP"
        return 0
    fi

    # Check if it's a worktree name
    local worktree_path="$WORKTREES_DIR/$target"
    if [ -d "$worktree_path" ]; then
        echo "$worktree_path"
        return 0
    fi

    # Try partial match
    local matches=()
    if [ -d "$WORKTREES_DIR" ]; then
        for dir in "$WORKTREES_DIR"/*/; do
            local name=$(basename "$dir")
            if [[ "$name" == *"$target"* ]]; then
                matches+=("$dir")
            fi
        done
    fi

    if [ ${#matches[@]} -eq 1 ]; then
        echo "${matches[0]%/}"
        return 0
    elif [ ${#matches[@]} -gt 1 ]; then
        echo "Multiple matches for '$target':" >&2
        for m in "${matches[@]}"; do
            echo "  $(basename "${m%/}")" >&2
        done
        return 1
    fi

    echo "Worktree not found: $target" >&2
    return 1
}

# Command: run
# Run a command in a worktree without changing directory
# Usage: pwt run <worktree> <command...>
#   @ = main worktree
cmd_run() {
    local target="$1"
    shift

    if [ -z "$target" ]; then
        echo -e "${RED}Usage: pwt run <worktree> <command...>${NC}"
        exit 1
    fi

    if [ $# -eq 0 ]; then
        echo -e "${RED}No command specified${NC}"
        exit 1
    fi

    local worktree_path

    if [ "$target" = "@" ]; then
        worktree_path="$MAIN_APP"
    else
        worktree_path="$WORKTREES_DIR/$target"
        # Try partial match if not found
        if [ ! -d "$worktree_path" ]; then
            local match=$(cmd_cd "$target" 2>/dev/null)
            if [ -n "$match" ] && [ -d "$match" ]; then
                worktree_path="$match"
            fi
        fi
    fi

    if [ ! -d "$worktree_path" ]; then
        echo -e "${RED}Worktree not found: $target${NC}"
        exit 1
    fi

    echo -e "${BLUE}Running in $worktree_path:${NC} $*"
    (cd "$worktree_path" && "$@")
}

# Command: editor
# Open worktree in configured editor
# Usage: pwt editor [worktree]
#   If no worktree specified, uses current directory or main app
cmd_editor() {
    local target="${1:-}"
    local worktree_path

    # Get editor from config or default to cursor
    local editor_cmd
    editor_cmd=$(get_project_config "$CURRENT_PROJECT" "editor" 2>/dev/null)
    [ -z "$editor_cmd" ] && editor_cmd="${EDITOR:-cursor}"

    if [ -z "$target" ] || [ "$target" = "@" ]; then
        worktree_path="$MAIN_APP"
    else
        worktree_path=$(cmd_cd "$target" 2>/dev/null)
        if [ -z "$worktree_path" ] || [ ! -d "$worktree_path" ]; then
            echo -e "${RED}Worktree not found: $target${NC}"
            exit 1
        fi
    fi

    echo -e "${BLUE}Opening in $editor_cmd:${NC} $worktree_path"
    "$editor_cmd" "$worktree_path"
}

# Command: ai
# Start AI coding tool in worktree
# Usage: pwt ai [worktree] [-- args...]
cmd_ai() {
    local target="${1:-}"
    local worktree_path
    local ai_args=()

    # Shift past target if provided and not --
    if [ -n "$target" ] && [ "$target" != "--" ]; then
        shift
    else
        target=""
    fi

    # Collect args after --
    if [ "$1" = "--" ]; then
        shift
        ai_args=("$@")
    fi

    # Get AI tool from config or default to claude
    local ai_cmd
    ai_cmd=$(get_project_config "$CURRENT_PROJECT" "ai" 2>/dev/null)
    [ -z "$ai_cmd" ] && ai_cmd="claude"

    if [ -z "$target" ] || [ "$target" = "@" ]; then
        worktree_path="$MAIN_APP"
    else
        worktree_path=$(cmd_cd "$target" 2>/dev/null)
        if [ -z "$worktree_path" ] || [ ! -d "$worktree_path" ]; then
            echo -e "${RED}Worktree not found: $target${NC}"
            exit 1
        fi
    fi

    echo -e "${BLUE}Starting $ai_cmd in:${NC} $worktree_path"
    (cd "$worktree_path" && "$ai_cmd" "${ai_args[@]}")
}

# Command: open
# Open worktree in Finder/file manager
# Usage: pwt open [worktree]
cmd_open() {
    local target="${1:-}"
    local worktree_path

    if [ -z "$target" ] || [ "$target" = "@" ]; then
        worktree_path="$MAIN_APP"
    else
        worktree_path=$(cmd_cd "$target" 2>/dev/null)
        if [ -z "$worktree_path" ] || [ ! -d "$worktree_path" ]; then
            echo -e "${RED}Worktree not found: $target${NC}"
            exit 1
        fi
    fi

    echo -e "${BLUE}Opening in Finder:${NC} $worktree_path"
    open "$worktree_path"
}

# Command: diff
# Show diff between worktrees or worktree vs main
# Usage: pwt diff <worktree1> [worktree2]
cmd_diff() {
    local wt1="$1"
    local wt2="${2:-@}"

    if [ -z "$wt1" ]; then
        echo -e "${RED}Usage: pwt diff <worktree1> [worktree2]${NC}"
        echo "  worktree2 defaults to @ (main app)"
        exit 1
    fi

    local path1 path2

    # Resolve worktree1
    if [ "$wt1" = "@" ]; then
        path1="$MAIN_APP"
    else
        path1=$(cmd_cd "$wt1" 2>/dev/null)
        if [ -z "$path1" ] || [ ! -d "$path1" ]; then
            echo -e "${RED}Worktree not found: $wt1${NC}"
            exit 1
        fi
    fi

    # Resolve worktree2
    if [ "$wt2" = "@" ]; then
        path2="$MAIN_APP"
    else
        path2=$(cmd_cd "$wt2" 2>/dev/null)
        if [ -z "$path2" ] || [ ! -d "$path2" ]; then
            echo -e "${RED}Worktree not found: $wt2${NC}"
            exit 1
        fi
    fi

    echo -e "${BLUE}Comparing:${NC}"
    echo "  $wt1: $path1"
    echo "  $wt2: $path2"
    echo ""

    # Get branch and commit info
    local branch1=$(git -C "$path1" branch --show-current 2>/dev/null || echo "detached")
    local branch2=$(git -C "$path2" branch --show-current 2>/dev/null || echo "detached")
    local commit1=$(git -C "$path1" rev-parse HEAD 2>/dev/null)
    local commit2=$(git -C "$path2" rev-parse HEAD 2>/dev/null)

    if [ -z "$commit1" ] || [ -z "$commit2" ]; then
        echo -e "${RED}Error: Could not get commit hashes${NC}"
        exit 1
    fi

    echo -e "${BLUE}Branches:${NC} $branch1 vs $branch2"
    echo -e "${BLUE}Commits:${NC} ${commit1:0:8} vs ${commit2:0:8}"
    echo ""

    # Show git diff using commit hashes (works across worktrees via main repo)
    git -C "$MAIN_APP" diff "$commit2".."$commit1" --stat
}

# Command: conflicts
# Show file overlap between worktrees (files modified in multiple worktrees)
# Usage: pwt conflicts [worktree1] [worktree2]
#   No args: show all overlaps
#   Two args: compare specific pair
cmd_conflicts() {
    require_project --info-only

    local wt1="$1"
    local wt2="$2"

    if [ -n "$wt1" ] && [ -n "$wt2" ]; then
        # Compare specific pair
        compare_worktree_conflicts "$wt1" "$wt2"
    else
        # Compare all worktrees
        show_all_conflicts
    fi
}

# Helper: get modified files for a worktree (vs default branch)
get_modified_files() {
    local dir="$1"
    git -C "$dir" diff --name-only "origin/${DEFAULT_BRANCH:-master}" 2>/dev/null || true
}

# Helper: compare two worktrees for conflicts
compare_worktree_conflicts() {
    local wt1="$1"
    local wt2="$2"

    local path1 path2

    # Resolve paths
    if [ "$wt1" = "@" ]; then
        path1="$MAIN_APP"
    else
        path1="$WORKTREES_DIR/$wt1"
    fi

    if [ "$wt2" = "@" ]; then
        path2="$MAIN_APP"
    else
        path2="$WORKTREES_DIR/$wt2"
    fi

    if [ ! -d "$path1" ]; then
        echo -e "${RED}Worktree not found: $wt1${NC}"
        exit 1
    fi
    if [ ! -d "$path2" ]; then
        echo -e "${RED}Worktree not found: $wt2${NC}"
        exit 1
    fi

    echo -e "${BLUE}Comparing:${NC} $wt1 vs $wt2"
    echo ""

    local files1=$(get_modified_files "$path1")
    local files2=$(get_modified_files "$path2")

    local conflicts=$(comm -12 <(echo "$files1" | sort) <(echo "$files2" | sort))

    if [ -z "$conflicts" ]; then
        echo -e "${GREEN}No file conflicts found${NC}"
    else
        local count=$(echo "$conflicts" | wc -l | tr -d ' ')
        echo -e "${YELLOW}⚠️  $count file(s) modified in both worktrees:${NC}"
        echo "$conflicts" | while read -r file; do
            echo "  $file"
        done
    fi
}

# Helper: show all conflicts across all worktrees
show_all_conflicts() {
    if [ ! -d "$WORKTREES_DIR" ]; then
        echo -e "${YELLOW}No worktrees found${NC}"
        return 0
    fi

    local tmpfile=$(mktemp)
    trap "rm -f '$tmpfile'" EXIT

    # Collect all modified files with their worktree names
    for dir in "$WORKTREES_DIR"/*/; do
        [ -d "$dir" ] || continue
        local name=$(basename "$dir")
        get_modified_files "$dir" | while read -r file; do
            [ -n "$file" ] && echo "$name:$file" >> "$tmpfile"
        done
    done

    if [ ! -s "$tmpfile" ]; then
        echo -e "${GREEN}No modified files in any worktree${NC}"
        return 0
    fi

    # Find files that appear in multiple worktrees
    local duplicates=$(cut -d: -f2 "$tmpfile" | sort | uniq -d)

    if [ -z "$duplicates" ]; then
        echo -e "${GREEN}No file conflicts found${NC}"
        echo ""
        echo -e "${BLUE}Summary:${NC}"
        echo "  Worktrees with changes: $(cut -d: -f1 "$tmpfile" | sort -u | wc -l | tr -d ' ')"
        echo "  Total files modified: $(cut -d: -f2 "$tmpfile" | sort -u | wc -l | tr -d ' ')"
    else
        local count=$(echo "$duplicates" | wc -l | tr -d ' ')
        echo -e "${YELLOW}⚠️  $count file(s) modified in multiple worktrees:${NC}"
        echo ""
        echo "$duplicates" | while read -r file; do
            echo -e "${YELLOW}$file${NC}"
            grep ":$file$" "$tmpfile" | cut -d: -f1 | sed 's/^/  /'
        done
    fi
}

# Command: context
# Generate markdown context for AI agents about worktrees
# Usage: pwt context [worktree]
#   No args: context for all worktrees
#   worktree: context focused on specific worktree
cmd_context() {
    require_project --info-only

    local focus_wt="$1"

    echo "# Worktree Context: ${CURRENT_PROJECT}"
    echo ""
    echo "Generated: $(date '+%Y-%m-%d %H:%M')"
    echo ""

    # Project info
    echo "## Project"
    echo ""
    echo "| Key | Value |"
    echo "|-----|-------|"
    echo "| Project | ${CURRENT_PROJECT} |"
    echo "| Main App | ${MAIN_APP} |"
    echo "| Worktrees Dir | ${WORKTREES_DIR} |"
    [ -n "$PROJECT_REMOTE" ] && echo "| Remote | ${PROJECT_REMOTE} |"
    echo ""

    # Active worktrees
    echo "## Active Worktrees"
    echo ""
    echo "| Worktree | Branch | Base | Status | Ahead/Behind |"
    echo "|----------|--------|------|--------|--------------|"

    # Main app
    local main_branch=$(git -C "$MAIN_APP" branch --show-current 2>/dev/null || echo "?")
    local main_hash=$(get_short_hash "$MAIN_APP")
    local main_status=$(get_status_symbols "$MAIN_APP")
    echo "| @ (main) | ${main_branch} | - | ${main_status:-clean} | - |"

    # Worktrees
    if [ -d "$WORKTREES_DIR" ]; then
        for dir in "$WORKTREES_DIR"/*/; do
            [ -d "$dir" ] || continue
            local name=$(basename "$dir")
            local branch=$(git -C "$dir" branch --show-current 2>/dev/null || echo "?")
            local base=$(get_base_branch "$name" "$dir")
            local status=$(get_status_symbols "$dir")
            local divergence=$(get_divergence "$dir" "origin/${DEFAULT_BRANCH:-master}")

            # Get description from metadata
            local desc=$(get_metadata "$name" "description")

            echo "| ${name} | ${branch} | ${base} | ${status:-clean} | ${divergence:-synced} |"
        done
    fi
    echo ""

    # Worktree descriptions
    echo "## Worktree Details"
    echo ""
    if [ -d "$WORKTREES_DIR" ]; then
        for dir in "$WORKTREES_DIR"/*/; do
            [ -d "$dir" ] || continue
            local name=$(basename "$dir")

            # If focus_wt is set, only show that worktree
            if [ -n "$focus_wt" ] && [ "$name" != "$focus_wt" ]; then
                continue
            fi

            local desc=$(get_metadata "$name" "description")
            local branch=$(git -C "$dir" branch --show-current 2>/dev/null || echo "?")
            local base=$(get_base_branch "$name" "$dir")

            echo "### ${name}"
            echo ""
            [ -n "$desc" ] && echo "**Purpose:** ${desc}"
            echo ""
            echo "- **Branch:** ${branch}"
            echo "- **Base:** ${base}"
            echo "- **Path:** ${dir}"
            echo ""

            # Recent commits (last 5)
            echo "**Recent commits:**"
            echo ""
            echo '```'
            git -C "$dir" log --oneline -5 2>/dev/null || echo "No commits"
            echo '```'
            echo ""

            # Modified files (summary)
            local modified=$(git -C "$dir" diff --name-only "origin/${DEFAULT_BRANCH:-master}" 2>/dev/null | wc -l | tr -d ' ')
            if [ "$modified" -gt 0 ]; then
                echo "**Modified files:** ${modified} file(s) changed from ${base}"
                echo ""
                if [ "$modified" -le 20 ]; then
                    echo '```'
                    git -C "$dir" diff --name-only "origin/${DEFAULT_BRANCH:-master}" 2>/dev/null
                    echo '```'
                else
                    echo '```'
                    git -C "$dir" diff --name-only "origin/${DEFAULT_BRANCH:-master}" 2>/dev/null | head -15
                    echo "... and $((modified - 15)) more files"
                    echo '```'
                fi
                echo ""
            fi
        done
    fi

    # Conflicts section
    if [ -z "$focus_wt" ]; then
        echo "## Potential Conflicts"
        echo ""
        echo "Files modified in multiple worktrees:"
        echo ""

        local tmpfile=$(mktemp)
        trap "rm -f '$tmpfile'" EXIT

        # Collect all modified files
        for dir in "$WORKTREES_DIR"/*/; do
            [ -d "$dir" ] || continue
            local name=$(basename "$dir")
            get_modified_files "$dir" | while read -r file; do
                [ -n "$file" ] && echo "$name:$file" >> "$tmpfile"
            done
        done

        if [ -s "$tmpfile" ]; then
            local duplicates=$(cut -d: -f2 "$tmpfile" | sort | uniq -d)
            if [ -n "$duplicates" ]; then
                local count=$(echo "$duplicates" | wc -l | tr -d ' ')
                echo "⚠️ **${count} file(s)** have potential merge conflicts:"
                echo ""
                echo '```'
                echo "$duplicates" | head -20
                [ $(echo "$duplicates" | wc -l) -gt 20 ] && echo "... and more"
                echo '```'
            else
                echo "✅ No conflicting files detected."
            fi
        else
            echo "No modified files in worktrees."
        fi
        echo ""
    fi

    # Instructions for AI
    echo "## Instructions for AI Agents"
    echo ""
    echo "When working in a worktree:"
    echo ""
    echo "1. **Stay focused** on the worktree's purpose (see description above)"
    echo "2. **Avoid modifying** files that are being changed in other worktrees (see conflicts)"
    echo "3. **Coordinate** if you need to touch a conflicting file"
    echo "4. **Base branch** - always create PRs against the base branch shown"
    echo "5. **Status symbols:** + = staged, ! = modified, ? = untracked"
    echo ""
}

# Command: copy
# Copy files between worktrees
# Usage: pwt copy <src> <dest> <patterns...>
#   src/dest can be @ for main app
cmd_copy() {
    local src="$1"
    local dest="$2"
    shift 2

    if [ -z "$src" ] || [ -z "$dest" ] || [ $# -eq 0 ]; then
        echo -e "${RED}Usage: pwt copy <src> <dest> <patterns...>${NC}"
        echo "  src/dest can be @ for main app"
        echo ""
        echo "Examples:"
        echo "  pwt copy @ TICKET-123 \".env*\"          # main → worktree"
        echo "  pwt copy TICKET-123 @ \".env*\"          # worktree → main"
        echo "  pwt copy TICKET-123 TICKET-456 \"*.json\" # between worktrees"
        exit 1
    fi

    local src_path dest_path

    # Resolve source
    if [ "$src" = "@" ]; then
        src_path="$MAIN_APP"
    else
        src_path=$(cmd_cd "$src" 2>/dev/null)
        if [ -z "$src_path" ] || [ ! -d "$src_path" ]; then
            echo -e "${RED}Worktree not found: $src${NC}"
            exit 1
        fi
    fi

    # Resolve destination
    if [ "$dest" = "@" ]; then
        dest_path="$MAIN_APP"
    else
        dest_path=$(cmd_cd "$dest" 2>/dev/null)
        if [ -z "$dest_path" ] || [ ! -d "$dest_path" ]; then
            echo -e "${RED}Worktree not found: $dest${NC}"
            exit 1
        fi
    fi

    echo -e "${BLUE}Copying from $src to $dest:${NC}"

    local count=0
    for pattern in "$@"; do
        # Use find to match patterns
        while IFS= read -r -d '' file; do
            local rel_path="${file#$src_path/}"
            local dest_file="$dest_path/$rel_path"

            # Create parent directory if needed
            mkdir -p "$(dirname "$dest_file")"

            cp "$file" "$dest_file"
            echo "  ✓ $rel_path"
            count=$((count + 1))
        done < <(find "$src_path" -path "*/$pattern" -type f -print0 2>/dev/null || find "$src_path" -name "$pattern" -type f -print0 2>/dev/null)
    done

    if [ $count -eq 0 ]; then
        echo "  No files matched"
    else
        echo -e "${GREEN}Copied $count file(s)${NC}"
    fi
}

# Command: doctor
# Check system health and configuration
# Usage: pwt doctor
cmd_doctor() {
    echo -e "${BLUE}pwt doctor${NC}"
    echo ""

    local errors=0

    # Check git
    if command -v git &>/dev/null; then
        local git_version=$(git --version | cut -d' ' -f3)
        echo -e "${GREEN}✓${NC} Git: $git_version"
    else
        echo -e "${RED}✗${NC} Git: not installed"
        errors=$((errors + 1))
    fi

    # Check jq
    if command -v jq &>/dev/null; then
        local jq_version=$(jq --version 2>/dev/null || echo "?")
        echo -e "${GREEN}✓${NC} jq: $jq_version"
    else
        echo -e "${RED}✗${NC} jq: not installed (required)"
        errors=$((errors + 1))
    fi

    # Check lsof
    if command -v lsof &>/dev/null; then
        echo -e "${GREEN}✓${NC} lsof: installed"
    else
        echo -e "${YELLOW}⚠${NC} lsof: not installed (recommended for port detection)"
    fi

    # Check fzf
    if command -v fzf &>/dev/null; then
        local fzf_version=$(fzf --version 2>/dev/null | head -1 || echo "?")
        echo -e "${GREEN}✓${NC} fzf: $fzf_version"
    else
        echo -e "${YELLOW}⚠${NC} fzf: not installed (needed for pwt select)"
    fi

    echo ""

    # Check project configuration
    if [ -n "$CURRENT_PROJECT" ]; then
        echo -e "${GREEN}✓${NC} Project: $CURRENT_PROJECT"

        if [ -n "$MAIN_APP" ] && [ -d "$MAIN_APP" ]; then
            echo -e "${GREEN}✓${NC} Main app: $MAIN_APP"
        else
            echo -e "${RED}✗${NC} Main app: not found"
            errors=$((errors + 1))
        fi

        if [ -n "$WORKTREES_DIR" ]; then
            if [ -d "$WORKTREES_DIR" ]; then
                local wt_count=$(ls -d "$WORKTREES_DIR"/*/ 2>/dev/null | wc -l | tr -d ' ')
                echo -e "${GREEN}✓${NC} Worktrees dir: $WORKTREES_DIR ($wt_count worktrees)"
            else
                echo -e "${YELLOW}⚠${NC} Worktrees dir: $WORKTREES_DIR (not created yet)"
            fi
        fi

        # Check Pwtfile
        if [ -n "$PWTFILE" ] && [ -f "$PWTFILE" ]; then
            echo -e "${GREEN}✓${NC} Pwtfile: $PWTFILE"
        elif [ -f "$MAIN_APP/Pwtfile" ]; then
            echo -e "${GREEN}✓${NC} Pwtfile: $MAIN_APP/Pwtfile"
        else
            echo -e "${YELLOW}⚠${NC} Pwtfile: not found (optional)"
        fi

        # Check editor config
        local editor_cfg=$(get_project_config "$CURRENT_PROJECT" "editor" 2>/dev/null)
        if [ -n "$editor_cfg" ]; then
            if command -v "$editor_cfg" &>/dev/null; then
                echo -e "${GREEN}✓${NC} Editor: $editor_cfg"
            else
                echo -e "${YELLOW}⚠${NC} Editor: $editor_cfg (not found in PATH)"
            fi
        fi

        # Check AI config
        local ai_cfg=$(get_project_config "$CURRENT_PROJECT" "ai" 2>/dev/null)
        if [ -n "$ai_cfg" ]; then
            if command -v "$ai_cfg" &>/dev/null; then
                echo -e "${GREEN}✓${NC} AI: $ai_cfg"
            else
                echo -e "${YELLOW}⚠${NC} AI: $ai_cfg (not found in PATH)"
            fi
        fi
    else
        echo -e "${YELLOW}⚠${NC} Project: not detected (run from project directory)"
    fi

    echo ""
    if [ $errors -gt 0 ]; then
        echo -e "${RED}$errors error(s) found${NC}"
        exit 1
    else
        echo -e "${GREEN}All checks passed!${NC}"
    fi
}

# Command: select
# Interactive worktree selector using fzf
# Usage: pwt select [--preview]
cmd_select() {
    local preview=false

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --preview|-p)
                preview=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    # Check if fzf is installed
    if ! command -v fzf &>/dev/null; then
        echo -e "${RED}Error: fzf is required for pwt select${NC}"
        echo "Install with: brew install fzf"
        exit 1
    fi

    # Build list of worktrees
    local items=()

    # Add main app
    if [ -d "$MAIN_APP" ]; then
        local main_branch=$(git -C "$MAIN_APP" branch --show-current 2>/dev/null || echo "main")
        items+=("@ (main) - $main_branch")
    fi

    # Add worktrees
    if [ -d "$WORKTREES_DIR" ] && [ "$(ls -A "$WORKTREES_DIR" 2>/dev/null)" ]; then
        for dir in "$WORKTREES_DIR"/*/; do
            [ -d "$dir" ] || continue
            local name=$(basename "$dir")
            local branch=$(git -C "$dir" branch --show-current 2>/dev/null || echo "?")
            local status=$(get_status_symbols "$dir")
            [ -n "$status" ] && status=" [$status]"
            items+=("$name - $branch$status")
        done
    fi

    if [ ${#items[@]} -eq 0 ]; then
        echo -e "${YELLOW}No worktrees found${NC}"
        exit 0
    fi

    # Run fzf
    local fzf_opts=(
        --height=40%
        --reverse
        --header="Select worktree (Enter to switch, Esc to cancel)"
    )

    if [ "$preview" = true ]; then
        fzf_opts+=(
            --preview="name=\$(echo {} | cut -d' ' -f1); if [ \"\$name\" = \"@\" ]; then git -C \"$MAIN_APP\" diff --stat 2>/dev/null | head -20; else git -C \"$WORKTREES_DIR/\$name\" diff --stat 2>/dev/null | head -20; fi"
            --preview-window=right:50%
        )
    fi

    local selected
    selected=$(printf '%s\n' "${items[@]}" | fzf "${fzf_opts[@]}")

    if [ -z "$selected" ]; then
        exit 0
    fi

    # Extract worktree name (first word before " - ")
    local target=$(echo "$selected" | cut -d' ' -f1)

    # Output for shell function to cd
    if [ "$target" = "@" ]; then
        echo "$MAIN_APP"
    else
        echo "$WORKTREES_DIR/$target"
    fi
}

# Internal command: _select
# Used by shell function to get selection and cd
cmd__select() {
    local result
    result=$(cmd_select "$@")
    echo "$result"
}

# Command: marker
# Set/get/clear marker on worktree
# Usage: pwt marker [worktree] [marker]
#        pwt marker TICKET-123 🚧      # set marker
#        pwt marker TICKET-123         # show marker
#        pwt marker --clear            # clear current worktree marker
#        pwt marker TICKET-123 --clear # clear specific marker
cmd_marker() {
    local target=""
    local marker=""
    local clear=false

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --clear|-c)
                clear=true
                shift
                ;;
            -*)
                echo -e "${RED}Unknown option: $1${NC}"
                exit 1
                ;;
            *)
                if [ -z "$target" ]; then
                    target="$1"
                else
                    marker="$1"
                fi
                shift
                ;;
        esac
    done

    # If no target, use current worktree
    if [ -z "$target" ]; then
        if [ -n "$PWT_WORKTREE" ]; then
            target="$PWT_WORKTREE"
        else
            # Try to detect from PWD
            if [[ "$PWD" == *"-worktrees/"* ]]; then
                target=$(basename "$PWD")
            else
                echo -e "${RED}Error: Not in a worktree. Specify target.${NC}"
                exit 1
            fi
        fi
    fi

    # Verify worktree exists
    local worktree_dir="$WORKTREES_DIR/$target"
    if [ ! -d "$worktree_dir" ]; then
        echo -e "${RED}Error: Worktree not found: $target${NC}"
        exit 1
    fi

    # Clear marker
    if [ "$clear" = true ]; then
        update_metadata "$target" "marker" ""
        echo -e "${GREEN}✓${NC} Cleared marker for $target"
        return 0
    fi

    # Show current marker
    if [ -z "$marker" ]; then
        local current=$(get_metadata "$target" "marker")
        if [ -n "$current" ]; then
            echo "$current"
        else
            echo "(no marker)"
        fi
        return 0
    fi

    # Set marker
    update_metadata "$target" "marker" "$marker"
    echo -e "${GREEN}✓${NC} Set marker for $target: $marker"
}

# Command: for-each
# Run command in all worktrees
# Usage: pwt for-each <command...>
cmd_for_each() {
    if [ $# -eq 0 ]; then
        echo -e "${RED}Error: No command specified${NC}"
        echo "Usage: pwt for-each <command...>"
        exit 1
    fi

    local cmd="$*"
    local count=0

    # Run in main app
    echo -e "${BLUE}=== @ (main) ===${NC}"
    (
        cd "$MAIN_APP" || exit 1
        unset PWT_WORKTREE
        eval "$cmd"
    )
    echo ""

    # Run in worktrees
    if [ -d "$WORKTREES_DIR" ] && [ "$(ls -A "$WORKTREES_DIR" 2>/dev/null)" ]; then
        for dir in "$WORKTREES_DIR"/*/; do
            [ -d "$dir" ] || continue
            local name=$(basename "$dir")
            count=$((count + 1))

            echo -e "${BLUE}=== $name ===${NC}"
            (
                cd "$dir" || exit 1
                export PWT_WORKTREE="$name"
                export PWT_WORKTREE_PATH="$dir"
                eval "$cmd"
            )
            echo ""
        done
    fi

    echo -e "${GREEN}✓ Ran in $((count + 1)) worktrees${NC}"
}

# Command: shell-init
# Output shell function for cd integration
# Usage: eval "$(pwt shell-init)"
cmd_shell_init() {
    local pwt_path
    pwt_path=$(which pwt 2>/dev/null || echo "$0")

    cat << EOF
# pwt shell integration
# Add to ~/.zshrc: eval "\$(pwt shell-init)"
pwt() {
    if [[ "\$1" == "cd" ]]; then
        local input="\$2"
        local target

        # Handle "-" for previous worktree (like cd -)
        if [[ "\$input" == "-" ]]; then
            if [[ -z "\$PWT_PREVIOUS_PATH" ]]; then
                echo "No previous worktree" >&2
                return 1
            fi
            target="\$PWT_PREVIOUS_PATH"
        else
            target=\$("$pwt_path" _cd "\$input" 2>&1)
            if [[ \$? -ne 0 ]] || [[ ! -d "\$target" ]]; then
                echo "\$target"
                return 1
            fi
        fi

        # Save current path as previous (if different)
        if [[ "\$PWD" != "\$target" ]]; then
            export PWT_PREVIOUS_PATH="\$PWD"
        fi

        builtin cd "\$target"

        # Set PWT_WORKTREE for prompts and scripts
        if [[ "\$target" == *"-worktrees/"* ]]; then
            export PWT_WORKTREE=\$(basename "\$target")
        else
            unset PWT_WORKTREE
        fi
    elif [[ "\$1" == "select" ]]; then
        # Interactive selection with cd
        shift
        local target
        target=\$("$pwt_path" _select "\$@" 2>&1)
        if [[ \$? -ne 0 ]] || [[ -z "\$target" ]]; then
            [[ -n "\$target" ]] && echo "\$target"
            return 0
        fi
        if [[ ! -d "\$target" ]]; then
            echo "\$target"
            return 1
        fi

        # Save current path as previous (if different)
        if [[ "\$PWD" != "\$target" ]]; then
            export PWT_PREVIOUS_PATH="\$PWD"
        fi

        builtin cd "\$target"

        # Set PWT_WORKTREE for prompts and scripts
        if [[ "\$target" == *"-worktrees/"* ]]; then
            export PWT_WORKTREE=\$(basename "\$target")
        else
            unset PWT_WORKTREE
        fi
    else
        "$pwt_path" "\$@"
    fi
}
EOF
}

# Command: config
# Configure current project (zero-config override)
cmd_config() {
    local key="$1"
    local value="$2"

    # Ensure project is detected
    if [ -z "$CURRENT_PROJECT" ]; then
        echo -e "${RED}Error: No project detected${NC}"
        echo "Run from inside a git repository."
        exit 1
    fi

    local config_dir="$PWT_PROJECTS_DIR/$CURRENT_PROJECT"
    local config_file="$config_dir/config.json"

    # Create config dir if needed
    mkdir -p "$config_dir/hooks"

    # Initialize config file if needed
    if [ ! -f "$config_file" ]; then
        echo "{}" > "$config_file"
    fi

    case "$key" in
        ""|show)
            # Show current config
            echo -e "${BLUE}Project: $CURRENT_PROJECT${NC}"
            echo ""
            echo "Current settings:"
            echo "  main_app:      ${MAIN_APP:-"(auto-detected)"}"
            echo "  worktrees_dir: ${WORKTREES_DIR:-"(auto-detected)"}"
            echo "  branch_prefix: ${BRANCH_PREFIX:-"(none)"}"
            echo "  base_port:     ${BASE_PORT:-5000}"
            echo ""
            if [ -f "$config_file" ] && [ "$(cat "$config_file")" != "{}" ]; then
                echo "Saved overrides ($config_file):"
                jq '.' "$config_file"
            else
                echo "No saved overrides (using auto-detected values)."
            fi
            ;;
        main_app|worktrees_dir|branch_prefix|base_port)
            if [ -z "$value" ]; then
                # Show current value
                local current=$(jq -r ".$key // empty" "$config_file" 2>/dev/null)
                echo "${current:-"(not set)"}"
            else
                # Set value
                local tmp_file=$(mktemp)
                jq --arg key "$key" --arg value "$value" '.[$key] = $value' "$config_file" > "$tmp_file" && mv "$tmp_file" "$config_file"
                echo -e "${GREEN}✓ Set $key = $value${NC}"
            fi
            ;;
        *)
            echo -e "${RED}Unknown config key: $key${NC}"
            echo ""
            echo "Available keys:"
            echo "  main_app       - Path to main project"
            echo "  worktrees_dir  - Path to worktrees directory"
            echo "  branch_prefix  - Prefix for branches (e.g., jp/)"
            echo "  base_port      - Base port for allocation"
            exit 1
            ;;
    esac
}

# Command: project
# Manage project configurations
cmd_project() {
    local action="$1"
    local project="$2"
    local arg3="$3"
    local arg4="$4"

    init_metadata

    case "$action" in
        ""|list)
            # List all projects
            echo -e "${BLUE}Configured Projects:${NC}"
            echo ""
            if [ -d "$PROJECTS_DIR" ] && [ "$(ls -A "$PROJECTS_DIR" 2>/dev/null)" ]; then
                for dir in "$PROJECTS_DIR"/*/; do
                    [ -d "$dir" ] || continue
                    local proj_name=$(basename "$dir")
                    local config_file="$dir/config.json"
                    if [ -f "$config_file" ]; then
                        local main_app=$(jq -r '.main_app // "(not set)"' "$config_file")
                        local prefix=$(jq -r '.branch_prefix // "(not set)"' "$config_file")
                        echo -e "  ${GREEN}$proj_name${NC}"
                        echo "    main_app: $main_app"
                        echo "    branch_prefix: $prefix"
                        # Count hooks
                        local hook_count=$(ls "$dir/hooks" 2>/dev/null | wc -l | tr -d ' ')
                        if [ "$hook_count" -gt 0 ]; then
                            echo "    hooks: $hook_count"
                        fi
                        echo ""
                    fi
                done
            else
                echo "  No projects configured yet."
                echo ""
                echo "  Use: pwt project init <name>"
            fi
            ;;
        init)
            if [ -z "$project" ]; then
                echo -e "${RED}Error: Project name required${NC}"
                echo "Usage: pwt project init <name>"
                exit 1
            fi
            init_project "$project"
            echo ""
            echo "Edit the config at: $PROJECTS_DIR/$project/config.json"
            echo "Add hooks in: $PROJECTS_DIR/$project/hooks/"
            ;;
        show)
            if [ -z "$project" ]; then
                echo -e "${RED}Error: Project name required${NC}"
                echo "Usage: pwt project show <name>"
                exit 1
            fi
            local config_file="$PROJECTS_DIR/$project/config.json"
            if [ ! -f "$config_file" ]; then
                echo -e "${RED}Project not found: $project${NC}"
                exit 1
            fi
            echo -e "${BLUE}Project: $project${NC}"
            echo ""
            echo "Config:"
            jq '.' "$config_file"
            echo ""
            echo "Hooks:"
            ls -la "$PROJECTS_DIR/$project/hooks/" 2>/dev/null || echo "  (none)"
            ;;
        set)
            if [ -z "$project" ] || [ -z "$arg3" ] || [ -z "$arg4" ]; then
                echo -e "${RED}Error: Missing arguments${NC}"
                echo "Usage: pwt project set <name> <key> <value>"
                exit 1
            fi
            local config_file="$PROJECTS_DIR/$project/config.json"
            if [ ! -f "$config_file" ]; then
                echo -e "${RED}Project not found: $project${NC}"
                echo "Use: pwt project init $project"
                exit 1
            fi
            local tmp_file=$(mktemp)
            jq --arg key "$arg3" --arg value "$arg4" '.[$key] = $value' "$config_file" > "$tmp_file" && mv "$tmp_file" "$config_file"
            echo -e "${GREEN}✓ Updated $project.$arg3 = $arg4${NC}"
            ;;
        path)
            if [ -z "$project" ]; then
                echo -e "${RED}Error: Project name required${NC}"
                exit 1
            fi
            echo "$PROJECTS_DIR/$project"
            ;;
        *)
            echo -e "${RED}Unknown action: $action${NC}"
            echo "Usage: pwt project [list|init|show|set|path]"
            echo ""
            echo "Commands:"
            echo "  list              - List all configured projects"
            echo "  init <name>       - Initialize a new project config"
            echo "  show <name>       - Show project config and hooks"
            echo "  set <name> <k> <v> - Update project config value"
            echo "  path <name>       - Print project config directory path"
            exit 1
            ;;
    esac
}

# Command: port
# Get port for a worktree
cmd_port() {
    local name="$1"

    # If no name, try to detect from current directory
    if [ -z "$name" ]; then
        local current_dir=$(pwd)
        if [[ "$current_dir" == "$WORKTREES_DIR"/* ]]; then
            name=$(basename "$current_dir")
        else
            echo -e "${RED}Error: Not in a worktree directory${NC}" >&2
            exit 1
        fi
    fi

    init_metadata
    local port=$(get_metadata "$name" "port")

    if [ -z "$port" ]; then
        echo -e "${RED}Error: No port found for worktree: $name${NC}" >&2
        exit 1
    fi

    echo "$port"
}

# Parse global flags
while [[ "${1:-}" == --* ]]; do
    case "$1" in
        --project)
            CURRENT_PROJECT="$2"
            shift 2
            ;;
        --help|-h)
            set -- "help"
            break
            ;;
        *)
            echo -e "${RED}Unknown option: $1${NC}"
            exit 1
            ;;
    esac
done

# Initialize pwt
init_pwt

# Check if first argument is a project name or alias (before command dispatch)
# This allows: pwt myproject list (instead of pwt --project myproject list)
if [ -n "${1:-}" ]; then
    _resolved=$(resolve_project_alias "$1")
    if [ -d "$PWT_PROJECTS_DIR/${_resolved}" ]; then
        CURRENT_PROJECT="$_resolved"
        load_project_config "$_resolved"
        shift
    fi
    unset _resolved
fi

# Detect project from current directory (unless already set via --project or first arg)
detect_project

# Main command dispatch
case "${1:-}" in
    init)
        cmd_init "$2"
        ;;
    create)
        require_project --clone
        shift  # remove "create" from args
        cmd_create "$@"
        ;;
    list|ls)
        require_project --info-only
        shift  # remove "list" from args
        cmd_list "$@"
        ;;
    info|show)
        require_project
        cmd_info "$2"
        ;;
    remove|rm)
        require_project
        shift  # remove "remove" from args
        cmd_remove "$@"
        ;;
    server|s)
        require_project
        cmd_server
        ;;
    repair|fix)
        require_project
        cmd_repair "$2"
        ;;
    auto-remove|cleanup)
        require_project
        shift  # remove "auto-remove" from args
        cmd_auto_remove "$@"
        ;;
    fix-port)
        require_project
        cmd_fix_port "$2"
        ;;
    meta)
        cmd_meta "$2" "$3" "$4" "$5"
        ;;
    config)
        cmd_config "$2" "$3"
        ;;
    _cd)
        # Internal: output path for cd (used by shell function)
        require_project --info-only
        cmd_cd "$2"
        ;;
    run)
        require_project
        shift  # remove "run" from args
        cmd_run "$@"
        ;;
    editor|e)
        require_project
        cmd_editor "$2"
        ;;
    ai)
        require_project
        shift  # remove "ai" from args
        cmd_ai "$@"
        ;;
    open)
        require_project
        cmd_open "$2"
        ;;
    diff)
        require_project
        cmd_diff "$2" "$3"
        ;;
    conflicts)
        require_project
        cmd_conflicts "$2" "$3"
        ;;
    context)
        require_project
        cmd_context "$2"
        ;;
    copy|cp)
        require_project
        shift  # remove "copy" from args
        cmd_copy "$@"
        ;;
    marker)
        require_project
        shift  # remove "marker" from args
        cmd_marker "$@"
        ;;
    for-each)
        require_project
        shift  # remove "for-each" from args
        cmd_for_each "$@"
        ;;
    doctor)
        cmd_doctor
        ;;
    select)
        require_project --info-only
        shift  # remove "select" from args
        cmd_select "$@"
        ;;
    _select)
        require_project --info-only
        shift
        cmd__select "$@"
        ;;
    shell-init)
        cmd_shell_init "$2"
        ;;
    project)
        cmd_project "$2" "$3" "$4" "$5"
        ;;
    port)
        cmd_port "$2"
        ;;
    help|"")
        echo "pwt - Power Worktrees"
        echo "A tool for managing git worktrees across multiple projects"
        echo ""
        if [ -n "$CURRENT_PROJECT" ]; then
            echo -e "Current project: ${GREEN}$CURRENT_PROJECT${NC}"
            echo ""
        fi
        echo "Commands:"
        echo "  init [url]                     Initialize project (clone URL or configure current repo)"
        echo "  create <branch> [base] [desc]  Create new worktree (-e -a --from --from-current --dry-run)"
        echo "  list [flags]                   List worktrees (-v/--verbose, --dirty, --porcelain)"
        echo "  list statusline                Output for shell prompts"
        echo "  select [--preview]             Interactive worktree selector (fzf)"
        echo "  info [worktree]                Show worktree details"
        echo "  remove [worktree] [flags]      Remove worktree (--with-branch, --force-branch)"
        echo "  cd [worktree|@|-]              Navigate to worktree (@ main, - previous)"
        echo "  run <worktree> <cmd>           Run command in worktree"
        echo "  for-each <cmd>                 Run command in all worktrees"
        echo "  editor [worktree]              Open worktree in editor"
        echo "  ai [worktree] [-- args]        Start AI tool in worktree"
        echo "  open [worktree]                Open worktree in Finder"
        echo "  diff <wt1> [wt2]               Show diff between worktrees"
        echo "  conflicts [wt1] [wt2]          Show file overlap between worktrees"
        echo "  context [worktree]             Generate markdown context for AI"
        echo "  copy <src> <dest> <patterns>   Copy files between worktrees"
        echo "  marker [worktree] [emoji]      Set/show worktree marker (--clear)"
        echo "  server                         Start dev server (from Pwtfile)"
        echo "  fix-port [worktree]            Fix port conflict"
        echo "  auto-remove [target] [--dry-run] Remove worktrees merged into target"
        echo "  doctor                         Check system health and configuration"
        echo "  shell-init                     Output shell function for cd integration"
        echo "  meta [action] [args]           Manage worktree metadata"
        echo "  project [action] [args]        Manage project configs"
        echo ""
        echo "Project selection (in order of priority):"
        echo "  1. pwt <project> <command>     Project as first argument"
        echo "  2. pwt --project <name> ...    Explicit flag"
        echo "  3. Auto-detect from pwd        Inside project or worktree dir"
        echo ""
        echo "First time setup:"
        echo "  pwt project init myproject"
        echo "  pwt project set myproject main_app ~/path/to/app"
        echo "  pwt project set myproject worktrees_dir ~/path/to/worktrees"
        echo "  pwt project set myproject branch_prefix \"jp/\""
        echo ""
        echo "Examples:"
        echo "  pwt init git@github.com:user/app.git       # Clone and configure"
        echo "  pwt create TICKET-123 master \"fix\" -e -a  # Create + open editor + start AI"
        echo "  pwt create hotfix --from v1.2.3            # Create from tag"
        echo "  pwt list --dirty                           # Only show dirty worktrees"
        echo "  pwt run TICKET-123 npm test                # Run command in worktree"
        echo "  pwt diff TICKET-123                        # Diff worktree vs main"
        echo "  pwt auto-remove master --dry-run           # Preview cleanup"
        echo "  pwt doctor                                 # Check configuration"
        echo ""
        echo "Shell integration (add to ~/.zshrc):"
        echo "  eval \"\$(pwt shell-init)\""
        echo ""
        echo "After shell-init:"
        echo "  \$PWT_WORKTREE      Current worktree name (when in worktree)"
        echo "  \$PWT_PREVIOUS_PATH Previous path (enables 'pwt cd -')"
        ;;
    *)
        echo -e "${RED}Unknown command: $1${NC}"
        echo "Run 'pwt help' for usage"
        exit 1
        ;;
esac
