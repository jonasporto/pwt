#compdef pwt

# pwt - Power Worktrees completion
# Install: add to fpath and run compinit

_pwt_commands() {
    local commands=(
        'init:Initialize project (from current repo or URL)'
        'create:Create new worktree'
        'list:List worktrees and status'
        'ls:List worktrees and status'
        'cd:Navigate to worktree'
        'use:Set worktree as current'
        '-:Go to previous worktree'
        'info:Show worktree details'
        'show:Show worktree details'
        'remove:Remove worktree'
        'rm:Remove worktree'
        'server:Start development server'
        's:Start development server'
        'repair:Repair broken worktree'
        'fix:Repair broken worktree'
        'auto-remove:Remove merged worktrees'
        'cleanup:Remove merged worktrees'
        'restore:Recover backed up changes from trash'
        'fix-port:Resolve port conflict'
        'meta:Manage worktree metadata'
        'project:Manage project configs'
        'config:Configure current project'
        'port:Get port for worktree'
        'migrate:Migrate from old system'
        'setup-shell:Install shell integration'
        'shell-init:Output shell integration code'
        'shell:Interactive shell in worktree context'
        'help:Show help'
    )
    _describe 'command' commands
}

_pwt_worktrees() {
    local project="${1:-}"
    local worktrees
    # Use pwt list --names for accurate project detection
    # Pass --project if specified (for "pwt <project> cd <tab>" syntax)
    if [[ -n "$project" ]]; then
        worktrees=("${(@f)$(pwt --project "$project" list --names 2>/dev/null)}")
    else
        worktrees=("${(@f)$(pwt list --names 2>/dev/null)}")
    fi
    # Fallback to just @ if pwt fails (e.g., not in a project)
    [[ ${#worktrees[@]} -eq 0 ]] && worktrees=("@")
    _describe 'worktree' worktrees
}

_pwt_projects() {
    local projects
    if [[ -d ~/.pwt/projects ]]; then
        projects=(${(f)"$(ls ~/.pwt/projects/ 2>/dev/null)"})
        _describe 'project' projects
    fi
}

# Check if input matches a project (exact, partial, or alias)
_pwt_is_project() {
    local input="$1"
    # Exact match
    [[ -d ~/.pwt/projects/$input ]] && return 0
    # Partial match (e.g., "acme" matches "acme-app")
    local matches=(~/.pwt/projects/${input}*(N))
    [[ ${#matches[@]} -eq 1 ]] && return 0
    # Check aliases in all project configs
    for config in ~/.pwt/projects/*/config.json(N); do
        # Check "alias" (string) field
        local alias_val=$(jq -r '.alias // empty' "$config" 2>/dev/null)
        [[ "$alias_val" == "$input" ]] && return 0
        # Check "aliases" (array) field
        jq -e --arg a "$input" '.aliases // [] | index($a) != null' "$config" >/dev/null 2>&1 && return 0
    done
    return 1
}

# Resolve partial project name or alias to full name
_pwt_resolve_project() {
    local input="$1"
    # Exact match
    [[ -d ~/.pwt/projects/$input ]] && echo "$input" && return
    # Partial match
    local matches=(~/.pwt/projects/${input}*(N))
    if [[ ${#matches[@]} -eq 1 ]]; then
        basename "${matches[1]}"
        return
    fi
    # Check aliases in all project configs
    for config in ~/.pwt/projects/*/config.json(N); do
        local project=$(basename "$(dirname "$config")")
        # Check "alias" (string) field
        local alias_val=$(jq -r '.alias // empty' "$config" 2>/dev/null)
        [[ "$alias_val" == "$input" ]] && echo "$project" && return
        # Check "aliases" (array) field
        if jq -e --arg a "$input" '.aliases // [] | index($a) != null' "$config" >/dev/null 2>&1; then
            echo "$project"
            return
        fi
    done
}

_pwt_branches() {
    local branches
    branches=(${(f)"$(git branch -a 2>/dev/null | sed 's/^[* ]*//' | sed 's|remotes/||')"})
    _describe 'branch' branches
}

_pwt_meta_actions() {
    local actions=(
        'list:List all metadata'
        'show:Show metadata for worktree'
        'set:Update metadata field'
        'import:Import existing worktrees'
    )
    _describe 'action' actions
}

_pwt_project_actions() {
    local actions=(
        'list:List all projects'
        'init:Initialize new project'
        'show:Show project config'
        'set:Update project config'
        'path:Print config directory'
    )
    _describe 'action' actions
}

_pwt_config_keys() {
    local keys=(
        'main_app:Main app path'
        'worktrees_dir:Worktrees directory'
        'branch_prefix:Branch prefix (e.g. user/)'
        'base_port:Base port for allocation'
    )
    _describe 'key' keys
}

_pwt_meta_fields() {
    local fields=(
        'base:Base branch'
        'description:Worktree description'
        'branch:Git branch'
        'port:Port number'
    )
    _describe 'field' fields
}

_pwt_remove_flags() {
    local flags=(
        '--with-branch:Also delete the branch (if merged)'
        '--force-branch:Force delete the branch (even if not merged)'
        '--kill-port:Kill processes using the port (opt-in)'
        '--kill-sidekiq:Kill Sidekiq processes (opt-in)'
        '--kill-all:Kill both port and Sidekiq processes'
        '-y:Skip confirmation prompts'
        '--yes:Skip confirmation prompts'
    )
    _describe 'flag' flags
}

_pwt_backups() {
    local backups
    if [[ -d ~/.pwt/trash ]]; then
        # Get worktree names from JSON metadata (without timestamp suffix for easier typing)
        backups=(${(f)"$(find ~/.pwt/trash -maxdepth 1 -name '*.json' -exec jq -r '.worktree // empty' {} \; 2>/dev/null | sort -u)"})
        [[ ${#backups[@]} -eq 0 ]] && backups=(${(f)"$(find ~/.pwt/trash -maxdepth 1 -name '*.patch' -exec basename {} .patch \; 2>/dev/null | sed -E 's/_[0-9]{8}_[0-9]{6}$//' | sort -u)"})
        _describe 'backup' backups
    fi
}

_pwt() {
    local curcontext="$curcontext" state line
    typeset -A opt_args

    _arguments -C \
        '--project[Specify project]:project:_pwt_projects' \
        '1: :->command' \
        '*: :->args'

    case $state in
        command)
            # Check if first arg is a project name (exact or partial)
            if _pwt_is_project "$words[2]"; then
                local _proj="$(_pwt_resolve_project "$words[2]")"
                # After project: offer commands AND worktrees (for exec syntax)
                _alternative \
                    'commands:command:_pwt_commands' \
                    "worktrees:worktree:_pwt_worktrees $_proj"
            else
                _alternative \
                    'projects:project:_pwt_projects' \
                    'commands:command:_pwt_commands'
            fi
            ;;
        args)
            local cmd="${words[2]}"

            # Handle project as first arg (exact or partial match)
            if _pwt_is_project "$cmd"; then
                local _project="$(_pwt_resolve_project "$cmd")"
                cmd="${words[3]}"
                case $cmd in
                    create)
                        case $CURRENT in
                            4) _pwt_branches ;;
                            5) _pwt_branches ;;
                            *) _message 'description' ;;
                        esac
                        ;;
                    remove|rm)
                        _alternative \
                            "worktrees:worktree:_pwt_worktrees $_project" \
                            'flags:flag:_pwt_remove_flags'
                        ;;
                    cd|use|server|s|info|show|fix-port|port|shell)
                        _pwt_worktrees "$_project"
                        ;;
                    meta)
                        case $CURRENT in
                            4) _pwt_meta_actions ;;
                            5)
                                case ${words[4]} in
                                    show|set) _pwt_worktrees "$_project" ;;
                                esac
                                ;;
                            6)
                                case ${words[4]} in
                                    set) _pwt_meta_fields ;;
                                esac
                                ;;
                        esac
                        ;;
                    project)
                        case $CURRENT in
                            4) _pwt_project_actions ;;
                            5)
                                case ${words[4]} in
                                    show|set|path) _pwt_projects ;;
                                    init) _message 'project name' ;;
                                esac
                                ;;
                            6)
                                case ${words[4]} in
                                    set) _pwt_config_keys ;;
                                esac
                                ;;
                        esac
                        ;;
                    config)
                        case $CURRENT in
                            4) _pwt_config_keys ;;
                            *) _message 'value' ;;
                        esac
                        ;;
                    restore)
                        case $CURRENT in
                            4) _pwt_backups ;;
                            5) _pwt_worktrees "$_project" ;;
                        esac
                        ;;
                esac
            else
                case $cmd in
                    create)
                        case $CURRENT in
                            3) _pwt_branches ;;
                            4) _pwt_branches ;;
                            *) _message 'description' ;;
                        esac
                        ;;
                    remove|rm)
                        _alternative \
                            'worktrees:worktree:_pwt_worktrees' \
                            'flags:flag:_pwt_remove_flags'
                        ;;
                    cd|use|server|s|info|show|fix-port|repair|fix|port|shell)
                        _pwt_worktrees
                        ;;
                    auto-remove|cleanup)
                        _pwt_branches
                        ;;
                    restore)
                        case $CURRENT in
                            3) _pwt_backups ;;
                            4) _pwt_worktrees ;;
                        esac
                        ;;
                    meta)
                        case $CURRENT in
                            3) _pwt_meta_actions ;;
                            4)
                                case ${words[3]} in
                                    show|set) _pwt_worktrees ;;
                                esac
                                ;;
                            5)
                                case ${words[3]} in
                                    set) _pwt_meta_fields ;;
                                esac
                                ;;
                        esac
                        ;;
                    project)
                        case $CURRENT in
                            3) _pwt_project_actions ;;
                            4)
                                case ${words[3]} in
                                    show|set|path) _pwt_projects ;;
                                    init) _message 'project name' ;;
                                esac
                                ;;
                            5)
                                case ${words[3]} in
                                    set) _pwt_config_keys ;;
                                esac
                                ;;
                        esac
                        ;;
                    config)
                        case $CURRENT in
                            3) _pwt_config_keys ;;
                            *) _message 'value' ;;
                        esac
                        ;;
                esac
            fi
            ;;
    esac
}

_pwt "$@"
